@prefix ns1: <http://example.org/bok/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

"AI-Agents_Agents_and_Cognitive_Systems" ns1:content """Pages:79-79 HOURS CS Core = 0 KA Core = 0 AI-Agents: Agents and Cognitive
Systems Non-core: 1\\. Agent architectures (e.g., reactive, layered, cognitive)
2\\. Agent theory (including mathematical formalisms) 3\\. Rationality, Game
Theory a. Decision-theoretic agents b. Markov decision processes (MDP) c.
Bandit algorithms 4\\. Software agents, personal assistants, and information
access a. Collaborative agents b. Information-gathering agents c. Believable
agents (synthetic characters, modeling emotions in agents) 5\\. Learning agents
6\\. Cognitive systems a. Cognitive architectures (e.g., ACT-R, SOAR, ICARUS,
FORR) b. Capabilities (e.g., perception, decision making, prediction,
knowledge maintenance) c. Knowledge representation, organization, utilization,
acquisition, and refinement d. Applications and evaluation of cognitive
systems 7\\. Multi-agent systems a. Collaborating agents b. Agent teams c.
Competitive agents (e.g., auctions, voting) d. Swarm systems and biologically
inspired models e. Multi-agent learning 8\\. Human-agent interaction (See also:
HCI-User, HCI-Accessibility) a. Communication methodologies (verbal and non-
verbal) b. Practical issues c. Applications i. Trading agents, supply chain
management ii. Ethical issues of AI interactions with humans iii. Regulation
and legal requirements of AI systems for interacting with humans Illustrative
Learning Outcomes: 1\\. Characterize and contrast the standard agent
architectures. 2\\. Describe the applications of agent theory to domains such
as software agents, personal assistants, and believable agents, and discuss
associated ethical implications. 3\\. Describe the primary paradigms used by
learning agents. 4\\. Demonstrate using appropriate examples how multi-agent
systems support agent interaction. 5\\. Construct an intelligent agent using a
well-established cognitive architecture (ACT-R, SOAR) for solving a specific
problem."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Artificial_Intelligence_AI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Agents_Agents_and_Cognitive_Systems.txt> .

"AI-Introduction_Fundamental_Issues" ns1:content """Pages : 67-68 HOURS CS Core = 2 KA Core = 1 AI-Introduction: Fundamental
Issues CS Core: 1\\. Overview of AI problems, Examples of successful recent AI
applications 2\\. Definitions of agents with examples (e.g., reactive,
deliberative) 3\\. What is intelligent behavior? a. The Turing test and its
flaws b. Multimodal input and output c. Simulation of intelligent behavior d.
Rational versus non-rational reasoning 4\\. Problem characteristics a. Fully
versus partially observable b. Single versus multi-agent c. Deterministic
versus stochastic d. Static versus dynamic e. Discrete versus continuous 5\\.
Nature of agents 68 a. Autonomous, semi-autonomous, mixed-initiative autonomy
b. Reflexive, goal-based, and utility-based c. Decision making under
uncertainty and with incomplete information d. The importance of perception
and environmental interactions e. Learning-based agents f. Embodied agents i.
sensors, dynamics, effectors 6\\. Overview of AI Applications, growth, and
impact (economic, societal, ethics) KA Core: 7\\. Practice identifying problem
characteristics in example environments 8\\. Additional depth on nature of
agents with examples 9\\. Additional depth on AI Applications, Growth, and
Impact (economic, societal, ethics, security) Non-core: 10\\. Philosophical
issues 11\\. History of AI Illustrative Learning Outcomes: 1\\. Describe the
Turing test and the "Chinese Room" thought experiment. 2\\. Differentiate
between optimal reasoning/behavior and human-like reasoning/behavior. 3\\.
Differentiate the terms: AI, machine learning, and deep learning. 4\\.
Enumerate the characteristics of a specific problem."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "Artificial_Intelligence_AI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Introduction_Fundamental_Issues.txt> .

"AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning" ns1:content """Pages:70-70 HOURS CS Core = 2 KA Core = 2 AI-KRR: Fundamental Knowledge
Representation and Reasoning CS Core: 1\\. Types of representations a.
Symbolic, logical i. Creating a representation from a natural language problem
statement b. Learned subsymbolic representations c. Graphical models (e.g.,
naive Bayes, Bayesian network) 2\\. Review of probabilistic reasoning, Bayes
theorem (See also: MSF-Probability) 3\\. Bayesian reasoning a. Bayesian
inference KA Core: 4\\. Random variables and probability distributions a.
Axioms of probability b. Probabilistic inference c. Bayes' Rule (derivation)
d. Bayesian inference (more complex examples) 5\\. Independence 6\\. Conditional
Independence 7\\. Markov chains and Markov models 8\\. Utility and decision
making Illustrative Learning Outcomes: 1\\. Given a natural language problem
statement, encode it as a symbolic or logical representation. 2\\. Explain how
we can make decisions under uncertainty, using concepts such as Bayes theorem
and utility. 3\\. Compute a probabilistic inference in a real-world problem
using Bayes' theorem to determine the probability of a hypothesis given
evidence. 4\\. Apply Bayes' rule to determine the probability of a hypothesis
given evidence. 5\\. Compute the probability of outcomes and test whether
outcomes are independent. 71 AI-ML: Machine Learning CS Core: 1\\. Definition
and examples of a broad variety of machine learning tasks a. Supervised
learning i. Classification ii. Regression b. Reinforcement learning c.
Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability"""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Artificial_Intelligence_AI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt> .

"AI-LRR_Logical_Representation_and_Reasoning" ns1:content """Pages:76-77 HOURS CS Core = 0 KA Core = 0 AI-LRR: Logical Representation and
Reasoning Non-core: 77 1\\. Review of propositional and predicate logic (See
also: MSF-Discrete) 2\\. Resolution and theorem proving (propositional logic
only) a. Forward chaining, backward chaining 3\\. Knowledge representation
issues a. Description logics b. Ontology engineering 4\\. Semantic web 5\\. Non-
monotonic reasoning (e.g., non-classical logics, default reasoning) 6\\.
Argumentation 7\\. Reasoning about action and change (e.g., situation and event
calculus) 8\\. Temporal and spatial reasoning 9\\. Logic programming a. Prolog,
Answer Set Programming 10\\. Rule-based Expert Systems 11\\. Semantic networks
12\\. Model-based and Case-based reasoning Illustrative Learning Outcomes: 1\\.
Translate a natural language (e.g., English) sentence into a predicate logic
statement. 2\\. Convert a logic statement into clausal form. 3\\. Apply
resolution to a set of logic statements to answer a query. 4\\. Compare and
contrast the most common models used for structured knowledge representation,
highlighting their strengths and weaknesses. 5\\. Identify the components of
non-monotonic reasoning and its usefulness as a representational mechanism for
belief systems. 6\\. Compare and contrast the basic techniques for representing
uncertainty. 7\\. Compare and contrast the basic techniques for qualitative
representation. 8\\. Apply situation and event calculus to problems of action
and change. 9\\. Explain the distinction between temporal and spatial
reasoning, and how they interrelate. 10\\. Explain the difference between rule-
based, case-based, and model-based reasoning techniques. 11\\. Define the
concept of a planning system and how it differs from classical search
techniques. 12\\. Describe the differences between planning as search,
operator-based planning, and propositional planning, providing examples of
domains where each is most applicable. 13\\. Explain the distinction between
monotonic and non-monotonic inference."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Artificial_Intelligence_AI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt> .

"AI-ML_Machine_Learning" ns1:content """Pages:71-75 HOURS CS Core = 4 KA Core = 6 AI-ML: Machine Learning CS Core: 1\\.
Definition and examples of a broad variety of machine learning tasks a.
Supervised learning i. Classification ii. Regression b. Reinforcement learning
c. Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability in machine
learning 3\\. A simple statistical-based supervised learning such as linear
regression or decision trees a. Focus on how they work without going into
mathematical or optimization details; enough to understand and use existing
implementations correctly 4\\. The overfitting problem/controlling solution
complexity (regularization, pruning - intuition only) a. The bias
(underfitting) - variance (overfitting) tradeoff 5\\. Working with Data a. Data
preprocessing i. Importance and pitfalls of preprocessing choices b. Handling
missing values (imputing, flag-as-missing) i. Implications of imputing vs
flag-as-missing c. Encoding categorical variables, encoding real-valued data
d. Normalization/standardization e. Emphasis on real data, not textbook
examples 6\\. Representations a. Hypothesis spaces and complexity b. Simple
basis feature expansion, such as squaring univariate features c. Learned
feature representations 7\\. Machine learning evaluation a. Separation of
train, validation, and test sets b. Performance metrics for classifiers c.
Estimation of test performance on held-out data d. Tuning the parameters of a
machine learning model with a validation set e. Importance of understanding
what a model is doing, where its pitfalls/shortcomings are, and the
implications of its decisions 8\\. Basic neural networks a. Fundamentals of
understanding how neural networks work and their training process, without
details of the calculations b. Basic introduction to generative neural
networks (e.g., large language models) 9\\. Ethics for Machine Learning (See
also: SEP-Context) a. Focus on real data, real scenarios, and case studies b.
Dataset/algorithmic/evaluation bias and unintended consequences 72 KA Core:
10\\. Formulation of simple machine learning as an optimization problem, such
as least squares linear regression or logistic regression a. Objective
function b. Gradient descent c. Regularization to avoid overfitting
(mathematical formulation) 11\\. Ensembles of models a. Simple weighted
majority combination 12\\. Deep learning a. Deep feed-forward networks
(intuition only, no mathematics) b. Convolutional neural networks (intuition
only, no mathematics) c. Visualization of learned feature representations from
deep nets d. Other architectures (generative NN, recurrent NN, transformers,
etc.) 13\\. Performance evaluation a. Other metrics for classification (e.g.,
error, precision, recall) b. Performance metrics for regressors c. Confusion
matrix d. Cross-validation i. Parameter tuning (grid/random search, via cross-
validation) 14\\. Overview of reinforcement learning methods 15\\. Two or more
applications of machine learning algorithms a. E.g., medicine and health,
economics, vision, natural language, robotics, game play 16\\. Ethics for
Machine Learning a. Continued focus on real data, real scenarios, and case
studies (See also: SEP-Context) b. Privacy (See also: SEP-Privacy) c. Fairness
(See also: SEP-Privacy) d. Intellectual property e. Explainability Non-core:
17\\. General statistical-based learning, parameter estimation (maximum
likelihood) 18\\. Supervised learning a. Decision trees b. Nearest-neighbor
classification and regression c. Learning simple neural networks / multi-layer
perceptrons d. Linear regression e. Logistic regression f. Support vector
machines (SVMs) and kernels g. Gaussian Processes 19\\. Overfitting a. The
curse of dimensionality b. Regularization (mathematical computations, L2 and
L1 regularization) 20\\. Experimental design 73 a. Data preparation (e.g.,
standardization, representation, one-hot encoding) b. Hypothesis space c.
Biases (e.g., algorithmic, search) d. Partitioning data: stratification,
training set, validation set, test set e. Parameter tuning (grid/random
search, via cross-validation) f. Performance evaluation i. Cross-validation
ii. Metric: error, precision, recall, confusion matrix iii. Receiver operating
characteristic (ROC) curve and area under ROC curve 21\\. Bayesian learning
(Cross-Reference AI/Reasoning Under Uncertainty) a. Naive Bayes and its
relationship to linear models b. Bayesian networks c. Prior/posterior d.
Generative models 22\\. Deep learning a. Deep feed-forward networks b. Neural
tangent kernel and understanding neural network training c. Convolutional
neural networks d. Autoencoders e. Recurrent networks f. Representations and
knowledge transfer g. Adversarial training and generative adversarial networks
h. Attention mechanisms 23\\. Representations a. Manually crafted
representations b. Basis expansion c. Learned representations (e.g., deep
neural networks) 24\\. Unsupervised learning and clustering a. K-means b.
Gaussian mixture models c. Expectation maximization (EM) d. Self-organizing
maps 25\\. Graph analysis (e.g., PageRank) 26\\. Semi-supervised learning 27\\.
Graphical models (See also: AI-Probability) 28\\. Ensembles a. Weighted
majority b. Boosting/bagging c. Random forest d. Gated ensemble 29\\. Learning
theory a. General overview of learning theory / why learning works b. VC
dimension c. Generalization bounds 74 30\\. Reinforcement learning a.
Exploration vs exploitation tradeoff b. Markov decision processes c. Value and
policy iteration d. Policy gradient methods e. Deep reinforcement learning f.
Learning from demonstration and inverse RL 31\\. Explainable / interpretable
machine learning a. Understanding feature importance (e.g., LIME, Shapley
values) b. Interpretable models and representations 32\\. Recommender systems
33\\. Hardware for machine learning a. GPUs / TPUs 34\\. Application of machine
learning algorithms to: a. Medicine and health b. Economics c. Education d.
Vision e. Natural language f. Robotics g. Game play h. Data mining (Cross-
reference DM/Data Analytics) 35\\. Ethics for Machine Learning a. Continued
focus on real data, real scenarios, and case studies (See also: SEP-Context)
b. In depth exploration of dataset/algorithmic/evaluation bias, data privacy,
and fairness (See also: SEP-Privacy, SEP-Context) c. Trust / explainability
Illustrative Learning Outcomes: 1\\. Describe the differences among the three
main styles of learning (supervised, reinforcement, and unsupervised) and
determine which is appropriate to a particular problem domain. 2\\.
Differentiate the terms of AI, machine learning, and deep learning. 3\\. Frame
an application as a classification problem, including the available input
features and output to be predicted (e.g., identifying alphabetic characters
from pixel grid input). 4\\. Apply two or more simple statistical learning
algorithms to a classification task and measure the classifiers' accuracy. 5\\.
Identify overfitting in the context of a problem and learning curves and
describe solutions to overfitting. 6\\. Explain how machine learning works as
an optimization/search process. 7\\. Implement a statistical learning algorithm
and the corresponding optimization process to train the classifier and obtain
a prediction on new data. 8\\. Describe the neural network training process and
resulting learned representations. 75 9\\. Explain proper ML evaluation
procedures, including the differences between training and testing
performance, and what can go wrong with the evaluation process leading to
inaccurate reporting of ML performance. 10\\. Compare two machine learning
algorithms on a dataset, implementing the data preprocessing and evaluation
methodology (e.g., metrics and handling of train/test splits) from scratch.
11\\. Visualize the training progress of a neural network through learning
curves in a well-established toolkit (e.g., TensorBoard) and visualize the
learned features of the network. 12\\. Compare and contrast several learning
techniques (e.g., decision trees, logistic regression, naive Bayes, neural
networks, and belief networks), providing examples of when each strategy is
superior. 13\\. Evaluate the performance of a simple learning system on a real-
world dataset. 14\\. Characterize the state of the art in learning theory,
including its achievements and shortcomings. 15\\. Explain the problem of
overfitting, along with techniques for detecting and managing the problem.
16\\. Explain the triple tradeoff among the size of a hypothesis space, the
size of the training set, and performance accuracy. 17\\. Given a real-world
application of machine learning, describe ethical issues regarding the choices
of data, preprocessing steps, algorithm selection, and
visualization/presentation of results"""^^xsd:string ;
    ns1:cs_core_hours "4" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Artificial_Intelligence_AI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt> .

"AI-NLP_Natural_Language_Processing" ns1:content """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Artificial_Intelligence_AI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> .

"AI-Planning_Planning" ns1:content """Pages:78-78 HOURS CS Core = 0 KA Core = 0 AI-Planning: Planning Non-core: 1\\.
Review of propositional and first-order logic 2\\. Planning operators and state
representations 3\\. Total order planning 4\\. Partial-order planning 5\\. Plan
graphs and GraphPlan 6\\. Hierarchical planning 7\\. Planning languages and
representations a. PDDL 8\\. Multi-agent planning 9\\. MDP-based planning 10\\.
Interconnecting planning, execution, and dynamic replanning a. Conditional
planning b. Continuous planning c. Probabilistic planning Illustrative
Learning Outcomes: 1\\. Construct the state representation, goal, and operators
for a given planning problem. 2\\. Encode a planning problem in PDDL and use a
planner to solve it. 3\\. Given a set of operators, initial state, and goal
state, draw the partial-order planning graph and include ordering constraints
to resolve all conflicts. 4\\. Construct the complete planning graph for
GraphPlan to solve a given problem."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Artificial_Intelligence_AI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Planning_Planning.txt> .

"AI-Probability_Probabilistic_Representation_and_Reasoning" ns1:content """Pages:77-78 HOURS CS Core = 0 KA Core = 0 AI-Probability: Probabilistic
Representation and Reasoning Non-core: 1\\. Conditional Independence review 2\\.
Knowledge representations a. Bayesian Networks i. Exact inference and its
complexity ii. Markov blankets and d-separation iii. Randomized sampling
(Monte Carlo) methods (e.g., Gibbs sampling) b. Markov Networks 78 c.
Relational probability models d. Hidden Markov Models 3\\. Decision Theory a.
Preferences and utility functions b. Maximizing expected utility c. Game
theory Illustrative Learning Outcomes: 1\\. Compute the probability of a
hypothesis given the evidence in a Bayesian network. 2\\. Explain how
conditional independence assertions allow for greater efficiency of
probabilistic systems. 3\\. Identify examples of knowledge representations for
reasoning under uncertainty. 4\\. State the complexity of exact inference.
Identify methods for approximate inference. 5\\. Design and implement at least
one knowledge representation for reasoning under uncertainty. 6\\. Describe the
complexities of temporal probabilistic reasoning. 7\\. Design and implement an
HMM as one example of a temporal probabilistic system. 8\\. Describe the
relationship between preferences and utility functions. 9\\. Explain how
utility functions and probabilistic reasoning can be combined to make rational
decisions."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Artificial_Intelligence_AI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Probability_Probabilistic_Representation_and_Reasoning.txt> .

"AI-Robotics_Robotics" ns1:content """Pages:80-82 HOURS CS Core = 0 KA Core = 0 AI-Robotics: Robotics (See also:
SPD-Robot) Non-core: 1\\. Overview: problems and progress a. State-of-the-art
robot systems, including their sensors and an overview of their sensor
processing 81 b. Robot control architectures, e.g., deliberative vs reactive
control and Braitenberg vehicles c. World modeling and world models d.
Inherent uncertainty in sensing and in control 2\\. Sensors and effectors a.
Sensors: e.g., LIDAR, sonar, vision, depth, stereoscopic, event cameras,
microphones, haptics, b. Effectors: e.g., wheels, arms, grippers 3\\.
Coordinate frames, translation, and rotation (2D and 3D) 4\\. Configuration
space and environmental maps 5\\. Interpreting uncertain sensor data 6\\.
Localization and mapping 7\\. Navigation and control 8\\. Forward and inverse
kinematics 9\\. Motion path planning and trajectory optimization 10\\.
Manipulation and grasping 11\\. Joint control and dynamics 12\\. Vision-based
control 13\\. Multiple-robot coordination and collaboration 14\\. Human-robot
interaction (See also: HCI-User, HCI-Accessibility) a. Shared workspaces b.
Human-robot teaming and physical HRI c. Social assistive robots d.
Motion/task/goal prediction e. Collaboration and communication (explicit vs
implicit, verbal or symbolic vs non-verbal or visual) f. Trust 15\\.
Applications and Societal, Economic, and Ethical Issues a. Societal, economic,
right-to-work implications b. Ethical and privacy implications of robotic
applications c. Liability in autonomous robotics d. Autonomous weapons and
ethics e. Human oversight and control Illustrative Learning Outcomes: (Note:
Due to the expense of robot hardware, all of these could be done in simulation
or with low-cost educational robotic platforms.) 1\\. List capabilities and
limitations of today's state-of-the-art robot systems, including their sensors
and the crucial sensor processing that informs those systems. 2\\. Integrate
sensors, actuators, and software into a robot designed to undertake a specific
task. 3\\. Program a robot to accomplish simple tasks using deliberative,
reactive, and/or hybrid control architectures. 4\\. Implement fundamental
motion planning algorithms within a robot configuration space. 5\\.
Characterize the uncertainties associated with common robot sensors and
actuators; articulate strategies for mitigating these uncertainties. 6\\. List
the differences among robots' representations of their external environment,
including their strengths and shortcomings. 82 7\\. Compare and contrast at
least three strategies for robot navigation within known and/or unknown
environments, including their strengths and shortcomings. 8\\. Describe at
least one approach for coordinating the actions and sensing of several robots
to accomplish a single task. 9\\. Compare and contrast a multi-robot
coordination and a human-robot collaboration approach and attribute their
differences to differences between the problem settings. 10\\. Analyze the
societal, economic, and ethical issues of a real-world robotics application."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Artificial_Intelligence_AI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Robotics_Robotics.txt> .

"AI_SEP_Applications_and_Societal_Impact" ns1:content """Pages:75-76 HOURS CS Core = 3 KA Core = 3 AI-SEP: Applications and Societal
Impact Note: There is substantial benefit to studying applications and
ethics/fairness/trust/explainability in a curriculum alongside the methods and
theory that they apply to, rather than covering ethics in a separate,
dedicated class session. Whenever possible, study of these topics should be
integrated alongside other modules, such as exploring how decision trees could
be applied to a specific problem in environmental sustainability such as land
use allocation, then assessing the social/environmental/ethical implications
of doing so. CS Core: 1\\. At least one application of AI to a specific problem
and field, such as medicine, health, sustainability, social media, economics,
education, robotics, etc. (choose at least one for the CS Core). a.
Formulating and evaluating a specific application as an AI problem i. How to
deal with underspecified or ill-posed problems b. Data availability/scarcity
and cleanliness i. Basic data cleaning and preprocessing ii. Data set bias c.
Algorithmic bias d. Evaluation bias e. Assessment of societal implications of
the application 2\\. Deployed deep generative models a. High-level overview of
deep image generative models (e.g., as of 2023, DALL-E, Midjourney, Stable
Diffusion, etc.), their uses, and their shortcomings/pitfalls. b. High-level
overview of large language models (e.g., as of 2023, ChatGPT, Bard, etc.),
their uses, and their shortcomings/pitfalls. 3\\. Overview of societal impact
of AI 76 a. Ethics (See also: SEP-Context) b. Fairness (See also: SEP-Privacy,
SEP-DEIA) c. Trust/explainability (See also: SEP-Context) d. Privacy and usage
of training data (See also: SEP-Privacy) e. Human autonomy and
oversight/regulations/legal requirements (See also: SEP-Context) f.
Sustainability (See also: SEP-Sustainability) KA Core: 4\\. One or more
additional applications of AI to a broad set of problems and diverse fields,
such as medicine, health, sustainability, social media, economics, education,
robotics, etc. (choose a different area from that chosen for the CS Core). a.
Formulating and evaluating a specific application as an AI problem i. How to
deal with underspecified or ill-posed problems b. Data availability/scarcity
and cleanliness i. Basic data cleaning and preprocessing ii. Data set bias c.
Algorithmic bias d. Evaluation bias e. Assessment of societal implications of
the application 5\\. Additional depth on deployed deep generative models a.
Introduction to how deep image generative models work, (e.g., as of 2023,
DALL-E, Midjourney, Stable Diffusion) including discussion of attention b.
Introduction to how large language models work, (e.g., as of 2023, ChatGPT,
Bard) including discussion of attention c. Idea of foundational models, how to
use them, and the benefits/issues with training them from big data 6\\.
Analysis and discussion of the societal impact of AI a. Ethics (See also: SEP-
Context) b. Fairness (See also: SEP-Privacy, SEP-DEIA) c. Trust/explainability
(See also: SEP-Context) d. Privacy and usage of training data (See also: SEP-
Privacy) e. Human autonomy and oversight/regulations/legal requirements (See
also: SEP-Context) f. Sustainability (See also: SEP-Sustainability)
Illustrative Learning Outcomes: 1\\. Given a real-world application domain and
problem, formulate an AI solution to it, identifying proper data/input,
preprocessing, representations, AI techniques, and evaluation
metrics/methodology. 2\\. Analyze the societal impact of one or more specific
real-world AI applications, identifying issues regarding ethics, fairness,
bias, trust, and explainability. 3\\. Describe some of the failure modes of
current deep generative models for language or images, and how this could
affect their use in an application."""^^xsd:string ;
    ns1:cs_core_hours "3" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Artificial_Intelligence_AI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_SEP_Applications_and_Societal_Impact.txt> .

"AI_Search_Search" ns1:content """AI-Search: Search Pages: 68-70 HOURS CS Core = 5 KA Core = 6 AI-Search: Search
CS Core: 1\\. State space representation of a problem a. Specifying states,
goals, and operators b. Factoring states into representations (hypothesis
spaces) c. Problem solving by graph search i. e.g., Graphs as a space, and
tree traversals as exploration of that space ii. Dynamic construction of the
graph (not given upfront) 2\\. Uninformed graph search for problem solving (See
also: AL-Foundational) a. Breadth-first search b. Depth-first search i. With
iterative deepening c. Uniform cost search 3\\. Heuristic graph search for
problem solving (See also: AL-Strategies) a. Heuristic construction and
admissibility b. Hill-climbing c. Local minima and the search landscape i.
Local vs global solutions d. Greedy best-first search e. A* search 69 4\\.
Space and time complexities of graph search algorithms KA Core: 5\\.
Bidirectional search 6\\. Beam search 7\\. Two-player adversarial games a.
Minimax search b. Alpha-beta pruning i. Ply cutoff 8\\. Implementation of A*
search 9\\. Constraint satisfaction Non-core: 10\\. Understanding the search
space a. Constructing search trees b. Dynamic search spaces c. Combinatorial
explosion of search space d. Search space topology (e.g., ridges, saddle
points, local minima) 11\\. Local search 12\\. Tabu search 13\\. Variations on A*
(IDA*, SMA*, RBFS) 14\\. Two-player adversarial games a. The horizon effect b.
Opening playbooks/endgame solutions c. What it means to "solve" a game (e.g.,
checkers) 15\\. Implementation of minimax search, beam search 16\\. Expectimax
search (MDP-solving) and chance nodes 17\\. Stochastic search a. Simulated
annealing b. Genetic algorithms c. Monte-Carlo tree search Illustrative
Learning Outcomes: 1\\. Design the state space representation for a puzzle
(e.g., N-queens or 3-jug problem) 2\\. Select and implement an appropriate
uninformed search algorithm for a problem (e.g., tic-tac-toe), and
characterize its time and space complexities. 3\\. Select and implement an
appropriate informed search algorithm for a problem after designing a helpful
heuristic function (e.g., a robot navigating a 2D gridworld). 4\\. Evaluate
whether a heuristic for a given problem is admissible/can guarantee an optimal
solution. 5\\. Apply minimax search in a two-player adversarial game (e.g.,
connect four), using heuristic evaluation at a particular depth to compute the
scores to back up. [KA Core] 6\\. Design and implement a genetic algorithm
solution to a problem. 7\\. Design and implement a simulated annealing schedule
to avoid local minima in a problem. 70 8\\. Design and implement A*/beam search
to solve a problem, and compare it against other search algorithms in terms of
the solution cost, number of nodes expanded, etc. 9\\. Apply minimax search
with alpha-beta pruning to prune search space in a two-player adversarial game
(e.g., connect four). 10\\. Compare and contrast genetic algorithms with
classic search techniques, explaining when it is most appropriate to use a
genetic algorithm to learn a model versus other forms of optimization (e.g.,
gradient descent). 11\\. Compare and contrast various heuristic searches vis-a-
vis applicability to a given problem. 12\\. Model a logic or Sudoku puzzle as a
constraint satisfaction problem, solve it with backtrack search, and determine
how much arc consistency can reduce the search space."""^^xsd:string ;
    ns1:cs_core_hours "5" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Artificial_Intelligence_AI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_Search_Search.txt> .

"AL-Complexity_Complexity" ns1:content """Pages:91-93 HOURS CS Core = 6 KA Core = 3 AL-Complexity: Complexity CS Core:
1\\. Complexity Analysis Framework a. Best, average, and worst-case performance
of an algorithm b. Empirical and relative (Order of Growth) measurements c.
Input size and primitive operations d. Time and space efficiency 2\\.
Asymptotic complexity analysis (average and worst-case bounds) a. Big-O, Big-
Omega, and Big-Theta formal notations b. Foundational Complexity Classes and
Representative Examples/Problems i. O(1) Constant (e.g., array access) ii.
O(log2 n) Logarithmic (e.g., binary search) iii. O(n) Linear (e.g., linear
search) iv. O(n log2 n) Log Linear (e.g., mergesort) v. O(n2) Quadratic (e.g.,
selection sort) vi. O(nc) Polynomial (e.g., O(n3) Gaussian elimination) vii.
O(2n) Exponential (e.g., Knapsack, Satisfiability (SAT), Traveling Sales-
Person (TSP), all subsets) viii. O(n!) Factorial (e.g., Hamiltonian circuit,
all permutations) 3\\. Empirical measurements of performance 4\\. Tractability
and intractability a. P, NP, and NP-Complete Complexity Classes b. NP-Complete
Problems (e.g., SAT, Knapsack, TSP) c. Reductions 5\\. Time and space tradeoffs
in algorithms 92 KA Core: 6\\. Little-o, Little-Omega, and Little Theta
notations 7\\. Formal recursive analysis 8\\. Amortized analysis 9\\. Turing
Machine-based models of complexity a. Time complexity i. P, NP, NP-C, and EXP
classes ii. Cook-Levin theorem b. Space Complexity i. NSpace and PSpace ii.
Savitch's theorem Illustrative Learning Outcomes: CS Core: 1\\. Prepare a
presentation that explains to first year students the basic concepts of
algorithmic complexity including best, average, and worst-case algorithm
behavior, Big- O, Omega, and Theta notations, complexity classes, time and
space tradeoffs, empirical measurement, and impact on practical problems. 2\\.
Using examples, explain each of the foundational complexity classes in this
unit. 3\\. For each foundational complexity class in this unit, explain an
algorithm that demonstrates the associated runtime complexity. 4\\. For each
algorithm in the AL-Foundational unit, explain its runtime complexity class
and why it belongs to this class. 5\\. Informally evaluate the foundational
complexity class of simple algorithms. 6\\. Given a problem to program for
which there may be several algorithmic approaches, evaluate them and determine
which are feasible, and select one that is optimal in implementation and run-
time behavior. 7\\. Develop empirical studies to determine and validate
hypotheses about the runtime complexity of various algorithms by running
algorithms on input of various sizes and comparing actual performance to the
theoretical analysis. 8\\. Explain examples that illustrate time-space
tradeoffs of algorithms. 9\\. Explain how tree balance affects the efficiency
of binary search tree operations. 10\\. Explain to a non-technical audience the
significance of tractable versus intractable algorithms using an intuitive
explanation of Big-O complexity. 11\\. Explain the significance of NP-
Completeness. 12\\. Explain how NP-Hard is a lower bound and NP is an upper
bound for NP-Completeness. 13\\. Explain examples of NP-complete problems. KA
Core: 14\\. Use recurrence relations to evaluate the time complexity of
recursively defined algorithms. 15\\. Apply elementary recurrence relations
using a form of the Master Theorem. 16\\. Apply Big-O notation to give upper
case bounds on time/space complexity of algorithms. 17\\. Explain the Cook-
Levin Theorem and the NP-Completeness of SAT. 93 18\\. Explain the classes P
and NP. 19\\. Prove that a problem is NP-Complete by reducing a classic known
NP-C problem to it (e.g., 3SAT and Clique). 20\\. Explain the P-space class and
its relation to the EXP class."""^^xsd:string ;
    ns1:cs_core_hours "6" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Algorithmic_Foundations_AL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt> .

"AL-Models_Computational_Models_and_Formal_Languages" ns1:content """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
    ns1:cs_core_hours "9" ;
    ns1:ka_core_hours "23" ;
    ns1:part_of "Algorithmic_Foundations_AL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> .

"AL-SEP_Society_Ethics_and_the_Profession" ns1:content """Pages:95-95 HOURS CS Core = ? KA Core = ? AL-SEP: Society, Ethics, and the
Profession CS Core: (See also: SEP-Context, SEP-Sustainability) 1\\. Social,
ethical, and secure algorithms 2\\. Algorithmic fairness 3\\. Anonymity (e.g.,
Differential Privacy) 4\\. Accountability/Transparency 5\\. Responsible
algorithms 6\\. Economic and other impacts of inefficient algorithms 7\\.
Sustainability KA Core: 8\\. Context aware computing Illustrative Learning
Outcomes: CS Core: 1\\. Develop algorithmic solutions to real-world societal
problems, such as routing an ambulance to a hospital. 2\\. Explain the impact
that an algorithm may have on the environment and society when used to solve a
real-world problem while considering its sustainability and that it can affect
different societal groups in different ways. 3\\. Prepare a presentation that
justifies the selection of appropriate data structures and/or algorithms to
solve a given real-world problem. 4\\. Explain an example that articulates how
differential privacy protects knowledge of an individual's data. 5\\. Explain
the environmental impacts of design choices that relate to algorithm design.
6\\. Explain the tradeoffs involved in proof-of-work and proof-of-stake
algorithms."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Algorithmic_Foundations_AL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-SEP_Society_Ethics_and_the_Profession.txt> .

"AR-Heterogeneity_Heterogeneous_Architectures" ns1:content """Pages:107-107 HOURS CS Core = 0 KA Core = 2 AR-Heterogeneity: Heterogeneous
Architectures KA Core: 1\\. SIMD and MIMD architectures (e.g., General-Purpose
GPUs, TPUs, and NPUs) (See also: PDC- Programs, SPD-Embedded, GIT-Shading,
SPD-Game) 2\\. Heterogeneous memory systems (See also: OS-Process, PDC-
Communication) a. Shared memory versus distributed memory b. Volatile vs non-
volatile memory c. Coherence protocols 3\\. Domain-Specific Architectures
(DSAs) (See also: HCI-Accountability, GIT-Shading) a. Machine Learning
Accelerator b. In-networking computing (See also: NC-Applications) c. Embedded
systems for emerging applications d. Neuromorphic computing e. Edge computing
devices 4\\. Packaging and integration solutions such as 3DIC and chiplets 5\\.
Machine learning in architecture design a. AI algorithms for workload analysis
b. Optimization of architecture configurations for performance and power
efficiency Illustrative Learning Outcomes: KA Core 1\\. Analyze a system
diagram with alternative parallel architectures, e.g., SIMD and MIMD, and
identify the key differences. 2\\. Discuss what memory-management issues are
found in multiprocessors that are not present in uniprocessors and how these
issues might be resolved. 3\\. Indicate the differences between memory
backplane, processor memory interconnect, and remote memory via networks,
their implications for access latency, and their impact on program
performance. 4\\. Discuss how you would determine when to use a domain-specific
accelerator instead of a general- purpose CPU. 5\\. Enumerate key differences
in architectural design principles between a vector and scalar-based
processing unit. 6\\. List the advantages and disadvantages of a PIM
architecture."""^^xsd:string ;
    ns1:cs_core_hours "0" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Architecture_and_Organization_AR" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Heterogeneity_Heterogeneous_Architectures.txt> .

"AR-IO_Interfacing_and_Communication" ns1:content """Pages:105-105 HOURS CS Core = 1 KA Core = 0 AR-IO: Interfacing and
Communication CS Core: 1\\. I/O fundamentals (See also: OS-Devices, PDC-
Communication) a. Handshaking and buffering b. Programmed I/O c. Interrupt-
driven I/O (See also: OS-Principles) 2\\. Interrupt structures: vectored and
prioritized, interrupt acknowledgment (See also: OS-Principles) 3\\. I/O
devices (e.g., mouse, keyboard, display, camera, sensors, actuators) (See
also: GIT- Fundamentals, GIT-Interaction, OS-Advanced-Files, PDC-Programs) 4\\.
External storage, physical organization, and drives 5\\. Buses fundamentals
(See also: OS-Devices) a. Bus protocols b. Arbitration c. Direct-memory access
(DMA) Illustrative Learning Outcomes: CS Core: 1\\. Analyze an interrupt
control diagram to comment on how interrupts are used to implement I/O control
and data transfers. 2\\. Enumerate various types of buses in a computer system.
3\\. List the advantages of magnetic disks and contrast them with those of
solid-state disks."""^^xsd:string ;
    ns1:cs_core_hours "1" ;
    ns1:ka_core_hours "0" ;
    ns1:part_of "Architecture_and_Organization_AR" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-IO_Interfacing_and_Communication.txt> .

"AR-Logic_Digital_Logic_and_Digital_Systems" ns1:content """Pages:102-103 HOURS CS Core = 0 KA Core = 3 AR-Logic: Digital Logic and
Digital Systems KA Core: 1\\. Combinational vs sequential logic/field
programmable gate arrays (FPGAs) (See also: SF- Overview, SF-Foundations, SPD-
Embedded) a. Fundamental combinational b. Sequential logic building block 2\\.
Computer-aided design tools that process hardware and architectural
representations 3\\. High-level synthesis a. Register transfer notation b.
Hardware description language (e.g., Verilog/VHDL/Chisel) 4\\. System-on-chip
(SoC) design flow 5\\. Physical constraints a. Gate delays b. Fan-in and fan-
out c. Energy/power d. Speed of light Illustrative Learning Outcomes: 103 KA
Core: 1\\. Discuss the progression of computer technology components from
vacuum tubes to VLSI, from mainframe computer architectures to the
organization of warehouse-scale computers. 2\\. Describe parallelism and data
dependencies between and within components in a modern heterogeneous computer
architecture. 3\\. Explain the relationship between parallelism and power
consumption. 4\\. Construct the design of basic building blocks for a computer:
arithmetic-logic unit (gate-level), registers (gate-level), central processing
unit (register transfer-level), and memory (register transfer- level). 5\\.
Evaluate simple building blocks (e.g., arithmetic-logic unit, registers,
movement between registers) of a simple computer design. 6\\. Analyze the
timing behavior of a pipelined processor, identifying data dependency issues."""^^xsd:string ;
    ns1:cs_core_hours "0" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Architecture_and_Organization_AR" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Logic_Digital_Logic_and_Digital_Systems.txt> .

"AR-Memory_Memory_Hierarchy" ns1:content """Pages:104-105 HOURS CS Core = 6 KA Core = 0 AR-Memory: Memory Hierarchy CS
Core: 1\\. Memory hierarchy: the importance of temporal and spatial locality
(See also: SF-Performance, OS- Memory) 2\\. Main memory organization and
operations (See also: OS-Memory) 3\\. Persistent memory (e.g., SSD, standard
disks) 4\\. Latency, cycle time, bandwidth, and interleaving (See also: SF-
Performance) 5\\. Cache memories (See also: SF-Performance) a. Address mapping
b. Block size 105 c. Replacement and store policy d. Prefetching 6\\.
Multiprocessor cache coherence (See also: OS-Scheduling) 7\\. Virtual memory
(hardware support) (See also: OS-Memory) 8\\. Fault handling and reliability
(See also: SF-Reliability) 9\\. Reliability (See also: SF-Reliability, OS-
Faults) a. Error coding b. Data compression c. Data integrity KA Core: 10\\.
Processing In-Memory (PIM) Illustrative Learning Outcomes: CS Core: 1\\. Using
a memory system diagram, identify the main types of memory technology (e.g.,
SRAM, DRAM) and their relative cost and performance. 2\\. Measure the effect of
memory latency on running time. 3\\. Enumerate the functions of a system with
virtual memory management. 4\\. Compute average memory access time under
various cache and memory configurations and mixes of instruction and data
references."""^^xsd:string ;
    ns1:cs_core_hours "6" ;
    ns1:ka_core_hours "0" ;
    ns1:part_of "Architecture_and_Organization_AR" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Memory_Memory_Hierarchy.txt> .

"AR-Organization_Functional_Organization" ns1:content """Pages:106-106 HOURS CS Core = 0 KA Core = 2 AR-Organization: Functional
Organization KA Core: 1\\. Implementation of simple datapaths, including
instruction pipelining, hazard detection, and resolution (e.g., stalls,
forwarding) 2\\. Control unit a. Hardwired implementation b. Microprogrammed
realization 3\\. Instruction pipelining (See also: SF-Overview) 4\\.
Introduction to instruction-level parallelism (ILP) (See also: PDC-Programs)
Illustrative Learning Outcomes: KA Core: 1\\. Compare alternative
implementation of datapaths in modern computer architectures. 2\\. Produce a
set of control signals for adding two integers using hardwired and
microprogrammed implementations. 3\\. Discuss instruction-level parallelism
using pipelining and significant hazards that may occur. 4\\. Design a complete
processor, including datapath and control. 5\\. Compute the average cycles per
instruction for a given processor and memory system implementation."""^^xsd:string ;
    ns1:cs_core_hours "0" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Architecture_and_Organization_AR" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Organization_Functional_Organization.txt> .

"AR-Performance-Energy_Performance_and_Energy_Efficiency" ns1:content """Pages:106-107 HOURS CS Core = 0 KA Core = 3 AR-Performance-Energy: Performance
and Energy Efficiency KA Core: 1\\. Performance-energy evaluation
(introduction): performance, power consumption, memory, and communication
costs (See also: SF-Evaluation, OS-Scheduling, SPD-Game) 2\\. Branch
prediction, speculative execution, out-of-order execution, Tomasulo's
algorithm 3\\. Enhancements for vector processors and GPUs (See also: SPD-Game)
4\\. Hardware support for multithreading (See also: OS-Concurrency, OS-
Scheduling, PDC-Programs) a. Race conditions b. Lock implementations c. Point-
to-point synchronization d. Barrier implementation 5\\. Scalability 6\\.
Alternative architectures including VLIW/EPIC, accelerators, and other special
purpose processors 7\\. Dynamic voltage and frequency scaling (DVFS) 8\\. Dark
Silicon Illustrative Learning Outcomes: KA Core: 1\\. Discuss performance and
energy efficiency evaluation metrics. 2\\. Analyze a speculative execution
diagram and write about the decisions that can be made. 3\\. Create a GPU
performance-watt benchmarking diagram. 4\\. Write a multithreaded program that
adds (in parallel) elements of two integer vectors. 5\\. Recommend a set of
design choices for alternative computer architectures. 107 6\\. Enumerate key
concepts associated with dynamic voltage and frequency scaling. 7\\. Measure
energy savings improvement for an 8-bit integer quantization compared to a
32-bit quantization."""^^xsd:string ;
    ns1:cs_core_hours "0" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Architecture_and_Organization_AR" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Performance-Energy_Performance_and_Energy_Efficiency.txt> .

"AR-Representation_Machine-Level_Data_Representation" ns1:content """Pages:103-103 HOURS CS Core = 1 KA Core = 0 AR-Representation: Machine-Level
Data Representation CS Core: 1\\. Overview and history of computer architecture
(See also: SPD-Game) 2\\. Bits, bytes, and words 3\\. Unsigned, signed and two's
complement representations 4\\. Numeric data representation and number bases a.
Fixed-point b. Floating-point 5\\. Representation of non-numeric data 6\\.
Representation of records, arrays and UTF data types (See also: AL-
Foundational) Illustrative Learning Outcomes: CS Core: 1\\. Discuss why
everything in computers are data, including instructions. 2\\. Explain how
fixed-length number representations can affect accuracy and precision. 3\\.
Describe how negative integers are stored in sign-magnitude and
two's-complement representations. 4\\. Discuss how different formats can
represent numerical data. 5\\. Explain the bit-level representation of non-
numeric data, such as characters, strings, records, and arrays. 6\\. Translate
numerical data from one format to another. 7\\. Describe how a single adder
(without overflow detection) can handle both signed (two's complement) and
unsigned (binary) input without "knowing" which format a given input is using."""^^xsd:string ;
    ns1:cs_core_hours "1" ;
    ns1:ka_core_hours "0" ;
    ns1:part_of "Architecture_and_Organization_AR" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Representation_Machine-Level_Data_Representation.txt> .

"AR-SEP_Sustainability_Issues" ns1:content """Pages:109-109 HOURS CS Core = ? KA Core = ? AR-SEP: Sustainability Issues Non-
core: 1\\. Environmental impacts of implementation decisions a. Sustainability
goals, resource consumption, and economic viability b. Carbon footprint,
hardware electronic waste c. The energy footprint of data centers at various
workloads (e.g., AI model training and use) d. Guidelines for sustainable
design standards Illustrative Learning Outcomes: Non-core: 1\\. Assess the
environmental impacts of a given project's deployment (e.g., the energy
consumption of CPUs and GPUs, contribution to e-waste, and effect of hardware
virtualization in data centers)."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Architecture_and_Organization_AR" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-SEP_Sustainability_Issues.txt> .

"AR-Security_Secure_Processor_Architectures" ns1:content """Pages:107-108 HOURS CS Core = 0 KA Core = 2 AR-Security: Secure Processor
Architectures KA core: 1\\. Principles of Secure Hardware a. Security Risk
Analysis, Asset Protection, and Threat Model b. Cryptographic Acceleration
with Hardware (See also: SEC-Crypto) 108 c. Support for virtualization (e.g.,
OS isolation) 2\\. Roots of trust in hardware, Physically Unclonable Functions
(PUF) 3\\. Hardware Random Number Generators 4\\. Memory protection extensions
a. Runtime pointer bounds checking (e.g., buffer overflow) b. Protection at
the microarchitectural level c. Protection at the ISA level 5\\. Trusted
Execution Environment (TEE) a. Trusted Computer Base Protections b. Protecting
virtual machines c. Protecting containers d. Trusted software modules
(Enclaves) 6\\. Homomorphic encryption for privacy-preserving data processing
Illustrative Learning Outcomes KA Core: 1\\. Discuss principles of secure
hardware, exploring a framework for risk analysis and asset protection. 2\\.
Summarize how Physically Unclonable Functions (PUF) can be a unique device
identifier in security applications. 3\\. Distinguish a random number generator
with dedicated hardware support from generators without hardware dedicated to
generating entropy. 4\\. List the advantages and disadvantages of memory
protection at the ISA level. 5\\. Describe key design issues of a trusted
execution environment (TEE) to support virtual machines."""^^xsd:string ;
    ns1:cs_core_hours "0" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Architecture_and_Organization_AR" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Security_Secure_Processor_Architectures.txt> .

"DM-Analytics_Data_Analytics" ns1:content """Pages: 121-122 HOURS CS Core = 0 KA Core = 3 DM-Analytics: Data Analytics KA
Core: 1\\. Exploratory data techniques (motivation, representation, descriptive
statistics, visualizations) 2\\. Data science lifecycle: business
understanding, data understanding, data preparation, modeling, evaluation,
deployment, and user acceptance (See also: AI-ML) 3\\. Data mining and machine
learning algorithms: e.g., classification, clustering, association, regression
(See also: AI-ML) 4\\. Data acquisition and governance (See also: SEC-
Governance) 5\\. Data security and privacy considerations (See also: SEP-
Security, SEP-Privacy, SEC-Foundations) 6\\. Data fairness and bias (See also:
SEP-Security, AI-SEP) 7\\. Data visualization techniques and their use in data
analytics (See also: GIT-Visualization) 8\\. Entity Resolution Illustrative
Learning Outcomes: KA Core: 1\\. Describe several data exploration approaches,
including visualization, to understanding unfamiliar datasets. 2\\. Apply
several data exploration approaches to understanding unfamiliar datasets. 3\\.
Describe basic machine learning/data mining algorithms and when they are
appropriate for use. 4\\. Apply several machine learning/data mining
algorithms. 5\\. Describe legal and ethical considerations in acquiring, using,
and modifying datasets. 6\\. Describe issues of fairness and bias in data
collection and usage."""^^xsd:string ;
    ns1:cs_core_hours "0" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-Analytics_Data_Analytics.txt> .

"DM-Core_Core_Database_System_Concepts" ns1:content """Pages: 115-116 HOURS CS Core = 2 KA Core = 1 DM-Core: Core Database System
Concepts CS Core: 1\\. Purpose and advantages of database systems 2\\.
Components of database systems 3\\. Design of core DBMS functions (e.g., query
mechanisms, transaction management, buffer management, access methods) 4\\.
Database architecture, data independence, and data abstraction 5\\. Transaction
management 6\\. Normalization 7\\. Approaches for managing large volumes of data
(e.g., NoSQL database systems, use of MapReduce) (See also: PDC-Algorithms)
8\\. How to support CRUD-only applications 9\\. Distributed databases/cloud-
based systems 10\\. Structured, semi-structured, and unstructured data 11\\. Use
of a declarative query language KA Core: 12\\. Systems supporting structured
and/or stream content Illustrative Learning Outcomes: CS Core: 1\\. Identify at
least four advantages that using a database system provides. 2\\. Enumerate the
components of a (relational) database system. 3\\. Follow a query as it is
processed by the components of a (relational) database system. 4\\. Defend the
value of data independence. 5\\. Compose a simple select-project-join query in
SQL. 6\\. Enumerate the four properties of a correct transaction manager. 7\\.
Describe the advantages for eliminating duplicate repeated data. 8\\. Outline
how MapReduce uses parallelism to process data efficiently. 9\\. Evaluate the
differences between structured and semi/unstructured databases."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-Core_Core_Database_System_Concepts.txt> .

"DM-Data_The_Role_of_Data_and_the_Data_Life_Cycle" ns1:content """Pages: 115 HOURS CS Core = 2 KA Core = 0 DM-Data: The Role of Data and the
Data Life Cycle CS Core: 1\\. The Data Life Cycle: Creation-Processing-
Review/Reporting-Retention/Retrieval-Destruction (See also: SEP-Context, SEP-
Ethical-Analysis, SEP-Professional-Ethics, SEP-Privacy, SEP-Security, SEC-
Foundations) Illustrative Learning Outcomes: CS Core: 1\\. Identify the five
stages of the Data Life Cycle."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "0" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-Data_The_Role_of_Data_and_the_Data_Life_Cycle.txt> .

"DM-Distributed_Distributed_DatabasesCloud_Computing" ns1:content """Pages: 122 HOURS CS Core = 0 KA Core = 0 DM-Distributed: Distributed
Databases/Cloud Computing Non-core: 1\\. Distributed DBMS (See also: PDC-
Communications) a. Distributed data storage b. Distributed query processing c.
Distributed transaction model d. Homogeneous and heterogeneous solutions e.
Client-server distributed databases (See also: NC-Fundamentals) 2\\. Parallel
DBMS (See also: PDC-Algorithms) a. Parallel DBMS architectures: shared memory,
shared disk, shared nothing; b. Speedup and scale-up, e.g., use of the
MapReduce processing model (See also: PDCPrograms, SF-Foundations) c. Data
replication and weak consistency models (See also: PDC-Coordination)"""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-Distributed_Distributed_DatabasesCloud_Computing.txt> .

"DM-Internals_DBMS_Internals" ns1:content """Pages: 119-120 HOURS CS Core = 0 KA Core = 4 DM-Internals: DBMS Internals KA
Core: 1\\. DB Buffer Management (See also: OS-Memory, SF-Resource) 2\\.
Transaction Management (See also: PDC-Coordination) a. Isolation Levels b.
ACID c. Serializability d. Distributed Transactions 3\\. Concurrency Control:
(See also: OS-Concurrency) a. 2-Phase Locking b. Deadlocks handling strategies
c. Quorum-based consistency models 4\\. Recovery Manager a. Relation with
Buffer Manager Non-core: 5\\. Concurrency Control: a. Optimistic concurrency
control b. Timestamp concurrency control 6\\. Recovery Manager a. Write-Ahead
logging b. ARIES recovery system (Analysis, REDO, UNDO) Illustrative Learning
Outcomes: KA Core: 1\\. Describe how a DBMS manages its Buffer Pool. 2\\.
Describe the four properties for a correct transaction manager. 3\\. Outline
the principle of serializability."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-Internals_DBMS_Internals.txt> .

"DM-Modeling_Data_Modeling" ns1:content """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> .

"DM-NoSQL_NoSQL_Systems" ns1:content """Pages: 120-121 HOURS CS Core = 0 KA Core = 2 DM-NoSQL: NoSQL Systems KA Core:
1\\. Why NoSQL? (e.g., Impedance mismatch between Application [CRUD] and RDBMS)
2\\. Key-Value and Document data model Non-core: 3\\. Storage systems (e.g.,
Key-Value systems, Data Lakes) 4\\. Distribution Models (Sharding and
Replication) (See also: PDC-Communication) 5\\. Graph Databases 6\\. Consistency
Models (Update and Read, Quorum consistency, CAP theorem) (See also: PDC-
Communication) 7\\. Processing model (e.g., Map-Reduce, multi-stage map-reduce,
incremental map-reduce) (See also: PDC-Communication) 8\\. Case Studies: Cloud
storage system (e.g., S3); Graph databases; "When not to use NoSQL" (See also:
SPD-Web) Illustrative Learning Outcomes: KA Core: 1\\. Develop a use case for
the use of NoSQL over RDBMS. 2\\. Describe the defining characteristics behind
Key-Value and Document-based data models."""^^xsd:string ;
    ns1:cs_core_hours "0" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-NoSQL_NoSQL_Systems.txt> .

"DM-Processing_Query_Processing" ns1:content """Pages: 118-119 HOURS CS Core = 0 KA Core = 4 DM-Processing: Query Processing
KA Core: 1\\. Page structures 2\\. Index structures a. B+ trees (See also: AL-
Foundational) b. Hash indices: static and dynamic (See also: AL-Foundational,
SEC-Foundations) c. Index creation in SQL 3\\. File structures (See also: OS-
Files) a. Heap files b. Hash files 4\\. Algorithms for query operators a.
External Sorting (See also: AL-Foundational) b. Selection c. Projection; with
and without duplicate elimination d. Natural Joins: Nested loop, Sort-merge,
Hash join e. Analysis of algorithm efficiency (See also: AL-Complexity) 5\\.
Query transformations 6\\. Query optimization a. Access paths b. Query plan
construction c. Selectivity estimation d. Index-only plans 7\\. Parallel Query
Processing (e.g., parallel scan, parallel join, parallel aggregation) (See
also: PDC- Algorithms) 8\\. Database tuning/performance a. Index selection b.
Impact of indices on query performance (See also: SF-Performance, SEP-
Sustainability) c. Denormalization Illustrative Learning Outcomes: KA Core:
1\\. Describe the purpose and organization of both B+ tree and hash index
structures. 2\\. Compose an SQL command to create an index (any kind). 3\\.
Specify the steps for the various query operator algorithms: external sorting,
projection with duplicate elimination, sort-merge join, hash-join, block
nested-loop join. 4\\. Derive the run-time (in I/O requests) for each of the
above algorithms. 5\\. Transform a query in relational algebra to its
equivalent appropriate for a left-deep, pipelined execution. 6\\. Compute
selectivity estimates for a given selection and/or join operation. 7\\.
Describe how to modify an index structure to facilitate an index-only
operation for a given relation. 8\\. For a given scenario decide on which
indices to support for the efficient execution of a set of queries. 9\\.
Describe how DBMSs leverage parallelism to speed up query processing by
dividing the work across multiple processors or nodes."""^^xsd:string ;
    ns1:cs_core_hours "0" ;
    ns1:ka_core_hours "4" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-Processing_Query_Processing.txt> .

"DM-Querying_Query_Construction" ns1:content """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "4" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> .

"DM-Relational_Relational_Databases" ns1:content """Pages: 117-118 HOURS CS Core = 1 KA Core = 3 DM-Relational: Relational
Databases CS Core: 1\\. Entity and referential integrity: Candidate key,
superkeys 2\\. Relational database design KA Core: 3\\. Mapping conceptual
schema to a relational schema 4\\. Physical database design: file and storage
structures (See also: OS-Files) 5\\. Introduction to Functional dependency
theory 6\\. Normalization Theory a. Decomposition of a schema; lossless-join,
and dependency-preservation properties of a decomposition b. Normal forms
(BCNF) c. Denormalization (for efficiency) Non-core: 7\\. Functional dependency
theory a. Closure of a set of attributes b. Canonical Cover 8\\. Normalization
theory a. Multi-valued dependency (4NF) b. Join dependency (PJNF, 5NF) c.
Representation theory Illustrative Learning Outcomes: CS Core: 1\\. Describe
the defining characteristics behind the relational data model. 2\\. Comment on
the difference between a foreign key and a superkey. 3\\. Enumerate the
different types of integrity constraints. KA Core: 4\\. Compose a relational
schema from a conceptual schema which contains 1:1, 1:n, and n:m
relationships. 5\\. Map appropriate file structure to relations and indices.
6\\. Describe how functional dependency theory generalizes the notion of key.
7\\. Defend a given decomposition as lossless and or dependency preserving. 8\\.
Detect which normal form a given decomposition yields. 9\\. Comment on reasons
for denormalizing a relation."""^^xsd:string ;
    ns1:cs_core_hours "1" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt> .

"DM-SEP_Society_Ethics_and_the_Profession" ns1:content """Pages: 123 HOURS CS Core = Included in SEP hours KA Core = Included in SEP
hours DM-SEP: Society, Ethics, and the Profession CS Core: 1\\. Issues related
to scale (See also: SEP-Economies) 2\\. Data privacy overall (See also: SEP-
Privacy, SEP-Ethical-Analysis) a. Privacy compliance by design (See also: SEP-
Privacy) 3\\. Data anonymity (See also: SEP-Privacy) 4\\. Data
ownership/custodianship (See also: SEP-Professional-Ethics) 5\\. Intended and
unintended applications of stored data (See also: SEP-Professional-Ethics,
SECFoundations) KA Core: 6\\. Reliability of data (See also: SEP-Security) 7\\.
Provenance, data lineage, and metadata management (See also: SEP-Professional-
Ethics) 8\\. Data security (See also: DM-Security, SEP-Security) Illustrative
Learning Outcomes: CS Core: 1\\. Enumerate three social and three legal issues
related to large data collections. 2\\. Describe the value of data privacy. 3\\.
Identify the competing stakeholders with respect to data ownership. 4\\.
Enumerate three negative unintended consequences from a given (well known)
data-centric application (e.g., Facebook, LastPass, Ashley Madison). KA Core:
5\\. Describe the meaning of data provenance and lineage. 6\\. Identify how a
database might contribute to data security as well as how it may introduce
insecurities."""^^xsd:string ;
    ns1:cs_core_hours "123" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-SEP_Society_Ethics_and_the_Profession.txt> .

"DM-Security_Data_Security_and_Privacy" ns1:content """Pages: 121 HOURS CS Core = 1 KA Core = 2 DM-Security: Data Security and
Privacy CS Core: 1\\. Differences between data security and data privacy (See
also: SEC-Foundations) 2\\. Protecting data and database systems from attacks,
including injection attacks such as SQL injection (See also: SEC-Foundations)
3\\. Personally identifying information (PII) and its protection (See also:
SEC-Foundations, SEP- Security, SEP-Privacy) 4\\. Ethical considerations in
ensuring the security and privacy of data (See also: SEC-SEP, SEP- Ethical-
Analysis, SEP-Security, SEP-Privacy) KA Core: 5\\. Need for, and different
approaches to securing data at rest, in transit, and during processing (See
also: SEC-Foundations, SEC-Crypto) 6\\. Database auditing and its role in
digital forensics (See also: SEC-Forensics) 7\\. Data inferencing and
preventing attacks (See also: SEC-Crypto) 8\\. Laws and regulations governing
data security and data privacy (See also: SEP-Security, SEP- Privacy, SEC-
Foundations, SEC-Governance) Non-core: 9\\. Typical risk factors and prevention
measures for ensuring data integrity (See also: SEC- Governance) 10\\.
Ransomware and prevention of data loss and destruction (See also: SEC-Coding,
SEC-Forensics) Illustrative Learning Outcomes: CS Core: 1\\. Describe the
differences in the goals for data security and data privacy. 2\\. Identify and
mitigate risks associated with different approaches to protecting data. 3\\.
Describe legal and ethical considerations of end-to-end data security and
privacy. KA Core: 4\\. Develop a database auditing system given risk
considerations. 5\\. Apply several data exploration approaches to understanding
unfamiliar datasets."""^^xsd:string ;
    ns1:cs_core_hours "1" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-Security_Data_Security_and_Privacy.txt> .

"DM-Unstructured_Semi-structured_and_Unstructured_Databases" ns1:content """Pages: 122-123 HOURS CS Core = 0 KA Core = 0 DM-Unstructured: Semi-structured
and Unstructured Databases Non-core: 1\\. Vectorized unstructured data (text,
video, audio, etc.) and vector storage a. TF-IDF Vectorizer with ngram b.
Word2Vec c. Array database or array data type handling 2\\. Semi-structured
databases (e.g., JSON) a. Storage i. Encoding and compression of nested data
types b. Indexing i. Btree, skip index, Bloom filter ii. Inverted index and
bitmap compression iii. Space filling curve indexing for semi-structured geo-
data c. Query processing for OLTP and OLAP use cases i. Insert, Select,
update/delete tradeoffs ii. Case studies on Postgres/JSON, MongoDB, and
Snowflake/JSON"""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Date_Management_DM" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Date_Management_DM/DM-Unstructured_Semi-structured_and_Unstructured_Databases.txt> .

"FPL-Abstraction_Program_Abstraction_and_Representation" ns1:content """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
    ns1:cs_core_hours "0" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> .

"FPL-Analysis_Program_Analysis_and_Analyzers" ns1:content """Pages: 142 HOURS CS Core = 0 KA Core = 0 FPL-Analysis: Program Analysis and
Analyzers Non-core: 4\\. Relevant program representations, such as basic
blocks, control-flow graphs, def-use chains, and static single assignment 5\\.
Undecidability and consequences for program analysis 6\\. Flow-insensitive
analysis, such as type-checking and scalable pointer and alias analysis 7\\.
Flow-sensitive analysis, such as forward and backward dataflow analyses 8\\.
Path-sensitive analysis, such as software model checking and software
verification 9\\. Tools and frameworks for implementing analyzers 10\\. Role of
static analysis in program optimization and data dependency analysis during
exploitation of concurrency (See also: FPL-Code) 11\\. Role of program analysis
in (partial) verification and bug-finding (See also: FPL-Code) 12\\.
Parallelization: a. Analysis for auto-parallelization b. Analysis for
detecting concurrency bugs Illustrative learning outcomes: Non-core: 1\\.
Explain the difference between dataflow graph and control flow graph. 2\\.
Explain why non-trivial sound program analyses must be approximate. 3\\. Argue
why an analysis is correct (sound and terminating). 4\\. Explain why potential
aliasing limits sound program analysis and how alias analysis can help. 5\\.
Use the results of a program analysis for program optimization and/or partial
program correctness."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Analysis_Program_Analysis_and_Analyzers.txt> .

"FPL-Aspect_Aspect-Oriented_Programming" ns1:content """Pages: 136 HOURS CS Core = 0 KA Core = 0 FPL-Aspect: Aspect-Oriented
Programming Non-core: 1\\. Aspects 2\\. Join points 3\\. Advice a. Before b.
After (as finally, returning or throwing) c. Around 4\\. Point cuts a.
Designators 5\\. Weaving - static and dynamic 6\\. Alternatives including
annotations and IDEs"""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Aspect_Aspect-Oriented_Programming.txt> .

"FPL-Code_Code_Generation" ns1:content """Pages: 142-143 HOURS CS Core = 0 KA Core = 0 FPL-Code: Code Generation Non-
core: 1\\. Instruction sets (See also: AR-Assembly) 2\\. Control flow 3\\. Memory
management (See also: AR-Memory, OS-Memory) 4\\. Procedure calls and method
dispatching 5\\. Separate compilation; linking 6\\. Instruction selection 7\\.
Instruction scheduling (e.g., pipelining) 8\\. Register allocation 9\\. Code
optimization as a form of program analysis (See also: FPL-Analysis) 10\\.
Program generation through generative AI Illustrative learning outcomes: Non-
core: 1\\. Identify all essential steps for automatically converting source
code into assembly or other low-level languages. 2\\. Explain the low-level
code necessary for calling functions/methods in modern languages. 3\\. Discuss
why separate compilation requires uniform calling conventions. 4\\. Discuss why
separate compilation limits optimization because of unknown effects of calls.
5\\. Discuss opportunities for optimization introduced by naive translation and
approaches for achieving. optimization, such as instruction selection,
instruction scheduling, register allocation, and peephole optimization."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Code_Code_Generation.txt> .

"FPL-Constructs_Advanced_Programming_Constructs" ns1:content """Pages: 144 HOURS CS Core = 0 KA Core = 0 FPL-Constructs: Advanced Programming
Constructs Non-core: 1\\. Encapsulation mechanisms 2\\. Delayed evaluation and
infinite streams 3\\. Compare and contrast delayed evaluation vs eager
evaluation 4\\. Unification vs assertion vs expression evaluation 5\\. Control
abstractions: exception handling, continuations, monads. 6\\. Object-oriented
abstractions: multiple inheritance, mixins, traits, multimethods 7\\.
Metaprogramming: macros, generative programming, model-based development 8\\.
String manipulation via pattern-matching (regular expressions) 9\\. Dynamic
code evaluation ("eval") 10\\. Language support for checking assertions,
invariants, and pre/post-conditions 11\\. Domain specific languages, such as
database languages, data science languages, embedded computing languages,
synchronous languages, hardware interface languages 12\\. Massive parallel high
performance computing models and languages Illustrative learning outcomes:
Non-core: 1\\. Use various advanced programming constructs and idioms
correctly. 2\\. Discuss how various advanced programming constructs aim to
improve program structure, software quality, and programmer productivity. 3\\.
Discuss how various advanced programming constructs interact with the
definition and implementation of other language features."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Constructs_Advanced_Programming_Constructs.txt> .

"FPL-Design_Design_Principles_of_Programming_Languages" ns1:content """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> .

"FPL-Event-Driven_Event-Driven_and_Reactive_Programming" ns1:content """Pages: 134-135 HOURS CS Core = 2 KA Core = 2 FPL-Event-Driven: Event-Driven
and Reactive Programming CS Core: 1\\. Procedural programming vs reactive
programming: advantages of reactive programming in capturing events. 2\\.
Components of reactive programming: event-source, event signals, listeners and
dispatchers, event objects, adapters, event-handlers. (See also: GIT-
Interaction, SPD-Web, SPD-Mobile, SPD-Robot, SPD-Embedded, SPD-Game, SPD-
Interactive) 3\\. Stateless and state-transition models of event-based
programming. 4\\. Canonical uses such as GUIs, mobile devices, robots, servers.
(See also: GIT-Interaction, GITImage, SPD-Web, SPD-Mobile, SPD-Robot, SPD-
Embedded, SPD-Game, SPD-Interactive) KA Core: 5\\. Using a reactive framework:
a. Defining event handlers/listeners b. Parameterization of event senders and
event arguments c. Externally generated events and program-generated events
6\\. Separation of model, view, and controller 7\\. Event-driven and reactive
programs as state-transition systems Illustrative learning outcomes: CS Core:
1\\. Implement event handlers for use in reactive systems, such as GUIs. 2\\.
Examine why an event-driven programming style is natural in domains where
programs react to external events. KA Core: 3\\. Define and use a reactive
framework. 4\\. Describe an interactive system in terms of a model, a view, and
a controller."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Event-Driven_Event-Driven_and_Reactive_Programming.txt> .

"FPL-Formalism_Formal_Semantics" ns1:content """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> .

"FPL-Functional_Functional_Programming" ns1:content """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
    ns1:cs_core_hours "4" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> .

"FPL-Logic_Logic_Programming" ns1:content """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
    ns1:cs_core_hours "133" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> .

"FPL-Methodologies_Formal_Development_Methodologies" ns1:content """Pages: 146 HOURS CS Core = 0 KA Core = 0 FPL-Methodologies: Formal Development
Methodologies 1\\. Formal specification languages and methodologies 2\\. Theorem
provers, proof assistants, and logics 3\\. Constraint checkers (See also: FPL-
Formalism) 4\\. Dependent types (universal quantification as dependent
function, existential quantification as dependent product) (See also: FPL-
Types, FPL-Formalism) 5\\. Specification and proof discharge for fully verified
software systems using pre/post conditions, refinement types, etc. 6\\. Formal
modeling and manual refinement/implementation of software systems. 7\\. Use of
symbolic testing and fuzzing in software development. 8\\. Model checking. 9\\.
Understanding of situations where formal methods can be effectively applied
and how to structure development to maximize their value. Illustrative
learning outcomes: Non-core: 1\\. Use formal modeling techniques to develop and
validate architectures. 2\\. Use proof assisted programming languages to
develop fully specified and verified software artifacts. 3\\. Use verifier and
specification support in programming languages to formally validate system
properties. 4\\. Integrate symbolic validation tooling into a programming
workflow. 5\\. Discuss when and how formal methods can be effectively used in
the development process."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Methodologies_Formal_Development_Methodologies.txt> .

"FPL-OOP_Object-Oriented_Programming" ns1:content """Pages: 130-131 HOURS CS Core = 4 + 1 (SDF) KA Core = 1 FPL-OOP: Object-
Oriented Programming CS Core: 1\\. Imperative programming as a subset of
object-oriented programming. 2\\. Object-oriented design: a. Decomposition into
objects carrying state and having behavior. b. Class-hierarchy design for
modeling. 3\\. Definition of classes: fields, methods, and constructors. (See
also: SDF-Fundamentals) 4\\. Subclasses, inheritance (including multiple
inheritance), and method overriding. 5\\. Dynamic dispatch: definition of
method-call. 6\\. Exception handling. (See also: SDF-Fundamentals, PDC-
Coordination, SE-Construction) 7\\. Object-oriented idioms for encapsulation:
a. Privacy, data hiding, and visibility of class members. b. Interfaces
revealing only method signatures. c. Abstract base classes, traits and mixins.
8\\. Dynamic vs static properties. 9\\. Composition vs inheritance. 10\\.
Subtyping: a. Subtype polymorphism; implicit upcasts in typed languages. b.
Notion of behavioral replacement: subtypes acting like supertype. c.
Relationship between subtyping and inheritance. KA Core: 11\\. Collection
classes, iterators, and other common library components. 12\\. Metaprogramming
and reflection. Illustrative Learning Outcomes: CS Core: 1\\. Enumerate the
differences between imperative and object-oriented programming paradigms. 2\\.
Compose a class through design, implementation, and testing to meet behavioral
requirements. 3\\. Build a simple class hierarchy utilizing subclassing that
allows code to be reused for distinct subclasses. 4\\. Predict and validate
control flow in a program using dynamic dispatch. 5\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 6\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. 7\\. Compare and contrast the benefits and costs/impact of using
inheritance (subclasses) and composition (specifically, how to base
composition on higher order functions). 8\\. Explain the relationship between
object-oriented inheritance (code-sharing and overriding) and subtyping (the
idea of a subtype being usable in a context that expects the supertype). 9\\.
Use object-oriented encapsulation mechanisms such as interfaces and private
members. 10\\. Define and use iterators and other operations on aggregates,
including operations that take functions as arguments, in multiple programming
languages, selecting the most natural idioms for each language. (See also:
FPL-Functional) KA Core: 11\\. Use collection classes and iterators effectively
to solve a problem."""^^xsd:string ;
    ns1:cs_core_hours "4" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt> .

"FPL-Parallel_Parallel_and_Distributed_Computing" ns1:content """Pages: 135-136 HOURS CS Core = 2 + 1 (PDC) KA Core = 2 FPL-Parallel: Parallel
and Distributed Computing CS Core: 1\\. Safety and liveness (See also: PDC-
Evaluation) a. Race conditions (See also: OS-Concurrency) b.
Dependencies/preconditions c. Fault models (See also: OS-Faults) d.
Termination (See also: PDC-Coordination) 2\\. Programming models (See also:
PDC-Programs) One or more of the following: a. Actor models b. Procedural and
reactive models c. Synchronous/asynchronous programming models d. Data
parallelism 3\\. Properties (See also: PDC-Programs, PDC-Coordination) a.
Order-based properties i. Commutativity ii. Independence b. Consistency-based
properties i. Atomicity ii. Consensus 4\\. Execution control: (See also: PDC-
Coordination, SF-Foundations) a. Async await b. Promises c. Threads 5\\.
Communication and coordination (See also: OS-Process, PDC-Communication, PDC-
Coordination) a. Mutexes b. Message-passing c. Shared memory d. Cobegin-coend
e. Monitors f. Channels g. Threads h. Guards KA Core: 6\\. Futures 7\\. Language
support for data parallelism such as forall, loop unrolling, map/reduce 8\\.
Effect of memory-consistency models on language semantics and correct code
generation 9\\. Representational State Transfer Application Programming
Interfaces (REST APIs) 10\\. Technologies and approaches: cloud computing, high
performance computing, quantum computing, ubiquitous computing 11\\. Overheads
of message-passing 12\\. Granularity of program for efficient exploitation of
concurrency 13\\. Concurrency and other programming paradigms (e.g.,
functional) Illustrative learning outcomes: CS Core: 1\\. Explain why
programming languages do not guarantee sequential consistency in the presence
of data races and what programmers must do as a result. 2\\. Implement correct
concurrent programs using multiple programming models, such as shared memory,
actors, futures, synchronization constructs, and data-parallelism primitives.
3\\. Use a message-passing model to analyze a communication protocol. 4\\. Use
synchronization constructions such as monitor/synchronized methods in a simple
program. 5\\. Modeling data dependency using simple programming constructs
involving variables, read and write. 6\\. Modeling control dependency using
simple constructs such as selection and iteration. KA Core: 7\\. Explain how
REST API's integrate applications and automate processes. 8\\. Explain
benefits, constraints and challenges related to distributed and parallel
computing."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Parallel_Parallel_and_Distributed_Computing.txt> .

"FPL-Pragmatics_Language_Pragmatics" ns1:content """Pages: 144-145 HOURS CS Core = 0 KA Core = 0 FPL-Pragmatics: Language
Pragmatics Non-core: 1\\. Effect of technology needs and software requirements
on programming language development and evolution 2\\. Problem domains and
programming paradigm 3\\. Criteria for good programming language design a.
Principles of language design such as orthogonality b. Defining control and
iteration constructs c. Modularization of large software 4\\. Evaluation order,
precedence, and associativity 5\\. Eager vs delayed evaluation 6\\. Defining
control and iteration constructs 7\\. External calls and system libraries
Illustrative learning outcomes: Non-core: 1\\. Discuss the role of concepts
such as orthogonality and well-chosen defaults in language design. 2\\.
Objectively evaluate and justify language-design decisions. 3\\. Implement an
example program whose result can differ under different rules for evaluation
order, precedence, or associativity. 4\\. Illustrate uses of delayed
evaluation, such as user-defined control abstractions. 5\\. Discuss the need
for allowing calls to external calls and system libraries and the consequences
for language implementation."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Pragmatics_Language_Pragmatics.txt> .

"FPL-SEP_Society_Ethics_and_the_Profession" ns1:content """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> .

"FPL-Scripting_Shell_Scripting" ns1:content """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "0" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> .

"FPL-Semantics_Compiler_Semantic_Analysis" ns1:content """Pages: 141-142 HOURS CS Core = 0 KA Core = 0 FPL-Semantics: Compiler Semantic
Analysis Non-core: 1\\. Abstract syntax trees; contrast with concrete syntax
2\\. Defining, traversing, and modifying high-level program representations 3\\.
Scope and binding resolution 4\\. Static semantics a. Type checking. b. Define
before use c. Annotation and extended static checking frameworks. 5\\.
L-values/R-values (See also: SDF-Fundamentals) 6\\. Call semantics 7\\. Types of
parameter-passing with simple illustrations and comparison: call by value,
call by reference, call by value-result, call by name, call by need and their
variations 8\\. Declarative specifications such as attribute grammars and their
applications in handling limited context-base grammar Illustrative learning
outcomes: Non-core: 1\\. Draw the abstract syntax tree for a small language.
2\\. Implement context-sensitive, source-level static analyses such as type-
checkers or resolving identifiers to identify their binding occurrences. 3\\.
Describe semantic analyses using an attribute grammar."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Semantics_Compiler_Semantic_Analysis.txt> .

"FPL-Syntax_Syntax_Analysis" ns1:content """Pages: 141 HOURS CS Core = 0 KA Core = 0 FPL-Syntax: Syntax Analysis Non-core:
1\\. Regular grammars vs context-free grammars (See also: AL-Models) 2\\.
Scanning and parsing based on language specifications 3\\. Lexical analysis
using regular expressions 4\\. Tokens and their use 5\\. Parsing strategies
including top-down (e.g., recursive descent, or LL) and bottom-up (e.g., LR or
GLR) techniques a. Lookahead tables and their application to parsing 6\\.
Language theory: a. Chomsky hierarchy (See also: AL-Models) b. Left-
most/right-most derivation and ambiguity c. Grammar transformation 7\\. Parser
error recovery mechanisms 8\\. Generating scanners and parsers from declarative
specifications Illustrative learning outcomes: Non-core: 1\\. Use formal
grammars to specify the syntax of languages. 2\\. Illustrate the role of
lookahead tables in parsing. 3\\. Use declarative tools to generate parsers and
scanners. 4\\. Recognize key issues in syntax definitions: ambiguity,
associativity, precedence."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Syntax_Syntax_Analysis.txt> .

"FPL-Systems_Systems_Execution_and_Memory_Model" ns1:content """Pages: 138-139 HOURS CS Core = 2 + 1 (AR and OS) KA Core = 0 FPL-Systems:
Systems Execution and Memory Model CS Core: 1\\. Data structures for
translation, execution, translation, and code mobility such as stack, heap,
aliasing (sharing using pointers), indexed sequence and string 2\\. Direct,
indirect, and indexed access to memory location 3\\. Run-time representation of
data abstractions such as variables, arrays, vectors, records, pointerbased
data elements such as linked-lists and trees, and objects 4\\. Abstract low-
level machine with simple instruction, stack, and heap to explain translation
and execution 5\\. Run-time layout of memory: activation record (with various
pointers), static data, call-stack, heap (See also: AR-Memory, OS-Memory) a.
Translating selection and iterative constructs to control-flow diagrams b.
Translating control-flow diagrams to low level abstract code c. Implementing
loops, recursion, and tail calls d. Translating function/procedure calls and
return from calls, including different parameter-passing mechanisms using an
abstract machine 6\\. Memory management: (See also: AR-Memory, OS-Memory) a.
Low level allocation and accessing of high-level data structures such as basic
data types, ndimensional array, vector, record, and objects b. Return from
procedure as automatic deallocation mechanism for local data elements in the
stack c. Manual memory management: allocating, de-allocating, and reusing heap
memory d. Automated memory management: garbage collection as an automated
technique using the notion of reachability 7\\. Green computing. (See also:
SEP-Sustainability) Illustrative learning outcomes: CS Core: 1\\. Explain how a
core language construct, such as data abstractions and control abstractions,
is executed. 2\\. Explain how programming language implementations typically
organize memory into global data, text, heap, and stack sections and how
features such as recursion and memory management map to this memory model. 3\\.
Explain why memory leaks and dangling pointer problems occur, and what can be
done by a programmer to avoid/fix them."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "0" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Systems_Systems_Execution_and_Memory_Model.txt> .

"FPL-Translation_Language_Translation_and_Execution" ns1:content """Pages: 139-140 HOURS CS Core = 2 KA Core = 3 FPL-Translation: Language
Translation and Execution CS Core: 1\\. Execution models for JIT (Just-In-
Time), compiler, interpreter 2\\. Use of intermediate code, e.g., bytecode 3\\.
Limitations and benefits of JIT, compiler, and interpreter 4\\. Cross
compilers/transpilers 5\\. BNF and extended BNF representation of context-free
grammar 6\\. Parse tree using a simple sentence such as arithmetic expression
or if-then-else statement 7\\. Execution as native code or within a virtual
machine 8\\. Language translation pipeline: syntax analysis, parsing, optional
type-checking, translation/code generation and optimization, linking, loading,
execution KA Core: 9\\. Run-time representation of core language constructs
such as objects (method tables) and functions that can be passed as parameters
to and returned from functions (closures) 10\\. Secure compiler development
(See also: SEC-Foundations, SEC-Coding) Illustrative learning outcomes: CS
Core: 1\\. Explain and understand the differences between compiled, JIT, and
interpreted language implementations, including the benefits and limitations
of each. 2\\. Differentiate syntax and parsing from semantics and evaluation.
3\\. Use BNF and extended BNF to specify the syntax of simple constructs such
as if-then-else, type declaration and iterative constructs for known languages
such as C++ or Python. 4\\. Illustrate the parse tree using a simple
sentence/arithmetic expression. 5\\. Illustrate translation of syntax diagrams
to BNF/extended BNF for simple constructs such as if-thenelse, type
declaration, iterative constructs, etc. 6\\. Illustrate ambiguity in parsing
using nested if-then-else/arithmetic expression and show resolution using
precedence order. KA-Core: 7\\. Discuss the benefits and limitations of garbage
collection, including the notion of reachability."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Translation_Language_Translation_and_Execution.txt> .

"FPL-Types_Type_Systems" ns1:content """Pages: 136-137-138 HOURS CS Core = 3 KA Core = 3 FPL-Types: Type Systems CS
Core: 1\\. A type as a set of values together with a set of operations a.
Primitive types (e.g., numbers, Booleans) (See also: SDF-Fundamentals) b.
Compound types built from other types (e.g., records/structs, unions, arrays,
lists, functions, references using set operations) (See also: SDF-Data-
Structures) 2\\. Association of types to variables, arguments, results, and
fields 3\\. Type safety as an aspect of program correctness (See also: FPL-
Formalism) 4\\. Type safety and errors caused by using values inconsistently
given their intended types 5\\. Goals and limitations of static and dynamic
typing: detecting and eliminating errors as early as possible. 6\\. Generic
types (parametric polymorphism) a. Definition and advantages of polymorphism:
parametric, subtyping, overloading, and coercion b. Comparison of monomorphic
and polymorphic types c. Comparison with ad-hoc polymorphism (overloading) and
subtype polymorphism d. Generic parameters and typing e. Use of generic
libraries such as collections f. Comparison with ad hoc polymorphism
(overloading) and subtype polymorphism g. Prescriptive vs descriptive
polymorphism h. Implementation models of polymorphic types i. Subtyping KA
Core: 7\\. Type equivalence: structural vs name equivalence 8\\. Complementary
benefits of static and dynamic typing: a. Errors early vs errors late/avoided
b. Enforce invariants during code development and code maintenance vs postpone
typing decisions while prototyping and conveniently allow flexible coding
patterns such as heterogeneous collections. c. Typing rules for function,
product, and sum types d. Avoiding misuse of code vs allowing more code reuse
e. Detect incomplete programs vs allow incomplete programs to run f.
Relationship to static analysis g. Decidability Non-core: 9\\. Compositional
type constructors, such as product types (for aggregates), sum types (for
unions), function types, quantified types, and recursive types 10\\. Type
checking 11\\. Subtyping: (See also: FPL-OOP) a. Subtype polymorphism; implicit
upcasts in typed languages b. Notion of behavioral replacement: subtypes
acting like supertype c. Relationship between subtyping and inheritance 12\\.
Type safety as preservation plus progress 13\\. Type inference 14\\. Static
overloading 15\\. Propositions as types (implication as a function, conjunction
as a product, disjunction as a sum) (See also: FPL-Formalism) 16\\. Dependent
types (universal quantification as dependent function, existential
quantification as dependent product). (See also: FPL-Formalism) Illustrative
learning outcomes: CS Core: 1\\. Describe, for both a primitive and a compound
type, the values that have that type. 2\\. Describe, for a language with a
static type system, the operations that are forbidden statically, such as
passing the wrong type of value to a function or method. 3\\. Describe examples
of program errors detected by a type system. 4\\. Identify program properties,
for multiple programming languages, that are checked statically and program
properties that are checked dynamically. 5\\. Describe an example program that
does not type-check in a particular language and yet would have no error if
run. 6\\. Use types and type-error messages to write and debug programs. KA
Core: 7\\. Explain how typing rules define the set of operations that are legal
for a type. 8\\. List the type rules governing the use of a particular compound
type. 9\\. Explain why undecidability requires type systems to conservatively
approximate program behavior. 10\\. Define and use program pieces (such as
functions, classes, methods) that use generic types, including for
collections. 11\\. Discuss the differences among generics, subtyping, and
overloading. 12\\. Explain multiple benefits and limitations of static typing
in writing, maintaining, and debugging software. Non-core: 13\\. Define a type
system precisely and compositionally. 14\\. For various foundational type
constructors, identify the values they describe and the invariants they
enforce. 15\\. Precisely describe the invariants preserved by a sound type
system. 16\\. Prove type safety for a simple language in terms of preservation
and progress theorems. 17\\. Implement a unification-based type-inference
algorithm for a simple language. 18\\. Explain how static overloading and
associated resolution algorithms influence the dynamic behavior of programs."""^^xsd:string ;
    ns1:cs_core_hours "3" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Foundations_of_Programming_Languages_FPL" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt> .

"GIT-3D_Modeling" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Graphics_and_Interactive_Techniques_GIT" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> .

"GIT-Animation_and_Simulation" ns1:content """Pages: 152-153 HOURS CS Core = 3 KA Core = 2 GIT-Animation and Simulation:
Core Principles CS Core: 1\\. Key concepts in animation and simulation. 2\\.
Procedural animation and physics-based modeling. 3\\. Motion capture techniques
and keyframe animation. 4\\. Real-time simulation techniques for interactive
applications. KA Core: 5\\. AI-based animation and behavioral modeling. 6\\.
Crowd simulation and group behaviors in animations. 7\\. Advanced physics-based
simulations. Illustrative Learning Outcomes: 1\\. Apply keyframe animation
techniques to an interactive application. 2\\. Differentiate between procedural
and AI-driven animation. 3\\. Understand the role of physics in real-time
simulations."""^^xsd:string ;
    ns1:cs_core_hours "3" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Graphics_and_Interactive_Techniques_GIT" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Animation_and_Simulation.txt> .

"GIT-Augmented_Reality" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-Augmented Reality: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
GIT-Augmented Reality. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Graphics_and_Interactive_Techniques_GIT" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Augmented_Reality.txt> .

"GIT-Fundamentals" ns1:content """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
    ns1:cs_core_hours "3" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Graphics_and_Interactive_Techniques_GIT" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> .

"GIT-Game_Design" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-Game Design: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-Game Design.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours 11 ;
    ns1:ka_core_hours 6 ;
    ns1:part_of "Graphics_and_Interactive_Techniques_GIT" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Game_Design.txt> .

"GIT-Interaction_Design" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-Interaction Design: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
GIT-Interaction Design. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Graphics_and_Interactive_Techniques_GIT" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Interaction_Design.txt> .

"GIT-Rendering_and_Shaders" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-Rendering and Shaders: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
GIT-Rendering and Shaders. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Graphics_and_Interactive_Techniques_GIT" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Rendering_and_Shaders.txt> .

"GIT-Virtual_Reality" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-Virtual Reality: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
GIT-Virtual Reality. 2\\. Apply principles in practical scenarios. 3\\. Analyze
the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Graphics_and_Interactive_Techniques_GIT" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Virtual_Reality.txt> .

"HCI-Accessibility_Accessibility_and_Inclusive_Design" ns1:content """Pages: 177-178 HOURS CS Core = 2 KA Core = 2 HCI-Accessibility: Accessibility
and Inclusive Design CS Core: 1\\. Background (See also: SEP-DEIA, SEP-
Security) a. Societal and legal support for and obligations to people with
disabilities b. Accessible design benefits everyone 2\\. Techniques a.
Accessibility standards (e.g., Web Content Accessibility Guidelines) (See
also: SPD-Web) 3\\. Technologies (See also: SE-Tools) a. Features and products
that enable accessibility and support inclusive development by designers and
engineers 4\\. IDFs (Inclusive Design Frameworks) (See also: SEP-DEIA) a.
Recognizing differences 5\\. Universal design KA Core: 6\\. Background a.
Demographics and populations (permanent, temporary, and situational
disability) b. International perspectives on disability (See also: SEP-DEIA)
c. Attitudes towards people with disabilities (See also: SEP-DEIA) 7\\.
Techniques a. UX (user experience) design and research b. Software engineering
practices that enable inclusion and accessibility. (See also: SEP-DEIA) 8\\.
Technologies a. Examples of accessibility-enabling features, such as
conformance to screen readers 9\\. Inclusive Design Frameworks a. Creating
inclusive processes such as participatory design b. Designing for larger
impact Non-core: 10\\. Background (See also: SEP-DEIA) a. Unlearning and
questioning b. Disability studies 11\\. Technologies: the Return On Investment
(ROI) of inclusion 12\\. Inclusive Design Frameworks: user-sensitive inclusive
design (See also: SEP-DEIA) 13\\. Critical approaches to HCI (e.g.,
inclusivity) (See also: SEP-DEIA) Illustrative Learning Outcomes: CS Core: 1\\.
Identify accessibility challenges faced by people with different disabilities
and specify the associated accessible and assistive technologies that address
them. (See also: AI-Agents, AI-Robotics) 2\\. Identify appropriate inclusive
design approaches, such as universal design and ability-based design. 3\\.
Identify and demonstrate understanding of software accessibility guidelines.
4\\. Demonstrate recognition of laws and regulations applicable to accessible
design. KA Core: 5\\. Apply inclusive frameworks to design, such as universal
design and usability and ability-based design, and demonstrate accessible
design of visual, voice-based, and touch-based UIs. 6\\. Demonstrate
understanding of laws and regulations applicable to accessible design. 7\\.
Demonstrate understanding of what is appropriate and inappropriate high level
of skill during interaction with individuals from diverse populations. 8\\.
Analyze web pages and mobile apps for current standards of accessibility. Non-
core: 9\\. Biases towards disability, race, and gender have historically,
either intentionally or unintentionally, informed technology design. a. Find
examples. b. Consider how those experiences (learnings?) might inform design.
10\\. Conceptualize user experience research to identify user needs and
generate design insights."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Human_Computer_Interaction_HCI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accessibility_Accessibility_and_Inclusive_Design.txt> .

"HCI-Accountability_Accountability_and_Responsibility_in_Design" ns1:content """Pages: 176 HOURS CS Core = 2 KA Core = 2 HCI-Accountability: Accountability
and Responsibility in Design CS Core: (See also: SEP-Context) 1\\. Design
impact a. Sustainability (See also: SEP-Sustainability) b. Inclusivity (See
also: SEP-DEIA) c. Safety, security and privacy (See also: SEP-Security, SEC-
Foundations) d. Harm and disparate impact (See also: SEP-DEIA) 2\\. Ethics in
design methods and solutions (See also: SEP-Ethical-Analysis, SEP-Context,
SEPIntellectual Property) a. The role of artificial intelligence (See also:
AI-SEP) b. Responsibilities for considering stakeholder impact and human
factors (See also: SEPProfessional-Ethics) c. Role of design to meet user
needs 3\\. Requirements in design (See also: SEP-Professional-Ethics) a.
Ownership responsibility b. Legal frameworks, compliance requirements c.
Consideration beyond immediate user needs, including via iterative
reconstruction of problem analysis and "digital well-being" features KA Core:
4\\. Value-sensitive design (See also: SEP-Ethical-Analysis, SEP-Context, SEP-
Communication) a. Identify direct and indirect stakeholders b. Determine and
include diverse stakeholder values and value systems. 5\\. Persuasion through
design (See also: SEP-Communication) a. Assess the persuasive content of a
design b. Employ persuasion as a design goal c. Distinguish persuasive
interfaces from manipulative interfaces Illustrative Learning Outcomes: CS
Core: 1\\. Identify and critique the potential impacts of a design on society
and relevant communities to address such concerns as sustainability,
inclusivity, safety, security, privacy, harm, and disparate impact. KA Core:
2\\. Identify the potential human factor elements in a design. 3\\. Identify and
understand direct and indirect stakeholders. 4\\. Develop scenarios that
consider the entire lifespan of a design, beyond the immediately planned uses
that anticipate direct and indirect stakeholders. 5\\. Identify and critique
the potential factors in a design that impact direct and indirect stakeholders
and broader society (e.g., transparency, sustainability of the system, trust,
artificial intelligence). 6\\. Assess the persuasive content of a design and
its intent relative to user interests. 7\\. Critique the outcomes of a design
given its intent. 8\\. Understand the impact of design decisions."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Human_Computer_Interaction_HCI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accountability_Accountability_and_Responsibility_in_Design.txt> .

"HCI-Design_System_Design" ns1:content """Pages: 179-181 HOURS CS Core = Included in SEP hours KA Core = Included in SEP
hours HCI-Design: System Design CS Core: 1\\. Prototyping techniques and tools
a. Low-fidelity prototyping b. Rapid prototyping c. Throw-away prototyping d.
Granularity of prototyping 2\\. Design patterns a. Iterative design b.
Universal design (See also: SEP-DEIA) c. Interaction design (e.g., data-driven
design, event-driven design) 3\\. Design constraints a. Platforms (See also:
SPD-Game) b. Devices c. Resources d. Balance among usability, security and
privacy (See also: SEC-Foundations) KA Core: 4\\. Design patterns and
guidelines a. Software architecture patterns b. Cross-platform design c.
Synchronization considerations 5\\. Design processes (See also: SEP-
Communication) a. Participatory design b. Co-design c. Double-diamond d.
Convergence and divergence 6\\. Interaction techniques (See also: GIT-
Interaction) a. Input and output vectors (e.g., gesture, pose, touch, voice,
force) b. Graphical user interfaces c. Controllers d. Haptics e. Hardware
design f. Error handling 7\\. Visual UI design (See also: GIT-Visualization) a.
Color b. Layout c. Gestalt principles Non-core: 8\\. Immersive environments
(See also: GIT-Immersion) a. XR (encompasses virtual reality, augmented
reality, and mixed reality) b. Spatial audio 9\\. 3D printing and fabrication
10\\. Asynchronous interaction models 11\\. Creativity support tools 12\\. Voice
UI designs Illustrative Learning Outcomes: CS Core: 1\\. Propose system designs
tailored to a specified appropriate mode of interaction. 2\\. Follow an
iterative design and development process that incorporates the following: a.
Understanding the user b. Developing an increment c. Evaluating the increment
d. Feeding those results into a subsequent iteration 3\\. Explain the impact of
changing constraints and design tradeoffs (e.g., hardware, user, security.) on
system design. KA Core: 4\\. Evaluate architectural design approaches in the
context of project goals. 5\\. Identify synchronization challenges as part of
the user experience in distributed environments. 6\\. Evaluate and compare the
privacy implications behind different input techniques for a given scenario.
7\\. Explain the rationale behind a UI design based on visual design
principles. Non-core: 8\\. Evaluate the privacy implications within a VR/AR/MR
scenario"""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Human_Computer_Interaction_HCI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Design_System_Design.txt> .

"HCI-Evaluation_Evaluating_the_Design" ns1:content """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
    ns1:cs_core_hours "1" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Human_Computer_Interaction_HCI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> .

"HCI-SEP_Society_Ethics_and_the_Profession" ns1:content """Pages: 181-182 HOURS CS Core = 1 KA Core = 2 HCI-SEP: Society, Ethics, and the
Profession CS Core: 1\\. Universal and user-centered design (See also: HCI-
User, SEP-DEIA) 2\\. Accountability (See also: HCI-Accountability) 3\\.
Accessibility and inclusive design (See also: SEP-DEIA, SEP-Security) 4\\.
Evaluating the design (See also: HCI-Evaluation) 5\\. System design (See also:
HCI-Design) KA Core: 6\\. Participatory and inclusive design processes 7\\.
Evaluating the design: Implications and impacts of design: with respect to the
environment, material, society, security, privacy, ethics, and broader impacts
(See also: SEC-Foundations, SEPPrivacy) Non-core: 8\\. VR/AR/MR scenarios
Illustrative Learning Outcomes: CS Core: 1\\. Conduct a user-centered design
process that is integrated into a project. 2\\. Identify and critique the
potential impacts of a design on society and relevant communities to address
such concerns as sustainability, inclusivity, safety, security, privacy, harm,
and disparate impact. KA Core: 2\\. Critique a recent example of a non-
inclusive design choice, its societal implications, and propose potential
design improvements. 3\\. Evaluating the design: Identify the implications and
broader impacts of a given design. Non-core: 4\\. Evaluate the privacy
implications within a VR/AR/MR scenario."""^^xsd:string ;
    ns1:cs_core_hours "1" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Human_Computer_Interaction_HCI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-SEP_Society_Ethics_and_the_Profession.txt> .

"HCI-User_Understanding_the_User_Individual_goals_and_interactions_with_others" ns1:content """Pages: 174-175 HOURS CS Core = 2 KA Core = 5 HCI-User: Understanding the User:
Individual goals and interactions with others CS Core: 1\\. User-centered
design and evaluation methods. (See also: SEP-Context, SEP-Ethical-Analysis,
SEP-Professional-Ethics) a. "You are not the users" b. User needs-finding c.
Formative studies d. Interviews e. Surveys f. Usability tests KA Core: 2\\.
User-centered design methodology. (See also: SE-Tools) a. Personas/persona
spectrum b. User stories/storytelling and techniques for gathering stories c.
Empathy maps d. Needs assessment (techniques for uncovering needs and
gathering requirements - e.g., interviews, surveys, ethnographic and
contextual enquiry) (See also: SE-Requirements) e. Journey maps f. Evaluating
the design (See also: HCI-Evaluation) g. Interfacing with stakeholders, as a
team h. Risks associated with physical, distributed, hybrid and virtual teams
3\\. Physical and cognitive characteristics of the user a. Physical
capabilities that inform interaction design (e.g., color perception,
ergonomics) b. Cognitive models that inform interaction design (e.g.,
attention, perception and recognition, movement, memory) c. Topics in
social/behavioral psychology (e.g., cognitive biases, change blindness) 4\\.
Designing for diverse user populations. (See also: SEP-DEIA, HCI-
Accessibility) a. How differences (e.g., in race, ability, age, gender,
culture, experience, and education) impact user experiences and needs b.
Internationalization c. Designing for users from other cultures d. Cross-
cultural design e. Challenges to effective design evaluation. (e.g., sampling,
generalization; disability and disabled experiences) f. Universal design 5\\.
Collaboration and communication (See also: AI-SEP, SE-Teamwork, SEP-
Communication, SPDGame) a. Understanding the user in a multi-user context b.
Synchronous group communication (e.g., chat rooms, conferencing, online games)
c. Asynchronous group communication (e.g., email, forums, social networks) d.
Social media, social computing, and social network analysis e. Online
collaboration f. Social coordination and online communities g. Avatars,
characters, and virtual worlds Non-core: 6\\. Multi-user systems Illustrative
Learning Outcomes: CS Core: 1\\. Conduct a user-centered design process that is
integrated into a project. KA Core: 2\\. Compare and contrast the needs of
users with those of designers. 3\\. Identify the representative users of a
design and discuss who else could be impacted by it. 4\\. Describe empathy and
evaluation as elements of the design process. 5\\. Carry out and document an
analysis of users and their needs. 6\\. Construct a user story from a needs
assessment. 7\\. Redesign an existing solution to a population whose needs
differ from those of the initial target population. 8\\. Contrast the different
needs-finding methods for a given design problem. 9\\. Reflect on whether your
design would benefit from low-tech or no-tech components. Non-core: 10\\.
Recognize the implications of designing for a multi-user system/context."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "5" ;
    ns1:part_of "Human_Computer_Interaction_HCI" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-User_Understanding_the_User_Individual_goals_and_interactions_with_others.txt> .

"MSF-Discrete_Discrete_Mathematics" ns1:content """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
    ns1:cs_core_hours "29" ;
    ns1:ka_core_hours "11" ;
    ns1:part_of "Mathematical_and_Statistical_Foundations_MSF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> .

"NC-Applications_Networked_Applications" ns1:content """Pages: 199 HOURS CS Core = 3.5 + 0.25 (SEP) + 0.25 (PDC) KA Core = . NC-
Applications: Networked Applications CS Core: 1\\. Naming and address schemes
(e.g., DNS, and Uniform Resource Identifiers) 2\\. Distributed application
paradigms (e.g., client/server, peer-to-peer, cloud, edge, and fog) (See also:
PDC-Communication, PDC-Coordination) 3\\. Diversity of networked application
demands (e.g., latency, bandwidth, and loss tolerance) (See also: PDC-
Communication, SEP-Sustainability, SEP-Context) 4\\. Coverage of application-
layer protocols (e.g., HTTP) 5\\. Interactions with TCP, UDP, and Socket APIs
(See also: PDC-Programs) Illustrative Learning Outcomes: CS Core: 1\\. Define
the principles of naming, addressing, resource location. 2\\. Analyze the needs
of specific networked application demands. 3\\. Describe the details of one
application layer protocol. 4\\. Implement a simple client-server socket-based
application."""^^xsd:string ;
    ns1:cs_core_hours "3.5" ;
    ns1:ka_core_hours "0" ;
    ns1:part_of "Networking_and_Communication_NC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Applications_Networked_Applications.txt> .

"NC-Emerging_Emerging_Topics" ns1:content """Pages: 201 HOURS CS Core = . KA Core = 4 NC-Emerging: Emerging Topics KA Core:
1\\. Middleboxes (e.g., advances in usage of AI, intent-based networking,
filtering, deep packet inspection, load balancing, NAT, CDN) 2\\. Network
Virtualization (e.g., SDN, Data Center Networks) 3\\. Quantum Networking (e.g.,
Intro to the domain, teleportation, security, Quantum Internet) 4\\. Satellite,
mmWave, Visible Light Illustrative Learning Outcomes: KA Core: 1\\. Describe
the value of advances in middleboxes in networks. 2\\. Describe the importance
of Software Defined Networks. 3\\. Describe some of the added value achieved by
using Quantum Networking."""^^xsd:string ;
    ns1:cs_core_hours "201" ;
    ns1:ka_core_hours "4" ;
    ns1:part_of "Networking_and_Communication_NC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Emerging_Emerging_Topics.txt> .

"NC-Fundamentals_Fundamentals" ns1:content """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
    ns1:cs_core_hours "2.5" ;
    ns1:ka_core_hours "0" ;
    ns1:part_of "Networking_and_Communication_NC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> .

"NC-Mobility_Mobility" ns1:content """Pages: 201 HOURS CS Core = . KA Core = 4 NC-Mobility: Mobility KA Core: 1\\.
Principles of cellular communication (e.g., 4G, 5G) 2\\. Principles of Wireless
LANs (mainly 802.11) 3\\. Device to device communication (e.g., IoT
communication) 4\\. Multi-hop wireless networks (e.g., ad hoc networks,
opportunistic, delay tolerant) Illustrative Learning Outcomes: KA Core: 1\\.
Describe some aspects of cellular communication such as registration 2\\.
Describe how 802.11 supports mobile users 3\\. Describe practical uses of
device-to-device communication, as well as multihop 4\\. Describe one type of
mobile network such as ad hoc"""^^xsd:string ;
    ns1:cs_core_hours "201" ;
    ns1:ka_core_hours "4" ;
    ns1:part_of "Networking_and_Communication_NC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Mobility_Mobility.txt> .

"NC-Reliability_Reliability_Support" ns1:content """Pages: 199 HOURS CS Core = . KA Core = 5.75 + 0.25 (SF) NC-Reliability:
Reliability Support KA Core: 1\\. Unreliable delivery (e.g., UDP) 2\\.
Principles of reliability (e.g., delivery without loss, duplication, or out of
order) (See also: SFReliability) 3\\. Error control (e.g., retransmission,
error correction) 4\\. Flow control (e.g., stop and wait, window based) 5\\.
Congestion control (e.g., implicit and explicit congestion notification) 6\\.
TCP and performance issues (e.g., Tahoe, Reno, Vegas, Cubic) Illustrative
Learning Outcomes: KA Core: 1\\. Describe the operation of reliable delivery
protocols. 2\\. List the factors that affect the performance of reliable
delivery protocols. 3\\. Describe some TCP reliability design issues. 4\\.
Design and implement a simple reliable protocol."""^^xsd:string ;
    ns1:cs_core_hours "199" ;
    ns1:ka_core_hours "5.75" ;
    ns1:part_of "Networking_and_Communication_NC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Reliability_Reliability_Support.txt> .

"NC-Routing_Routing_and_Forwarding" ns1:content """Pages: 199-200 HOURS CS Core = . KA Core = 4 NC-Routing: Routing and
Forwarding KA Core: 1\\. Routing paradigms and hierarchy (e.g., intra/inter
domain, centralized and decentralized, source routing, virtual circuits, QoS)
2\\. Forwarding methods (e.g., forwarding tables and matching algorithms) 3\\.
IP and Scalability issues (e.g., NAT, CIDR, BGP, different versions of IP)
Illustrative Learning Outcomes: KA Core: 1\\. Describe various routing
paradigms and hierarchies. 2\\. Describe how packets are forwarded in an IP
network. 3\\. Describe how the Internet tackles scalability challenges. ."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Networking_and_Communication_NC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Routing_Routing_and_Forwarding.txt> .

"NC-Security_Network_Security" ns1:content """Pages: 200-201 HOURS CS Core = . KA Core = 2.25 + 0.5 (SEC) + 0.25 (SEP) NC-
Security: Network Security KA Core: 1\\. General intro about security (Threats,
vulnerabilities, and countermeasures) (See also: SEPSecurity, SEC-Foundations,
SEC-Engineering) 2\\. Network specific threats and attack types (e.g., denial
of service, spoofing, sniffing and traffic redirection, attacker-in-the-
middle, message integrity attacks, routing attacks, ransomware, and traffic
analysis) (See also: SEC-Foundations, SEC-Engineering) 3\\. Countermeasures (:
SEC-Foundations, SEC-Crypto, SEC-Engineering) a. Cryptography (e.g. SSL, TLS,
symmetric/asymmetric) b. Architectures for secure networks (e.g., secure
channels, secure routing protocols, secure DNS, VPNs, DMZ, Zero Trust Network
Access, hyper network security, anonymous communication protocols, isolation)
c. Network monitoring, intrusion detection, firewalls, spoofing and DoS
protection, honeypots, tracebacks, BGP Sec, RPKI Illustrative Learning
Outcomes: KA Core: 1\\. Describe some of the threat models of network security.
2\\. Describe specific network-based countermeasures. 3\\. Analyze various
aspects of network security from a case study."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6.75" ;
    ns1:part_of "Networking_and_Communication_NC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Security_Network_Security.txt> .

"NC-SingleHop_Single_Hop_Communication" ns1:content """Pages: 200 HOURS CS Core = . KA Core = 3 NC-SingleHop: Single Hop
Communication KA Core: 1\\. Introduction to modulation, bandwidth, and
communication media 2\\. Encoding and Framing 3\\. Medium Access Control (MAC)
(e.g., random access and scheduled access) 4\\. Ethernet and WiFi 5\\. Switching
(e.g., spanning trees, VLANS). 6\\. Local Area Network Topologies (e.g., data
center, campus networks). Illustrative Learning Outcomes: KA Core: 1\\.
Describe some basic aspects of modulation, bandwidth, and communication media.
2\\. Describe in detail a MAC protocol. 3\\. Demonstrate understanding of
encoding and framing solution tradeoffs. 4\\. Describe details of the
implementation of Ethernet. 5\\. Describe how switching works. 6\\. Describe one
kind of a LAN topology."""^^xsd:string ;
    ns1:cs_core_hours "200" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "Networking_and_Communication_NC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-SingleHop_Single_Hop_Communication.txt> .

"OS-Advanced-Files_Advanced_File_systems" ns1:content """Pages: 212-213 HOURS CS Core = 0 KA Core = 1 OS-Advanced-Files: Advanced File
systems KA Core: 1\\. File systems: partitioning, mount/unmount, virtual file
systems 2\\. In-depth implementation techniques 3\\. Memory-mapped files (See
also: AR-IO ) 4\\. Special-purpose file systems 5\\. Naming, searching, access,
backups 6\\. Journaling and log-structured file systems (See also: SF-
Reliability) Non-Core: (including emerging topics) 1\\. Distributed file
systems 2\\. Encrypted file systems 3\\. Fault tolerance Illustrative Learning
Outcomes: KA Core: 1\\. Explain how hardware developments have led to changes
in the priorities for the design and the management of file systems. 2\\. Map
file abstractions to a list of relevant devices and interfaces. 3\\. Identify
and categorize different mount types. 4\\. Explain specific file systems
requirements and the specialized file systems features that meet those
requirements. 5\\. Explain the use of journaling and how log-structured file
systems enhance fault tolerance. Non-Core: 6\\. Explain purpose and complexity
of distributed file systems. 7\\. List examples of distributed file systems
protocols. 8\\. Explain mechanisms in file systems to improve fault tolerance."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Advanced-Files_Advanced_File_systems.txt> .

"OS-Concurrency_Concurrency" ns1:content """Pages: 208 HOURS CS Core = 2 KA Core = 1 OS-Concurrency: Concurrency CS Core:
1\\. Thread abstraction relative to concurrency 2\\. Race conditions, critical
regions (role of interrupts, if needed) (See also: PDC-Programs) 3\\. Deadlocks
and starvation (See also: PDC-Coordination) 4\\. Multiprocessor issues (spin-
locks, reentrancy). 5\\. Multiprocess concurrency vs multithreading KA Core:
6\\. Thread creation, states, structures (See also: SF-Foundations) 7\\. Thread
APIs 8\\. Deadlocks and starvation (necessary conditions/mitigations) (See
also: PDC-Coordination) 9\\. Implementing thread safe code (semaphores, mutex
locks, condition variables). (See also: ARPerformance-Energy, SF-Evaluation,
PDC-Evaluation) 10\\. Race conditions in shared memory (See also: PDC-
Coordination) Non-Core: 11\\. Managing atomic access to OS objects (e.g., big
kernel lock vs many small locks vs lockless data structures like lists)
Illustrative Learning Outcomes: CS Core: 1\\. Understand the advantages and
disadvantages of concurrency as inseparable functions within the operating
system framework. 2\\. Understand how architecture level implementation results
in concurrency problems including race conditions. 3\\. Understand concurrency
issues in multiprocessor systems. KA Core: 4\\. Understand the range of
mechanisms that can be employed at the operating system level to realize
concurrent systems and describe the benefits of each. 5\\. Understand
techniques for achieving synchronization in an operating system (e.g.,
describe how a semaphore can be implemented using OS primitives) including
intra-concurrency control and use of hardware atomics. 6\\. Accurately analyze
code to identify race conditions and appropriate solutions for addressing race
conditions."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Concurrency_Concurrency.txt> .

"OS-Devices_Device_management" ns1:content """Pages: 211-212 HOURS CS Core = 0 KA Core = 0.5 + 0.5 (AR) OS-Devices: Device
management KA Core: 1\\. Buffering strategies (See also: AR-IO) 2\\. Direct
Memory Access (DMA) and polled I/O, Memory-mapped I/O (See also: AR-IO)
Example concept: DMA communication protocols (e.g., ring buffers etc.) 3\\.
Historical and contextual - Persistent storage device management (e.g.,
magnetic, Solid State Device (SSD)) (See also: SEP-History) Non-Core: 4\\.
Device interface abstractions, hardware abstraction layer 5\\. Device driver
purpose, abstraction, implementation, and testing challenges 6\\. High-level
fault tolerance in device communication Illustrative Learning Outcomes: KA
Core: 1\\. Explain architecture level device control implementation and link
relevant operating system mechanisms and policy (e.g., buffering strategies,
direct memory access). 2\\. Explain OS device management layers and the
architecture (e.g., device controller, device driver, device abstraction). 3\\.
Explain the relationship between the physical hardware and the virtual devices
maintained by the operating system. 4\\. Explain I/O data buffering and
describe strategies for implementing it. 5\\. Describe the advantages and
disadvantages of direct memory access and discuss the circumstances in which
its use is warranted. Non-Core: 6\\. Describe the complexity and best practices
for the creation of device drivers."""^^xsd:string ;
    ns1:cs_core_hours "0" ;
    ns1:ka_core_hours "1.0" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Devices_Device_management.txt> .

"OS-Faults_Fault_tolerance" ns1:content """Pages: 214-215 HOURS CS Core = 0 KA Core = 1 OS-Faults: Fault tolerance KA
Core: 1\\. Reliable and available systems. (See also: SF-Reliability) 2\\.
Software and hardware approaches to address tolerance (RAID). (See also: SF-
Reliability) Non-Core: 3\\. Spatial and temporal redundancy. (See also: SF-
Reliability) 4\\. Methods used to implement fault tolerance. (See also: SF-
Reliability) 5\\. Error identification and correction mechanisms, checksums of
volatile memory in RAM. (See also: AR-Memory) 6\\. File system consistency
check and recovery. 7\\. Journaling and log-structured file systems. (See also:
SF-Reliability) 8\\. Use-cases for fault-tolerance (databases, safety-
critical). (See also: SF-Reliability) 9\\. Examples of OS mechanisms for
detection, recovery, restart to implement fault tolerance, use of these
techniques for the OS's own services. (See also: SF-Reliability) Illustrative
Learning Outcomes: KA Core: 1\\. Explain how operating systems can facilitate
fault tolerance, reliability, and availability 2\\. Explain the range of
methods for implementing fault tolerance in an operating system. 3\\. Explain
how an operating system can continue functioning after a fault occurs. 4\\.
Explain the performance and flexibility tradeoffs that impact using fault
tolerance. Non-Core: 5\\. Describe operating systems fault tolerance issues and
mechanisms in detail."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Faults_Fault_tolerance.txt> .

"OS-Files_File_Systems_API_and_Implementation" ns1:content """Pages: 212 HOURS CS Core = 0 KA Core = 2 OS-Files: File Systems API and
Implementation KA Core: 1\\. Concept of a file including data, metadata,
operations, and access-mode 2\\. File system mounting 3\\. File access control
4\\. File sharing 5\\. Basic file allocation methods, including linked
allocation table 6\\. File system structures comprising file allocation
including various directory structures and methods for uniquely identifying
files (e.g., name, identified or metadata storage location) 7\\.
Allocation/deallocation/storage techniques (algorithms and data structure)
impact on performance and flexibility (i.e., internal and external
fragmentation and compaction) 8\\. Free space management such as using bit
tables vs linking 9\\. Implementation of directories to segment and track file
location Illustrative Learning Outcomes: KA Core: 1\\. Explain the choices to
be made in designing file systems. 2\\. Evaluate different approaches to file
organization, recognizing the strengths and weaknesses of each. 3\\. Apply
software constructs appropriately given knowledge of the file system
implementation."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Files_File_Systems_API_and_Implementation.txt> .

"OS-Memory_Memory_Management" ns1:content """Pages: 210-211 HOURS CS Core = 0 KA Core = 0.5 + 1.5 (AR) OS-Memory: Memory
Management KA Core: 1\\. Review of physical memory, address translation and
memory management hardware (See also: AR-Memory, MSF-Discrete) 2\\. Impact of
memory hierarchy including cache concept, cache lookup, and per-CPU caching on
operating system mechanisms and policy (See also: AR-Memory, SF-Performance)
3\\. Logical and physical addressing, address space virtualization (See also:
AR-Memory, MSFDiscrete) 4\\. Concepts of paging, page replacement, thrashing
and allocation of pages and frames 5\\. Allocation/deallocation/storage
techniques (algorithms and data structure) performance and flexibility Example
concept: Arenas, slab allocators, free lists, size classes, heterogeneously
sized pages (huge pages) 6\\. Memory caching and cache coherence and the effect
of flushing the cache to avoid speculative execution vulnerabilities (See
also: AR-Organization, AR-Memory, SF-Performance) 7\\. Security mechanisms and
concepts in memory management including sandboxing, protection, isolation, and
relevant vectors of attack (See also: SEC-Foundations) Non-Core: 8\\. Virtual
memory: leveraging virtual memory hardware for OS services and efficiency
Illustrative Learning Outcomes: KA Core: 1\\. Explain memory hierarchy and
cost-performance tradeoffs. 2\\. Summarize the principles of virtual memory as
applied to caching and paging. 3\\. Evaluate the tradeoffs in terms of memory
size (main memory, cache memory, auxiliary memory) and processor speed. 4\\.
Describe the reason for and use of cache memory (performance and proximity,
how caches complicate isolation and virtual machine abstraction). 5\\.
Code/Develop efficient programs that consider the effects of page replacement
and frame allocation on the performance of a process and the system in which
it executes. Non-Core: 6\\. Explain how hardware is utilized for efficient
virtualization"""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Memory_Memory_Management.txt> .

"OS-Process_Process_Model" ns1:content """Pages: 210 HOURS CS Core = 0 KA Core = 2 OS-Process: Process Model KA Core:
1\\. Processes and threads relative to virtualization protected memory, process
state, memory isolation, etc. 2\\. Memory footprint/segmentation (e.g., stack,
heap, etc.) (See also: AR-Assembly) 3\\. Creating and loading executables,
shared libraries, and dynamic linking (See also: FPL-Translation) 4\\.
Dispatching and context switching (See also: AR-Assembly) 5\\. Interprocess
communication (e.g., shared memory, message passing, signals, environment
variables) (See also: PDC-Communication) Illustrative Learning Outcomes: KA
Core: 1\\. Understand how processes and threads use concurrency features to
virtualize control. 2\\. Understand reasons for using interrupts, dispatching,
and context switching to support concurrency and virtualization in an
operating system. 3\\. Understand the different states that a task may pass
through, and the data structures needed to support the management of many
tasks. 4\\. Understand the different ways of allocating memory to tasks, citing
the relative merits of each. 5\\. Apply the appropriate interprocess
communication mechanism for a specific purpose in a programmed software
artifact."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Process_Process_Model.txt> .

"OS-Protection_Protection_and_Safety" ns1:content """Pages: 209 HOURS CS Core = 2 KA Core = 1 OS-Protection: Protection and Safety
CS Core: 1\\. Overview of operating system security mechanisms (See also: SEC-
Foundations) 2\\. Attacks and antagonism (scheduling, etc.) (See also: SEC-
Foundations) 3\\. Review of major vulnerabilities in real operating systems
(See also: SEC-Foundations) 4\\. Operating systems mitigation strategies such
as backups (See also: SF-Reliability) KA Core: 5\\. Policy/mechanism separation
(See also: SEC-Governance) 6\\. Security methods and devices (See also: SEC-
Foundations) Example concepts: a. Rings of protection (history from Multics to
virtualized x86) b. x86_64 rings -1 and -2 (hypervisor and ME/PSP) 7\\.
Protection, access control, and authentication (See also: SEC-Foundations,
SEC-Crypto) Illustrative Learning Outcomes: CS Core: 1\\. Understand the
requirement for protection and security mechanisms in operating systems. 2\\.
List and describe the attack vectors that leverage OS vulnerabilities. 3\\.
Understand the mechanisms available in an OS to control access to resources.
KA Core: 4\\. Summarize the features and limitations of an operating system
that impact protection and security."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Protection_Protection_and_Safety.txt> .

"OS-Purpose_Role_and_Purpose_of_Operating_Systems" ns1:content """Pages: 206-207 HOURS CS Core = 2 KA Core = 0 OS-Purpose: Role and Purpose of
Operating Systems CS Core: 1\\. Operating systems mediate between general
purpose hardware and application-specific software. 2\\. Universal operating
system functions (e.g., process, user and device interfaces, persistence of
data) 3\\. Extended and/or specialized operating system functions (e.g.,
embedded systems, server types such as file, web, multimedia, boot loaders and
boot security) 4\\. Design issues (e.g., efficiency, robustness, flexibility,
portability, security, compatibility, power, safety, tradeoffs between error
checking and performance, flexibility and performance, and security and
performance) (See also: SEC-Engineering) 5\\. Influences of security,
networking, multimedia, parallel and distributed computing 6\\. Overarching
concern of security/protection: Neglecting to consider security at every layer
creates an opportunity to inappropriately access resources. Example concepts:
a. Unauthorized access to files on an unencrypted drive can be achieved by
moving the media to another computer. b. Operating systems enforced security
can be defeated by infiltrating the boot layer before the operating system is
loaded. c. Process isolation can be subverted by inadequate authorization
checking at API boundaries. d. Vulnerabilities in system firmware can provide
attack vectors that bypass the operating system entirely. e. Improper
isolation of virtual machine memory, computing, and hardware can expose the
host system to attacks from guest systems. f. The operating system may need to
mitigate exploitation of hardware and firmware vulnerabilities, leading to
potential performance reductions (e.g., Spectre and Meltdown mitigations). 7\\.
Exposure of operating systems functions in shells and systems programming.
(See also: FPLScripting) Illustrative Learning Outcomes: CS Core: 1\\.
Understand the objectives and functions of modern operating systems. 2\\.
Evaluate the design issues in different usage scenarios (e.g., real time OS,
mobile, server). 3\\. Understand the functions of a contemporary operating
system with respect to convenience, efficiency, and the ability to evolve. 4\\.
Understand how evolution and stability are desirable and mutually antagonistic
in operating systems function."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "0" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Purpose_Role_and_Purpose_of_Operating_Systems.txt> .

"OS-Real-time_Real-time_and_Embedded_Systems" ns1:content """Pages: 214 HOURS CS Core = 0 KA Core = 1 OS-Real-time: Real-time and Embedded
Systems KA Core: 1\\. Process and task scheduling. 2\\. Deadlines and real-time
issues. (See also: SPD-Embedded) 3\\. Low-latency vs "soft real-time" vs "hard
real time." (See also: SPD-Embedded, FPL-Event-Driven) Non-Core: 4\\.
Memory/disk management requirements in a real-time environment. 5\\. Failures,
risks, and recovery. 6\\. Special concerns in real-time systems (safety).
Illustrative Learning Outcomes: KA Core: 1\\. Explain what makes a system a
real-time system. 2\\. Explain latency and its sources in software systems and
its characteristics. 3\\. Explain special concerns that real-time systems
present, including risk, and how these concerns are addressed. Non-Core: 4\\.
Explain specific real time operating systems features and mechanisms."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Real-time_Real-time_and_Embedded_Systems.txt> .

"OS-SEP_Society_Ethics_and_the_Profession" ns1:content """Pages: 215 HOURS CS Core = Included in SEP hours KA Core = Included in SEP
hours OS-SEP: Society, Ethics, and the Profession KA Core: 1\\. Open source in
operating systems. (See also: SEP-IP) Example concepts: a. Identification of
vulnerabilities in open-source kernels, b. Open-source guest operating
systems, c. Open-source host operating systems, and d. Changes in monetization
(paid vs free upgrades). 2\\. End-of-life issues with sunsetting operating
systems. Example concept: Privacy implications of using proprietary operating
systems/operating environments, including telemetry, automated scanning of
personal data, built-in advertising, and automatic cloud integration.
Illustrative Learning Outcomes: KA Core: 1\\. Explain advantages and
disadvantages of finding and addressing bugs in open-source kernels. 2\\.
Contextualize history and positive and negative impact of Linux as an open-
source product. 3\\. List complications with reliance on operating systems past
end-of-life. 4\\. Understand differences in finding and addressing bugs for
various operating systems payment models."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-SEP_Society_Ethics_and_the_Profession.txt> .

"OS-Scheduling_Scheduling" ns1:content """Pages: 209-210 HOURS CS Core = 0 KA Core = 2 OS-Scheduling: Scheduling KA
Core: 1\\. Preemptive and non-preemptive scheduling 2\\. Schedulers and policies
(e.g., first come, first serve, shortest job first, priority, round robin,
multilevel) (See also: SF-Resource) 3\\. Concepts of Symmetric Multi-Processor
(SMP) scheduling and cache coherence (See also: ARMemory) 4\\. Timers (e.g.,
building many timers out of finite hardware timers) (See also: AR-Assembly)
5\\. Fairness and starvation Non-Core: 6\\. Subtopics of operating systems such
as energy-aware scheduling and real-time scheduling (See also: AR-Performance-
Energy, SPD-Embedded, SPD-Mobile) 7\\. Cooperative scheduling, such as Linux
futexes and userland scheduling. Illustrative Learning Outcomes: KA Core: 1\\.
Compare and contrast the common algorithms used for both preemptive and non-
preemptive scheduling of tasks in operating systems, such as priority,
performance comparison, and fair-share schemes. 2\\. Explain the relationships
between scheduling algorithms and application domains. 3\\. Explain the
distinctions among types of processor scheduler such as short-term, medium-
term, long-term, and I/O. 4\\. Evaluate a problem or solution to determine
appropriateness for asymmetric and/or symmetric multiprocessing. 5\\. Evaluate
a problem or solution to determine appropriateness as a process vs threads.
6\\. List some contexts benefitting from preemption and deadline scheduling.
Non-Core: 7\\. Explain the ways that the logic embodied in scheduling
algorithms are applicable to other operating systems mechanisms, such as first
come first serve or priority to disk I/O, network scheduling, project
scheduling, and problems beyond computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Scheduling_Scheduling.txt> .

"OS-Virtualization_Virtualization" ns1:content """Pages: 213-214 HOURS CS Core = 0 KA Core = 1 OS-Virtualization: Virtualization
KA Core: 1\\. Using virtualization and isolation to achieve protection and
predictable performance. (See also: SFPerformance) 2\\. Advanced paging and
virtual memory. (See also: SF-Performance) 3\\. Virtual file systems and
virtual devices. 4\\. Containers and their comparison to virtual machines. 5\\.
Thrashing (e.g., Popek and Goldberg requirements for recursively virtualizable
systems). Non-core: 6\\. Types of virtualizations (including hardware/software,
OS, server, service, network). (See also: SFPerformance) 7\\. Portable
virtualization; emulation vs isolation. (See also: SF-Performance) 8\\. Cost of
virtualization. (See also: SF-Performance) 9\\. Virtual machines and container
escapes, dangers from a security perspective. (See also: SECEngineering) 10\\.
Hypervisors- hardware virtual machine extensions, hosts with kernel support,
QEMU KVM Illustrative Learning Outcomes: KA Core: 1\\. Explain how hardware
architecture provides support and efficiencies for virtualization. 2\\. Explain
the difference between emulation and isolation. 3\\. Evaluate virtualization
tradeoffs. Non-Core: 4\\. Explain hypervisors and the need for them in
conjunction with different types of hypervisors."""^^xsd:string ;
    ns1:cs_core_hours "0" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "Operating_Systems_OS" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Operating_Systems_OS/OS-Virtualization_Virtualization.txt> .

"PDC-Cloud_and_HPC" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD PDC-Cloud and HPC: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of PDC-Cloud and HPC.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Parallel_and_Distributed_Computing_PDC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Cloud_and_HPC.txt> .

"PDC-Concepts" ns1:content """Pages: 217-218 HOURS CS Core = 3 KA Core = 2 PDC-Concepts: Parallel and
Distributed Computing Fundamentals CS Core: 1\\. Introduction to parallel and
distributed computing. 2\\. Concepts of concurrency and parallelism. 3\\.
Multithreading and shared memory models. 4\\. Message passing and
synchronization mechanisms. 5\\. Fault tolerance in distributed systems. KA
Core: 6\\. Advanced scheduling techniques. 7\\. Performance evaluation and
scalability analysis. 8\\. Real-world applications in cloud computing and HPC.
Illustrative Learning Outcomes: 1\\. Describe key differences between parallel
and distributed systems. 2\\. Apply synchronization techniques to prevent race
conditions. 3\\. Evaluate the performance of parallel algorithms."""^^xsd:string ;
    ns1:cs_core_hours "3" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Parallel_and_Distributed_Computing_PDC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Concepts.txt> .

"PDC-Distributed_Systems" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD PDC-Distributed Systems: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
PDC-Distributed Systems. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Parallel_and_Distributed_Computing_PDC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Distributed_Systems.txt> .

"PDC-Fault_Tolerance" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD PDC-Fault Tolerance: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
PDC-Fault Tolerance. 2\\. Apply principles in practical scenarios. 3\\. Analyze
the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Parallel_and_Distributed_Computing_PDC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Fault_Tolerance.txt> .

"PDC-Grid_Computing" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD PDC-Grid Computing: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of PDC-Grid
Computing. 2\\. Apply principles in practical scenarios. 3\\. Analyze the
importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Parallel_and_Distributed_Computing_PDC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Grid_Computing.txt> .

"PDC-Parallel_Algorithms" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD PDC-Parallel Algorithms: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
PDC-Parallel Algorithms. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Parallel_and_Distributed_Computing_PDC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Parallel_Algorithms.txt> .

"PDC-Performance_Evaluation" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD PDC-Performance Evaluation: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
PDC-Performance Evaluation. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Parallel_and_Distributed_Computing_PDC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Performance_Evaluation.txt> .

"PDC-Synchronization_and_Concurrency" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD PDC-Synchronization and
Concurrency: Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder
topic 2 3\\. Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\.
Placeholder advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key
concepts of PDC-Synchronization and Concurrency. 2\\. Apply principles in
practical scenarios. 3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Parallel_and_Distributed_Computing_PDC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Synchronization_and_Concurrency.txt> .

"SDF-Algorithms" ns1:content """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
    ns1:cs_core_hours "6" ;
    ns1:ka_core_hours "None" ;
    ns1:part_of "Software_Development_Fundamentals_SDF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> .

"SDF-Fundamental_Data_Structures" ns1:content """Pages : 169-170 CS Core : 12, KA Core : None CS Core: (See also: AL-
Foundational) 1\\. Standard abstract data types such as lists, stacks, queues,
sets, and maps/dictionaries, including operations on them. 2\\. Selecting and
using appropriate data structures. 3\\. Performance implications of choice of
data structure(s). 4\\. Strings and string processing. Illustrative Learning
Outcomes: CS Core: 1\\. Write programs that use each of the key abstract data
types provided in the language (e.g., arrays, tuples/records/structs, lists,
stacks, queues, and associative data types like sets, dictionaries/maps). 2\\.
Select the appropriate data structure for a given problem. 3\\. Explain how the
performance of a program may change when using different data structures or
operations. 4\\. Write programs that work with text by using string processing
capabilities provided by the language."""^^xsd:string ;
    ns1:cs_core_hours "12" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Software_Development_Fundamentals_SDF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Data_Structures.txt> .

"SDF-Fundamental_Programming_Concepts_and_Practices" ns1:content """Pages : 168-169 CS Core : 20, KA Core : None CS Core: 1\\. Basic concepts such
as variables, primitive data types, expressions, and their evaluation 2\\. How
imperative programs work: state and state transitions on execution of
statements, flow of control 3\\. Basic constructs such as assignment
statements, conditional and iterative statements, basic I/O 4\\. Key modularity
constructs such as functions (and methods and classes, if supported in the
language) and related concepts like parameter passing, scope, abstraction,
data encapsulation (See also: FPL-OOP) 5\\. Input and output using files and
APIs 6\\. Structured data types available in the chosen programming language
like sequences (e.g., arrays, lists), associative containers (e.g.,
dictionaries, maps), others (e.g., sets, tuples) and when and how to use them
(See also: AL-Foundational) 7\\. Libraries and frameworks provided by the
language (when/where applicable) 8\\. Recursion 9\\. Dealing with runtime errors
in programs (e.g., exception handling). 10\\. Basic concepts of programming
errors, testing, and debugging (See also: SE-Construction, SEC-Coding) 11\\.
Documenting/commenting code at the program and module level.(See also: SE-
Construction) 12\\. Develop a security mindset. (See also: SEC-Foundations)
Illustrative Learning Outcomes: CS Core: In these learning outcomes, the term
"develop" means "design, write, test, and debug." 1\\. Develop programs that
use the fundamental programming constructs: assignment and expressions, basic
I/O, conditional and iterative statements. 2\\. Develop programs using
functions with parameter passing. 3\\. Develop programs that effectively use
the different structured data types provided in the language like
arrays/lists, dictionaries, and sets. 4\\. Develop programs that use file I/O
to provide data persistence across multiple executions. 5\\. Develop programs
that use language-provided libraries and frameworks (where applicable). 6\\.
Develop programs that use APIs to access or update data (e.g., from the web).
7\\. Develop programs that create simple classes and instantiate objects of
those classes (if supported by the language). 8\\. Explain the concept of
recursion and identify when and how to use it effectively. 9\\. Develop
recursive functions. 10\\. Develop programs that can handle runtime errors.
11\\. Read a given program and explain what it does. 12\\. Write comments for a
program or a module specifying what it does. 13\\. Trace the flow of control
during the execution of a program. 14\\. Use appropriate terminology to
identify elements of a program (e.g., identifier, operator, operand)."""^^xsd:string ;
    ns1:cs_core_hours "20" ;
    ns1:ka_core_hours "None" ;
    ns1:part_of "Software_Development_Fundamentals_SDF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt> .

"SDF-Society_Ethics_and_the_Profession" ns1:content """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Software_Development_Fundamentals_SDF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> .

"SE-Agile_and_DevOps" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Agile and DevOps: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Agile and DevOps. 2\\. Apply principles in practical scenarios. 3\\. Analyze
the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Software_Engineering_SE" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Engineering_SE/SE-Agile_and_DevOps.txt> .

"SE-Formal_Methods" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Software_Engineering_SE" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> .

"SE-Maintenance_and_Evolution" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Software_Engineering_SE" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> .

"SE-Project_Management" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Software_Engineering_SE" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> .

"SE-Requirements_Engineering" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Requirements Engineering: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Requirements Engineering. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Software_Engineering_SE" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Engineering_SE/SE-Requirements_Engineering.txt> .

"SE-Software_Architecture" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Software_Engineering_SE" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> .

"SE-Software_Development" ns1:content """Pages: 237-238 HOURS CS Core = 3 KA Core = 2 SE-Software Development:
Engineering Software Systems CS Core: 1\\. Software development lifecycle
models. 2\\. Requirements engineering principles. 3\\. Software design patterns
and architectures. 4\\. Software testing methodologies. 5\\. Version control and
collaboration tools. KA Core: 6\\. Agile and DevOps methodologies. 7\\. Software
maintenance and evolution. 8\\. Formal methods for verification and validation.
Illustrative Learning Outcomes: 1\\. Differentiate between various software
development models. 2\\. Apply software testing techniques to ensure quality
assurance. 3\\. Explain the role of version control in team-based software
development."""^^xsd:string ;
    ns1:cs_core_hours "3" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Software_Engineering_SE" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Development.txt> .

"SE-Testing_and_Quality_Assurance" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Software_Engineering_SE" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> .

"SE-Usability_and_Human_Factors" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Usability and Human Factors:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Usability and Human Factors. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Software_Engineering_SE" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Software_Engineering_SE/SE-Usability_and_Human_Factors.txt> .

"SEC-Access_Control" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SEC-Access Control: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SEC-Access
Control. 2\\. Apply principles in practical scenarios. 3\\. Analyze the
importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Security_SEC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Security_SEC/SEC-Access_Control.txt> .

"SEC-Cryptography" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SEC-Cryptography: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SEC-Cryptography.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Security_SEC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Security_SEC/SEC-Cryptography.txt> .

"SEC-Ethical_Hacking" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SEC-Ethical Hacking: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SEC-Ethical Hacking. 2\\. Apply principles in practical scenarios. 3\\. Analyze
the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Security_SEC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Security_SEC/SEC-Ethical_Hacking.txt> .

"SEC-Incident_Response" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SEC-Incident Response: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SEC-Incident Response. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Security_SEC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Security_SEC/SEC-Incident_Response.txt> .

"SEC-Malware_Analysis" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SEC-Malware Analysis: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SEC-Malware Analysis. 2\\. Apply principles in practical scenarios. 3\\. Analyze
the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Security_SEC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Security_SEC/SEC-Malware_Analysis.txt> .

"SEC-Network_Security" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SEC-Network Security: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SEC-Network Security. 2\\. Apply principles in practical scenarios. 3\\. Analyze
the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Security_SEC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Security_SEC/SEC-Network_Security.txt> .

"SEC-Security_Foundations" ns1:content """Pages: 255-256 HOURS CS Core = 3 KA Core = 2 SEC-Security Foundations:
Principles of Secure Computing CS Core: 1\\. Fundamental security principles
(Confidentiality, Integrity, Availability). 2\\. Threat models and risk
assessment. 3\\. Cryptographic techniques for data protection. 4\\. Secure
coding practices. 5\\. Authentication and access control mechanisms. KA Core:
6\\. Network security concepts and protocols. 7\\. Incident response and
forensics. 8\\. Advanced cryptographic methods. Illustrative Learning Outcomes:
1\\. Explain the CIA triad and its role in security. 2\\. Identify common
security vulnerabilities in software applications. 3\\. Apply cryptographic
techniques to ensure secure communications."""^^xsd:string ;
    ns1:cs_core_hours "3" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Security_SEC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Security_SEC/SEC-Security_Foundations.txt> .

"SEC-Threat_Modeling" ns1:content """Pages: TBD HOURS CS Core = TBD KA Core = TBD SEC-Threat Modeling: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SEC-Threat Modeling. 2\\. Apply principles in practical scenarios. 3\\. Analyze
the importance of this topic in computing."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Security_SEC" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Security_SEC/SEC-Threat_Modeling.txt> .

"SEP-Communication" ns1:content """Pages : 217-218 CS Core : 2, KA Core : 1 Computing is an inherently
collaborative and social discipline making communication an essential aspect
of the profession. Much but not all of this communication occurs in a
professional setting where communication styles, expectations, and norms
differ from other contexts where similar technology might be used. Both
professional and informal communication conveys information to various
audiences who may have different goals and needs for that information. Good
communication is also necessary for transparency and trustworthiness. It is
also important to note that computing professionals are not just communicators
but are also listeners who must be able to hear and thoughtfully make use of
feedback received from various stakeholders. Effective communication skills
are not something one 'just knows' - they are developed and can be learned.
Communication skills are best taught in context throughout the undergraduate
curriculum. CS Core: 1\\. Oral, written, and electronic team and group
communication 2\\. Technical communication materials (e.g., source code, and
documentation, tutorials, reference materials, API documentation) 3\\.
Communicating with different stakeholders such as customers, leadership, or
the public 4\\. Team collaboration (including tools) and conflict resolution
5\\. Accessibility and inclusivity requirements for addressing professional
audiences 6\\. Cultural competence in communication including considering the
impact of difference in natural language KA Core: 7\\. Tradeoffs in competing
factors that affect communication channels and choices 8\\. Communicating to
solve problems or make recommendations in the workplace, such as raising
ethical concerns or addressing accessibility issues Illustrative Learning
Outcomes: CS Core: 1\\. Understand the importance of writing concise and
accurate technical documents following well-defined standards for format and
for including appropriate tables, figures, and references. 2\\. Analyze written
technical documentation for technical accuracy, concision, lack of ambiguity,
and awareness of audience. 3\\. Compose and deliver an audience-aware,
accessible, and organized formal presentation. 4\\. Plan interactions (e.g.,
virtual, face-to-face, shared documents) with others in ways that invite
inclusive participation, model respectful consideration of others'
contributions, and explicitly value diversity of ideas. 5\\. Identify and
describe qualities of effective communication (e.g., virtual, face-to-face,
intragroup, shared documents). 6\\. Understand how to communicate effectively
and appropriately as a member of a team including conflict resolution
techniques. 7\\. Discuss ways to influence performance and results in diverse
and cross-cultural teams. KA Core: 8\\. Assess personal strengths and
weaknesses to work remotely as part of a team drawing from diverse backgrounds
and experiences. 9\\. Choose an appropriate way to communicate delicate ethical
concerns."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "Society_Ethics_and_the_Profession_SEP" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Communication.txt> .

"SEP-Diversity_Equity_Inclusion_and_Accessibility" ns1:content """Pages : 223-224 CS Core : 2, KA Core : 2 Despite being a creative, often
highly compensated field with myriad job (and other) opportunities, racial,
gender, and many other inequities in representation are pervasive in many
regions. For too many students, their first computer science course is their
last. There are many factors including the legacy of systemic racism, ableism,
sexism, classism, and other injustices that contribute to the lack of diverse
identities within computer science, and there is no single or quick fix.
CS2023's sponsoring organizations are ACM, IEEE, and AAAI. Each of these
places a high value on diversity, equity, inclusion, and accessibility; our
computer science classrooms should promote and model those principles. We
should welcome and seek diversity - the gamut of human differences including
gender identity, ethnicity, race, politics, abilities and attributes,
religion, nationality, etc.- in our classrooms, departments, and campuses. We
should strive to make our classrooms, labs, and curricula accessible and to
promote inclusion. We should aim for students and all community members to
have a sense of belonging that comes with being respected, wanted, and valued.
To achieve equity, we must allocate resources, promote fairness, and check our
biases to ensure persons of all identities achieve success. Accessibility
should be addressed and implemented in all computing activities and products.
Explicitly infusing diversity, equity, inclusion, and accessibility (DEIA)
across the computer science curriculum demonstrates its importance for the
department, institution, and our field - all of which are likely to have a
DEIA statement and/or initiative(s). This emphasis on DEIA is important
ethically and a bellwether issue of our time. Many professionals in computing
already recognize attention to DEIA as integral to disciplinary practice.
Regardless of the degree to which these values appear in any one computer
science class, research suggests that a lack of attention to them results in
inferior designs in addition to harm and its perpetuation. Not only does data
support that diverse teams outperform homogeneous ones, but diverse teams may
better prevent egregious technology failures in recent headlines such as
facial recognition misuse, airbag injuries and deaths, and other well-known
failures of science and computing. CS Core: 1\\. How identity impacts and is
impacted by computing technologies and environments (academic and
professional) 2\\. The benefits of diverse development teams and the impacts of
teams that are not diverse 3\\. Inclusive language and charged terminology, and
why their use matters 4\\. Inclusive behaviors and why they matter 5\\.
Designing and developing technology with accessibility in mind 6\\. How
computing professionals can influence and impact diversity, equity, inclusion
and accessibility, including but not only through the software they create KA
Core: 7\\. Experts and their practices that reflect the identities of the
classroom and the world through practical DEIA principles 8\\. Historic
marginalization due to systemic social mechanisms, technological supremacy and
global infrastructure challenges to diversity, equity, inclusion, and
accessibility 9\\. Cross-cultural differences in, and needs for, diversity,
equity, inclusion, and accessibility Illustrative Learning Outcomes: CS Core:
1\\. Define and distinguish equity, equality, diversity, inclusion, and
accessibility. 2\\. Identify language, practices, and behaviors that may make
someone feel included in a workplace and/or a team, and why is it relevant.
Avoid charged terminology - see Words Matter (www.acm.org/diversity-
inclusion/words-matter) - this includes identifying and accommodating users
who are often excluded without thought and not considered at all. 3\\. Evaluate
the accessibility of your classroom or lab. Evaluate the accessibility of your
webpage. (See www.w3.org/WAI and www.w3.org/TR/WCAG21). 4\\. Demonstrate
collegiality and respect when working with team members who do not share your
identity. It is not enough to merely assign team projects. Faculty should
prepare students for teamwork and monitor, mentor, and assess the
effectiveness of their student teams throughout a project. 5\\. Compare the
demographics of your institution's computer science and STEM majors to the
overall institutional demographics. If they differ, identify factors that
contribute to inequitable access, engagement, and achievement in computer
science among marginalized groups. If they do not, assess why not. 6\\.
Identify developers' assumptions and values embedded in hardware and software
design, especially as they pertain to usability by diverse populations. 7\\.
Identify examples of the benefits that diverse teams can bring to software
products, and how a lack of diversity has costs. KA Core: 8\\. Analyze the work
of experts who reflect the identities of the classroom and the world. 9\\.
Assess the impact of power and privilege in the computing profession as it
relates to culture, industry, products, and society. 10\\. Develop examples of
systemic changes that could positively address diversity, equity, inclusion,
and accessibility in a familiar context (i.e., in an introductory computing
course) and an unfamiliar context and when these might be different, or the
same. 11\\. Compare the demographics of your institution to the overall
community demographics. If they differ, identify factors that contribute to
inequitable access, engagement, and achievement among marginalized groups. If
they do not, assess why not."""^^xsd:string ;
    ns1:cs_core_hours 2 ;
    ns1:ka_core_hours 2 ;
    ns1:part_of "Society_Ethics_and_the_Profession_SEP" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt> .

"SEP-Economies_of_Computing" ns1:content """Page : 220 CS Core : 0, KA Core : 1 The economies of computing are important
to those who develop and provide computing resources and services to others as
well as society in general. They impact users of these resources and services,
both professional and non-professional. Computing professionals have a duty to
know the impact of these topics on their own roles and activities and how
choices made will impact users and society. KA Core: 1\\. Economic models:
regulated and unregulated, monopolies, network effects, and open market;
knowledge and attention economies 2\\. Pricing and deployment strategies:
planned obsolescence, subscriptions, freemium, software licensing, open-
source, free software, adware 3\\. Impacts of differences in access to
computing resources, and the effect of skilled labor supply and demand on the
quality of computing products 4\\. Automation, AI, and their effects on job
markets, developers, and users 5\\. Ethical concerns surrounding the attention
economy and other economies of computing (e.g. informed consent, data
collection, use of verbose legalese in user agreements) Illustrative Learning
Outcomes: KA Core: 1\\. Summarize the social effects of economic models (e.g.,
the knowledge and attention economies). 2\\. Describe the differences and
similarities of competing strategies (e.g., subscription vs freemium vs free).
3\\. Discuss examples of digital divides. 4\\. Understand the effects of
automation and AI on society. 5\\. Understand the ethical implications of
computing economies that rely on attention and data."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Society_Ethics_and_the_Profession_SEP" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Economies_of_Computing.txt> .

"SEP-Intellectual_Property" ns1:content """Pages : 215-216 CS Core : 1, KA Core : 1 Intellectual property refers to a
range of intangible rights of ownership in any product of human intellect,
such as a software program. Laws, which vary by locality, provide different
methods for protecting these rights of ownership based on their type. Ideally,
intellectual property laws balance the interests of creators and users of the
property. There are four types of intellectual property rights relevant to
software: patents, copyrights, trade secrets, and trademarks. Moreover,
property rights are often protected by user licenses. Each affords a different
type of legal protection. CS Core: 1\\. Intellectual property rights 2\\.
Intangible digital intellectual property (IDIP) 3\\. Legal foundations for
intellectual property protection 4\\. Common software licenses (e.g., MIT, GPL
and its variants, Apache, Mozilla, Creative Commons) 5\\. Plagiarism and
authorship KA Core: 6\\. Philosophical foundations of intellectual property 7\\.
Forms of intellectual property (e.g., copyrights, patents, trade secrets,
trademarks) and the rights they protect 8\\. Limitations on copyright
protections, including fair use and the first sale doctrine 9\\. Intellectual
property laws and treaties that impact the enforcement of copyrights 10\\.
Software piracy and technical methods for enforcing intellectual property
rights, such as digital rights management and closed source software as a
trade secret 11\\. Moral and legal foundations of the open-source movement 12\\.
Systems that use others' data (e.g., large language models) Illustrative
Learning Outcomes: CS Core: 1\\. Describe and critique legislation and
precedent aimed at digital copyright infringements. 2\\. Identify contemporary
examples of intangible digital intellectual property. 3\\. Select an
appropriate software license for a given project. 4\\. Defend legal and ethical
uses of copyrighted materials. 5\\. Interpret the intent and implementation of
software licensing. 6\\. Discuss whether a use of copyrighted material is
likely to be fair use. 7\\. Analyze the ethical issues inherent in various
plagiarism detection mechanisms. 8\\. Identify multiple forms of plagiarism
beyond verbatim copying of text or software (e.g., intentional paraphrasing,
authorship misrepresentation, and improper attribution). KA Core: 9\\. Discuss
the philosophical bases of intellectual property in an appropriate context
(e.g., country). 10\\. Distinguish the conflicting issues involved in securing
software patents. 11\\. Contrast the protections and obligations of copyright,
patent, trade secret, and trademarks. 12\\. Describe the rationale for the
legal protection of intellectual property in the appropriate context (e.g.,
country). 13\\. Analyze the use of copyrighted work under the concepts of fair
use and the first sale doctrine. 14\\. Identify the goals of the open-source
movement and its impact on fields beyond computing, such as the right-to-
repair movement. 15\\. Summarize the global nature of software piracy. 16\\.
Criticize the use of technical measures of digital rights management (e.g.,
encryption, watermarking, copy restrictions, and region lockouts) from
multiple stakeholder perspectives. 17\\. Discuss the nature of anti-
circumvention laws in the context of copyright protection."""^^xsd:string ;
    ns1:cs_core_hours "1" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "Society_Ethics_and_the_Profession_SEP" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Intellectual_Property.txt> .

"SEP-Methods_for_Ethical_Analysis" ns1:content """Pages : 212-213-214 CS Core : 2, KA Core : 1 Ethical theories and principles
are the foundations of ethical analysis because they are the viewpoints which
can provide guidance along the pathway to a decision. Each theory emphasizes
different assumptions and methods for determining the ethicality of a given
action. It is important for students to recognize that decisions in different
contexts may require different ethical theories (including combinations) to
arrive at ethically acceptable outcomes, and what constitutes 'acceptable'
depends on a variety of factors such as cultural context. Applying methods for
ethical analysis requires both an understanding of the underlying principles
and assumptions guiding a given tool and an awareness of the social context
for that decision. Traditional ethical frameworks (e.g., [11]) as provided by
western philosophy can be useful, but they are not all-inclusive. Effort must
be taken to include decolonial, indigenous, and historically marginalized
ethical perspectives whenever possible. No theory will be universally
applicable to all contexts, nor is any single ethical framework the 'best.'
Engagement across various ethical schools of thought is important for students
to develop the critical thinking needed in judiciously applying methods for
ethical analysis of a given situation. CS Core: 1\\. Avoiding fallacies and
misrepresentation in argumentation 2\\. Ethical theories and decision-making
(philosophical and social frameworks, e.g. [1]) 3\\. Recognition of the role
culture plays in our understanding, adoption, design, and use of computing
technology 4\\. Why ethics is important in computing, and how ethics is similar
to, and different from, laws andsocial norms KA Core: 5\\. Professional
checklists 6\\. Evaluation rubrics 7\\. Stakeholder analysis 8\\. Standpoint
theory 9\\. Introduction to ethical frameworks (e.g., consequentialism such as
utilitarianism, non-consequentialism such as duty, rights, or justice, agent-
centered such as virtue or feminism, contractarianism, ethics of care) and
their use for analyzing an ethical dilemma Illustrative Learning Outcomes: CS
Core: 1\\. Describe how a given cultural context impacts decision making. 2\\.
Express the use of example and analogy in ethical argument. 3\\. Analyze (and
avoid) basic logical fallacies in an argument. 4\\. Analyze an argument to
identify premises and conclusion. 5\\. Evaluate how and why ethics is so
important in computing and how it relates to cultural norms, values, and law.
6\\. Justify a decision made on ethical grounds. KA Core: 7\\. Distinguish all
stakeholder positions in relation to their cultural context in a given
situation. 8\\. Analyze the potential for introducing or perpetuating ethical
debt (deferred consideration of ethical impacts or implications) in technical
decisions. 9\\. Discuss the advantages and disadvantages of traditional ethical
frameworks. 10\\. Analyze ethical dilemmas related to the creation and use of
technology from multiple perspectives using ethical frameworks."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "Society_Ethics_and_the_Profession_SEP" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Methods_for_Ethical_Analysis.txt> .

"SEP-Privacy_and_Civil_Liberties" ns1:content """Pages : 216-217 CS Core : 2, KA Core : 1 Electronic information sharing
highlights the need to balance privacy protections with information access.
The ease of digital access to many types of data - in addition to copying and
distributing these data - makes privacy rights and civil liberties more
complex, especially given cultural and legal differences in these areas.
Complicating matters further, privacy also has interpersonal, organizational,
professional/business, and governance components. In addition, the
interconnected nature of online communities raises challenges for managing
expectations and protections for freedom of expression invarious cultures and
nations. Technology companies that provide platforms for user-generated
content are under increasing pressure to perform governance tasks, potentially
facing liability for their decisions. CS Core: 1\\. Privacy implications of
widespread data collection including but not limited to transactional
databases, data warehouses, surveillance systems, cloud computing, and
artificial intelligence 2\\. Conceptions of anonymity, pseudonymity, and
identity 3\\. Technology-based solutions for privacy protection (e.g., end-to-
end encryption and differential privacy) 4\\. Civil liberties, privacy rights,
and cultural differences KA Core: 5\\. Philosophical and legal conceptions of
the nature of privacy including the right to privacy 6\\. Legal foundations of
privacy protection in relevant jurisdictions (e.g., GDPR in the EU) 7\\.
Privacy legislation in areas of practice (e.g., HIPAA in the US, AI Act in the
EU) 8\\. Basic Principles of human-subjects research and principles beyond what
the law requires (e.g., Belmont Report, UN Universal Declaration on Human
Rights and how this relates to technology) 9\\. Freedom of expression and its
limitations 10\\. User-generated content, content moderation, and liability
Illustrative Learning Outcomes: CS Core: 1\\. Evaluate solutions to privacy
threats in transactional databases and data warehouses. 2\\. Describe the role
of data collection in the implementation of pervasive surveillance systems
(e.g., RFID, face recognition, toll collection, mobile computing). 3\\.
Distinguish the concepts and goals of anonymity and pseudonymity. 4\\. Describe
the ramifications of technology-based privacy protections, including
differential privacy and end-to-end encryption. 5\\. Identify cultural
differences regarding the nature and necessity of privacy and other civil
liberties. KA Core: 6\\. Discuss the philosophical basis for the legal
protection of personal privacy in an appropriate context (e.g., country). 7\\.
Critique the intent, potential value, and implementation of various forms of
privacy legislation and principles beyond what the law requires. 8\\. Identify
strategies to enable appropriate freedom of expression."""^^xsd:string ;
    ns1:cs_core_hours 2 ;
    ns1:ka_core_hours 1 ;
    ns1:part_of "Society_Ethics_and_the_Profession_SEP" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Privacy_and_Civil_Liberties.txt> .

"SEP-Professional_Ethics" ns1:content """Pages : 214-215 CS Core : 2, KA Core : 2 Computer ethics is a branch of
practical philosophy that deals with how computing professionals should make
decisions regarding professional and social conduct. There are three primary
influences: 1) the individual's own personal ethical code, 2) any informal or
formal regulation/decree/etc. of ethical behavior existing in the workplace,
applicable licensures, certifications, or laws, and 3) exposure to formal
codes of ethics and ethical frameworks. CS Core: 1\\. Community values and the
laws by which we live 2\\. The nature of being a professional including care,
attention, discipline, fiduciary responsibility, and mentoring 3\\. Keeping up
to date as a computing professional in terms of familiarity, tools, skills,
legal and professional frameworks as well as the ability and responsibility to
self-assess and progress in the computing field 4\\. Professional
certification, codes of ethics, conduct, and practice, such as the ACM, IEEE,
AAAI, and other international societies 5\\. Accountability, responsibility,
and liability (e.g., software correctness, reliability and safety, warranty,
negligence, strict liability, ethical approaches to security vulnerability
disclosures) including whether a product/service should be built, not just
doing so because it is technically possible. 6\\. Introduction to theories
describing the human creation and use of technology including instrumentalism,
sociology of technological systems, disability justice, neutrality thesis,
pragmatism, and decolonial models, including developing and using technology
to right wrongs and do good 7\\. Strategies for recognizing and reporting
designs, systems, software, and professional conduct (or their outcomes) that
may violate law or professional codes of ethics KA Core: 8\\. The role of the
computing professional and professional societies in public policy 9\\.
Maintaining awareness of consequences 10\\. Ethical dissent and whistleblowing
11\\. The relationship between regional culture and ethical dilemmas 12\\.
Dealing with harassment and discrimination 13\\. Forms of professional
credentialing 14\\. Ergonomics and healthy computing environments 15\\. Time-to-
market and cost considerations versus quality professional standards
Illustrative Learning Outcomes: CS Core: 1\\. Identify ethical issues that
arise in software design, development practices, and software deployment. 2\\.
Discuss how to address ethical issues in specific situations. 3\\. Express the
ethical responsibility of ensuring software correctness, reliability and
safety including from where this responsibility arises (e.g., ACM/IEEE/AAAI
Codes of Ethics, laws and regulations, organizational policies). 4\\. Describe
the mechanisms that typically exist for a professional to keep up to date in
ethical matters. 5\\. Describe the strengths and weaknesses of relevant
professional codes as expressions of being a professional and guides to
decision-making. 6\\. Analyze a global computing issue, observing the role of
professionals and government officials in managing this problem. KA Core: 7\\.
Describe ways in which professionals and professional organizations may
contribute to public policy. 8\\. Describe the consequences of inappropriate
professional behavior. 9\\. Be familiar with whistleblowing and have access to
knowledge to guide one through an incident. 10\\. Identify examples of how
regional culture interplays with ethical dilemmas. 11\\. Describe forms of
harassment and discrimination and avenues of assistance. 12\\. Assess various
forms of professional credentialing. 13\\. State the relationship between
ergonomics in computing environments and people's health. 14\\. Describe issues
associated with industries' push to focus on time-to-market versus enforcing
quality professional standards."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Society_Ethics_and_the_Profession_SEP" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Professional_Ethics.txt> .

"SEP-Security_Policies_Laws_and_Computer_Crimes" ns1:content """Page : 222 CS Core : 2, KA Core : 1 While security policies, laws and computer
crimes are important topics, it is essential they are viewed with the
foundation of other social and professional knowledge units, such as
Intellectual Property, Privacy and Civil Liberties, Social Context, and
Professional Ethics. Computers, the internet, and artificial intelligence,
perhaps more than any other technologies, have transformed society over the
past 75 years. At the same time, these technologies have contributed to
unprecedented threats to privacy; new categories of computer crime and
antisocial behavior; major disruptions to organizations; and the large-scale
concentration of risk in information systems. CS Core: 1\\. Computer crimes,
legal redress for computer criminals and impact on victims and society 2\\.
Social engineering, computing-enabled fraud, identity theft and recovery from
these 3\\. Cyber terrorism, criminal hacking, and hacktivism 4\\. Malware,
viruses, worms 5\\. Attacks on critical infrastructure such as electrical grids
and pipelines 6\\. Non-technical fundamentals of security (e.g., human
engineering, policy, confidentiality) KA Core: 7\\. Benefits and challenges of
existing and proposed computer crime laws 8\\. Security policies and the
challenges of change and compliance 9\\. Responsibility for security throughout
the computing life cycle 10\\. International and local laws and how they
intersect Illustrative Learning Outcomes: CS Core: 1\\. List classic examples
of computer crimes and social engineering incidents with societal impact. 2\\.
Identify issues with laws that apply to computer crimes. 3\\. Describe the
motivation and ramifications of cyber terrorism, data theft, hacktivism,
ransomware, and other attacks. 4\\. Examine the ethical and legal issues
surrounding the misuse of access and various breaches of security. 5\\. Discuss
the professional's role in security and the tradeoffs and challenges involved.
KA Core: 6\\. Investigate measures that can be taken by both individuals and
organizations including governments to prevent or mitigate the undesirable
effects of computer crimes. 7\\. Design a company-wide security policy, which
includes procedures for managing passwords and employee monitoring. 8\\.
Understand how legislation from one region may affect activities in another
(e.g., how EU GDPR applies globally, when EU persons are involved)."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "Society_Ethics_and_the_Profession_SEP" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Security_Policies_Laws_and_Computer_Crimes.txt> .

"SEP-Social_Context" ns1:content """Pages : 211-212 CS Core : 3, KA Core : 2 Computers, the internet, and
artificial intelligence - perhaps more than any other technologies - have
transformed society over the past several decades, with dramatic increases in
human productivity; an explosion of options for news, entertainment, and
communication; and fundamental breakthroughs in almost every branch of science
and engineering. It is imperative to recognize that this is not a one-way
street. Society also affects computing, resulting in a complex socio-technical
context that is constantly changing, requiring the perspective of history to
put the present as well as the possible future into appropriate perspective.
Social Context provides the foundation for all other knowledge units in SEP,
particularly Professional Ethics. CS Core: 1\\. Social implications (e.g.,
political and cultural ideologies) in a hyper-networked world where the
capabilities and impact of social media, artificial intelligence, and
computing in general are rapidly evolving. 2\\. Impact of computing
applications (e.g., social media, artificial intelligence applications) on
individual well-being, and safety of all kinds (e.g., physical, emotional,
economic). 3\\. Consequences of involving computing technologies, particularly
artificial intelligence, biometric technologies, and algorithmic decision-
making systems, in civic life (e.g., facial recognition technology, biometric
tags, resource distribution algorithms, policing software) and how human
agency and oversight is crucial. 4\\. How deficits in diversity and
accessibility in computing affect society and what steps can be taken to
improve equity in computing. KA Core: 5\\. Growth and control of the internet,
data, computing, and artificial intelligence 6\\. Often referred to as the
digital divide, differences in access to digital technology resources and its
resulting ramifications for gender, class, ethnicity, geography, and/or
developing countries, including consideration of responsibility to those who
might be less wealthy, under threat, or who would struggle to have their
voices heard. 7\\. Accessibility issues, including legal requirements such as
Web Content Accessibility Guidelines (www.w3.org/TR/WCAG21) 8\\. Context-aware
computing Illustrative Learning Outcomes: CS Core: 1\\. Describe the different
ways that computer technology (networks, mobile computing, artificial
intelligence) mediates social interaction at the personal and collective
levels. 2\\. Identify developers' assumptions and values embedded in hardware
and software design, especially as they pertain to usability for diverse
populations including under-served and those with disabilities. 3\\. Interpret
the social context of a given design and its implementation. 4\\. Analyze the
efficacy of a given design and implementation using empirical data. 5\\.
Understand the implications of technology use (e.g., social media) for
different identities, cultures, and communities. KA Core: 6\\. Describe the
internet's role in facilitating communication between citizens, governments,
and each other. 7\\. Analyze the effects of reliance on computing in the
implementation of democracy (e.g., delivery of social services, electronic
voting). 8\\. Describe the impact of a lack of appropriate representation of
people from historically minoritized populations in the computing profession
(e.g., industry culture, product diversity). 9\\. Discuss the implications of
context awareness in ubiquitous computing systems. 10\\. Express how access to
the internet and computing technologies affect different societies. 11\\.
Identify why/how internet access can be viewed as a human right."""^^xsd:string ;
    ns1:cs_core_hours "3" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Society_Ethics_and_the_Profession_SEP" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Social_Context.txt> .

"SEP-Sustainability" ns1:content """Pages : 219-220 CS Core : 1, KA Core : 1 Sustainability is defined by the
United Nations as "development that meets the needs of the present without
compromising the ability of future generations to meet their own needs." [12]
Alternatively, it is the "balance between the environment, equity and
economy." [13] As computing extends into more and more aspects of human
existence, we are already seeing estimates that double-digit percentages of
global electricity usage are consumed by computing activities, which unchecked
will likely grow. Further, electronics contribute individually to demand for
rare earth elements, mineral extraction, and countless e-waste concerns.
Students should gain a background that recognizes these global and
environmental costs and their potential long-term effects on the environment
and local communities. CS Core: 1\\. Environmental, social, and cultural
impacts of implementation decisions (e.g., sustainability goals, algorithmic
bias/outcomes, economic viability, and resource consumption) 2\\.
Local/regional/global social and environmental impacts of computing systems
and their use (e.g.,carbon footprints, resource usage, e-waste) due to
hardware (e.g., e-waste, data centers, rare element and resource utilization,
recycling) and software (e.g., cloud-based services, blockchain, AI model
training and use). This includes everyday use of hardware (cheap hardware
replaced frequently) and software (web-browsing, email, and other services
with hidden/remote computational demands). 3\\. Guidelines for sustainable
design standards. KA Core: 4\\. Systemic effects of complex computing
technologies and phenomena (e.g., generative AI, data centers, social media,
offshoring, remote work). 5\\. Pervasive computing: Information processing that
has been integrated into everyday objects and activities, such as smart energy
systems, social networking, and feedback systems to promote sustainable
behavior, transportation, environmental monitoring, citizen science and
activism. 6\\. How the sustainability of software systems is interdependent
with social systems, including the knowledge and skills of its users,
organizational processes and policies, and its societal context (e.g., market
forces, government policies). Illustrative Learning Outcomes: CS Core: 1\\.
Identify ways to be a sustainable practitioner in a specific area or with a
specific project. 2\\. Assess the environmental impacts of a given project's
deployment (e.g., energy consumption, contribution to e-waste, impact of
manufacturing). 3\\. Describe global social and environmental impacts of
computer use and disposal. 4\\. List the sustainable effects of modern
practices and activities (e.g., remote work, e-commerce, cryptocurrencies, AI
models, data centers). KA Core: 5\\. Describe the environmental impacts of
design choices within the field of computing that relate to algorithm design,
operating system design, networking design, database design, etc. 6\\. Analyze
the social and environmental impacts of new system designs. 7\\. Design
guidelines for sustainable IT design or deployment in areas such as smart
energy systems, social networking, transportation, agriculture, supply-chain
systems, environmental monitoring, and citizen activism. 8\\. Assess computing
applications in respect to environmental issues (e.g., energy, pollution,
resource usage, recycling and reuse, food management and production)."""^^xsd:string ;
    ns1:cs_core_hours "1" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "Society_Ethics_and_the_Profession_SEP" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Sustainability.txt> .

"SF-Basic_Concepts" ns1:content """Pages : 231-232 CS Core : 4, KA Core : 0 CS Core: 1\\. Digital vs
Analog/Discrete vs Continuous Systems 2\\. Simple logic gates, logical
expressions, Boolean logic simplification 3\\. Clocks, State, Sequencing 4\\.
State and state transition (e.g., starting state, final state, life cycle of
states) (See also: AL-Models) 5\\. Finite state machines (e.g., NFA, DFA) (See
also: AL-Models) 6\\. Combinational Logic, Sequential Logic, Registers,
Memories (See also: AR-Logic) 7\\. Computers and Network Protocols as examples
of State Machines (See also: NC-Fundamentals) 8\\. Sequential vs parallel
processing. (See also: PDC-Programs, OS-Concurrency) 9\\. Application-level
sequential processing: single thread (See also: PDC-Programs, OS-Concurrency)
10\\. Simple application-level parallel processing: request level (web
services/client-server/distributed), single thread per server, multiple
threads with multiple servers, pipelining (See also: PDC-Programs, OS-
Concurrency) Illustrative Learning Outcomes: CS Core: 1\\. Describe the
differences between digital and analog systems, and between discrete and
continuous systems. Can give real-world examples of these systems. 2\\.
Describe computations as a system characterized by a known set of
configurations with transitions from one unique configuration (state) to
another (state). 3\\. Describe the distinction between systems whose output is
only a function of their input (stateless) and those with memory/history
(stateful). 4\\. Develop state machine descriptions for simple problem
statement solutions (e.g., traffic light sequencing, pattern recognizers). 5\\.
Describe a computer as a state machine that interprets machine instructions.
6\\. Explain how a program or network protocol can also be expressed as a state
machine and that alternative representations for the same computation can
exist. 7\\. Derive the time-series behavior of a state machine from its state
machine representation (e.g., TCP connection management state machine). 8\\.
Write a simple sequential problem and a simple parallel version of the same
program. 9\\. Evaluate the performance of simple sequential and parallel
versions of a program with different problem sizes and be able to describe the
speed-ups achieved. 10\\. Describe on an execution timeline how parallelism
events and operations can take place simultaneously (i.e., at the same time).
Explain how work can be performed in less elapsed time if this can be
exploited."""^^xsd:string ;
    ns1:cs_core_hours "4" ;
    ns1:ka_core_hours "0" ;
    ns1:part_of "System_Fundamentals_SF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Basic_Concepts.txt> .

"SF-Overview_of_Computer_Systems" ns1:content """Pages : 230-231 CS Core : 3, KA Core : 0 CS Core: 1\\. Basic building blocks
and components of a computer (gates, flip-flops, registers, interconnections;
datapath + control + memory) 2\\. Hardware as a computational paradigm:
Fundamental logic building blocks; Logic expressions, minimization, sum of
product forms (See also: AR-Logic) 3\\. Programming abstractions, interfaces,
use of libraries (See also: PDC-Programs) 4\\. Distinction and interaction
between application and OS services, remote procedure call (See also: OS-
Purpose) 5\\. Basic concept of pipelining, overlapped processing stages (See
also: AR-Organization) 6\\. Basic concept of scaling: performance vs problem
size Illustrative Learning Outcomes: CS Core: 1\\. Describe the basic building
blocks of computers and their role in the historical development of computer
architecture. 2\\. Design a simple logic circuit using the fundamental building
blocks of logic design to solve a simple problem (e.g., adder). 3\\. Describe
how computing systems are constructed of layers upon layers, based on
separation of concerns, with well-defined interfaces, hiding details of low
layers from the higher layers. 4\\. Describe that hardware, OS, VM, and
application are additional layers of interpretation/processing. 5\\. Describe
the mechanisms of how errors are detected, signaled back, and handled through
the layers. 6\\. Construct a simple program (e.g., a TCP client/server) using
methods of layering, error detection and recovery, and reflection of error
status across layers. 7\\. Identify bugs in a layered program by using tools
for program tracing, single stepping, and debugging. 8\\. Understand the
concept of strong vs weak scaling, i.e., how performance is affected by the
scale of the problem vs the scale of resources to solve the problem. This can
be motivated by simple, real-world examples."""^^xsd:string ;
    ns1:cs_core_hours "3" ;
    ns1:ka_core_hours "0" ;
    ns1:part_of "System_Fundamentals_SF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt> .

"SF-Performance_Evaluation" ns1:content """Pages : 233-234 CS Core : 2, KA Core : 2 CS Core: 1\\. Performance figures of
merit (See also: AR-Performance-Energy, PDC-Evaluation) 2\\. Workloads and
representative benchmarks, and methods of collecting and analyzing performance
figures of merit (See also: AR-Performance-Energy, PDC-Evaluation) 3\\. CPI
(Cycles per Instruction) equation as a tool for understanding tradeoffs in the
design of instruction sets, processor pipelines, and memory system
organizations (See also: AR-Performance-Energy, PDC-Evaluation) 4\\. Amdahl's
Law: the part of the computation that cannot be sped up limits the effect of
the parts that can (See also: AR-Performance-Energy, PDC-Evaluation) 5\\. Order
of magnitude analysis (Big O notation) (See also: AL-Complexity) 6\\. Analysis
of slow and fast paths of a system (See also: AR-Organization) 7\\. Events on
their effect on performance (e.g., instruction stalls, cache misses, page
faults) (See also: OS-Memory, AR-Organization) KA Core: 7\\. Analytical tools
to guide quantitative evaluation 8\\. Understanding layered systems, workloads,
and platforms, their implications for performance, and the challenges they
represent for evaluation 9\\. Microbenchmark pitfalls Illustrative Learning
Outcomes: CS Core: 1\\. Explain how the components of system architecture
contribute to improving its performance. 2\\. Explain the circumstances in
which a given figure of a system performance metric is useful. 3\\. Explain the
usage and inadequacies of benchmarks as a measure of system performance. 4\\.
Describe Amdahl's law and discuss its limitations. 5\\. Apply limit studies or
simple calculations to produce order-of-magnitude estimates for a given
performance metric in a given context. 6\\. Apply software tools to profile and
measure program performance. KA Core: 7\\. Design and conduct a performance-
oriented experiment of a common system (e.g., an OS and Spark). 8\\. Design a
performance experiment on a layered system to determine the effect of a system
parameter on system performance."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "System_Fundamentals_SF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Performance_Evaluation.txt> .

"SF-Ressource_Management" ns1:content """Page : 232 CS Core : 1, KA Core : 1 CS Core: 1\\. Different types of resources
(e.g., processor share, memory, disk, net bandwidth) (See also: OS-Scheduling,
OS-Memory, OS-Files, NC-Fundamentals) 2\\. Common resource
allocation/scheduling algorithms (e.g., first-come-first-serve, priority-based
scheduling, fair scheduling, and preemptive scheduling) (See also: OS-
Scheduling) KA Core: 3\\. Advantages and disadvantages of common scheduling
algorithms (See also: OS-Scheduling) Illustrative Learning Outcomes: CS Core:
1\\. Define how finite computer resources (e.g., processor share, memory,
storage, and network bandwidth) are managed by their careful allocation to
existing entities. 2\\. Describe how common resource allocation/scheduling
algorithms work. 3\\. Develop common scheduling algorithms and evaluate their
performances. KA Core: 4\\. Describe the pros and cons of common scheduling
algorithms."""^^xsd:string ;
    ns1:cs_core_hours "1" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "System_Fundamentals_SF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Ressource_Management.txt> .

"SF-Society_Ethics_and_Profession" ns1:content """Pages : 235-236 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) KA Core: 1\\. Intellectual property
rights of computer systems (See also: SEP-IP) 2\\. Common software licenses
(See also: SEP-IP) 3\\. Computer crimes (See also: SEP-Security) Illustrative
Learning Outcomes: KA Core: 1\\. Describe the intellectual property rights of
computer systems. 2\\. List representative software licenses and compare their
differences. 3\\. List representative computer crimes."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "System_Fundamentals_SF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Society_Ethics_and_Profession.txt> .

"SF-System_Design" ns1:content """Page : 235 CS Core : 2, KA Core : 1 CS Core: 1\\. Common criteria of system
design (e.g., liveness, safety, robustness, scalability, and security) (See
also: PDC-Evaluation) KA Core: 2\\. Designs of representative systems (e.g.,
Apache web server, Spark, and Linux) Illustrative Learning Outcomes: CS Core:
1\\. Describe common criteria of system design. 2\\. Given the functionality
requirements of a system and its key design criteria, provide a high-level
design of this system. KA Core: 3\\. Describe the design of some representative
systems."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "System_Fundamentals_SF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Design.txt> .

"SF-System_Performance" ns1:content """Pages : 232-233 CS Core : 2, KA Core : 2 CS Core: 1\\. Latencies in computer
systems a. Speed of light and computers (one foot per nanosecond vs one GHz
clocks) (See also: AR-Organization) b. Memory vs disk latencies vs across-the-
network memory (See also: AR-Memory, AR-Performance-Energy) 2\\. Caches and the
effects of spatial and temporal locality on performance in processors and
systems (See also: AR-Memory, AR-Performance-Energy, OS-Memory) 3\\. Caches and
cache coherency in databases, operating systems, distributed systems, and
computer architecture (See also: OS-Memory, AR-Memory, DM-Internals) 4\\.
Introduction to the processor memory hierarchy (See also: AR-Memory, AR-
Performance-Energy) KA Core: 5\\. The formula for average memory access time
(See also: AR-Memory) 6\\. Rationale of virtualization and isolation:
protection and predictable performance (See also: OS-Virtualization) 7\\.
Levels of indirection, illustrated by virtual memory for managing physical
memory resources (See also: OS-Virtualization) 8\\. Methods for implementing
virtual memory and virtual machines (See also: OS-Virtualization) Illustrative
Learning Outcomes: CS Core: 1\\. Describe the breakdown of the latency of
computer systems in terms of memory, disk, and network. 2\\. Explain the
importance of locality in determining system performance. 3\\. Calculate
average memory access time and describe the tradeoffs in memory hierarchy
performance in terms of capacity, miss/hit rate, and access time. KA Core: 4\\.
Explain why it is important to isolate and protect the execution of individual
programs and environments that share common underlying resources. 5\\. Describe
how the concept of indirection can create the illusion of a dedicated machine
and its resources even when physically shared among multiple programs and
environments. 6\\. Evaluate the performance of two application instances
running on separate virtual machines and determine the effect of performance
isolation."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "System_Fundamentals_SF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Performance.txt> .

"SF-System_Reliability" ns1:content """Page : 234 CS Core : 2, KA Core : 1 CS Core: 1\\. Distinction between bugs,
faults, and failures (See also: PDC-Coordination, SE-Reliability) 2\\.
Reliability vs availability 3\\. Reliability through redundancy a. check and
retry (See also: OS-Faults, NC-Reliability) b. redundant encoding (error
correction codes, CRC, FEC, RAID) (See also: AR-Memory, NC-Reliability, DM-
Distributed) c. duplication/mirroring/replicas (See also: DM-Distributed) KA
Core: 4\\. Other approaches to reliability (e.g., journaling) (See also: OS-
Faults, NC-Reliability, SE-Reliability) Illustrative Learning Outcomes: CS
Core: 1\\. Explain the distinction between program errors, system errors, and
hardware faults (e.g., corrupted memory) and exceptions (e.g., attempt to
divide by zero). 2\\. Articulate the distinction between detecting, handling,
and recovering from faults and the methods for their implementation. 3\\.
Describe the role of error correction codes in providing error checking and
correction techniques in memories, storage, and networks. 4\\. Apply simple
algorithms for exploiting redundant information for the purposes of data
correction. KA Core: 5\\. Compare different error detection and correction
methods for their data overhead, implementation complexity, and relative
execution time for encoding, detecting, and correcting errors."""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "1" ;
    ns1:part_of "System_Fundamentals_SF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Reliability.txt> .

"SF-System_Security" ns1:content """Page : 235 CS Core : 2, KA Core : 1 CS Core: 1\\. Common system security issues
(e.g., viruses, denial-of-service attacks, and eavesdropping) (See also: OS-
Protection, NC-Security, SEC-Foundations, SEC-Engineering) 2\\. Countermeasures
(See also: OS-Principles, OS-Protection, NC-Security) a. Cryptography (See
also: SEC-Crypto) b. Security architecture (See also: SEC-Engineering) KA
Core: 3\\. Representative countermeasure systems a. Intrusion detection
systems, firewalls (See also: NC-Security) b. Antivirus systems Illustrative
Learning Outcomes: CS Core: 1\\. Describe some common system security issues
and give examples 2\\. Describe some countermeasures against system security
issues KA Core: 3\\. Describe representative countermeasure systems"""^^xsd:string ;
    ns1:cs_core_hours "2" ;
    ns1:ka_core_hours "3" ;
    ns1:part_of "System_Fundamentals_SF" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Security.txt> .

"SPD-Common_Aspects" ns1:content """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
    ns1:cs_core_hours "4" ;
    ns1:ka_core_hours "2" ;
    ns1:part_of "Specialized_Platform_Development_SPD" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> .

"SPD-Embedded_Platforms" ns1:content """Pages : 243-244 CS Core : None, KA Core : 4 (+10) (Additional hours here are
hours shared with other Areas) KA Core: 1\\. Introduction to the unique
characteristics of embedded systems a. Real-time vs soft real-time and non-
real-time systems b. Resource constraints, such as memory profiles and
deadlines (See also: AR-Memory) 2\\. API for custom architectures a. GPU
technology (See also: AR-Heterogeneity, GIT-Shading) b. Field Programmable
Gate Arrays (FPGA) (See also: AR-Logic) c. Cross-platform systems 3\\. Embedded
Systems a. Microcontrollers b. Interrupts and feedback c. Interrupt handlers
in high-level languages (See also: SF-Overview) d. Hard and soft interrupts
and trap-exits (See also: OS-Principles) e. Interacting with hardware,
actuators, and sensors f. Energy efficiency g. Loosely timed coding and
synchronization h. Software adapters 4\\. Embedded programming 5\\. Hard real-
time systems vs soft real-time systems (See also: OS-Real-time) a. Timeliness
b. Time synchronization/scheduling c. Prioritization d. Latency e. Compute
jitter 6\\. Real-time resource management 7\\. Memory management a. Mapping
programming construct (variable) to a memory location (See also: AR-Memory) b.
Shared memory (See also: OS-Memory) c. Manual memory management. d. Garbage
collection (See also: FPL-Translation) 8\\. Safety considerations and safety
analysis (See also: SEP-Context, SEP-Professional-Ethics) 9\\. Sensors and
actuators 10\\. Analysis and verification 11\\. Application design Illustrative
Learning Outcomes: KA Core: 1\\. Design and implement a small embedded system
for a given platform (e.g., a smart alarm clock or a drone). 2\\. Describe the
unique characteristics of embedded systems versus other systems. 3\\. Interface
with sensors/actuators. 4\\. Debug a problem with an existing embedded
platform. 5\\. Identify different types of embedded architectures. 6\\. Evaluate
which architecture is best for a given set of requirements. 7\\. Design and
develop software to interact with and control hardware. 8\\. Design methods for
real-time systems. 9\\. Evaluate real-time scheduling and schedulability
analysis. 10\\. Evaluate formal specification and verification of timing
constraints and properties."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Specialized_Platform_Development_SPD" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Embedded_Platforms.txt> .

"SPD-Game_Platforms" ns1:content """Pages : 244-245-246 CS Core : None, KA Core : 4 (+16) (Additional hours here
are hours shared with other Areas) KA Core: 1\\. Historical and contemporary
platforms for games (See also: AR-Logic) a. Evolution of Game Platforms (e.g.,
Brown Box to Metaverse and beyond; Improvement in Computing Architectures (CPU
and GPU); Platform Convergence and Mobility) b. Typical Game Platforms (e.g.,
Personal Computer; Home Console; Handheld Console; Arcade Machine; Interactive
Television; Mobile Phone; Tablet; Integrated Head-Mounted Display; Immersive
Installations and Simulators; Internet of Things enabled Devices; CAVE
Systems; Web Browsers; Cloud-based Streaming Systems) c. Characteristics and
Constraints of Different Game Platforms (e.g., Features (local storage,
internetworking, peripherals); Run-time performance (GPU/CPU frequency, number
of cores); Chipsets (physics processing units, vector co-processors);
Expansion Bandwidth (PCIe); Network throughput (Ethernet); Memory types and
capacities (DDR/GDDR); Maximum stack depth; Power consumption; Thermal design;
Endian) d. Typical Sensors, Controllers, and Actuators (e.g., distinctive
control system designs -peripherals (mouse, keypad, joystick), game
controllers, wearables, interactive surfaces; electronics and bespoke
hardware; computer vision, inside-out tracking, and outside-in tracking; IoT-
enabled electronics and I/O) (See also: GIT-Interaction) e. eSports Ecosystems
(e.g., evolution of gameplay across platforms; games and eSports; game events
such as LAN/arcade tournaments and international events such as the Olympic
eSports Series; streamed media and spectatorship; multimedia technologies and
broadcast management; professional play; data and machine learning for
coaching and training) 2\\. Real-time Simulation and Rendering Systems a. CPU
and GPU architectures (e.g., Flynn's taxonomy; parallelization; instruction
sets; standard components - graphics compute array, graphics memory
controller, video graphics array basic input/output system; bus interface;
power management unit; video processing unit; display interface) (See also:
AR-Heterogeneity) b. Pipelines for physical simulations and graphical
rendering: (e.g., tile-based, immediate-mode). (See also: GIT-Rendering) c.
Common Contexts for Algorithms, Data Structures, and Mathematical Functions
(e.g., game loops; spatial partitioning, viewport culling, and level of
detail; collision detection and resolution; physical simulation; behavior for
intelligent agents; procedural content generation) (See also: MSF-Discrete,
AL-Foundational) d. Media representations (e.g., I/O, and computation
techniques for virtual worlds: audio; music; sprites; models and textures;
text; dialogue; multimedia (e.g., olfaction, tactile)) (See also: GIT-
Fundamentals) 3\\. Game Development Tools and Techniques a. Programming
Languages (e.g., C++; C#; Lua; Python; JavaScript) b. Shader Languages (e.g.,
HLSL, GLSL; Shader Graph) c. Graphics Libraries and APIs (e.g., DirectX; SDL;
OpenGL; Metal; Vulkan; WebGL). (See also: GIT-Rendering, HCI-Design) d. Common
Development Tools and Environments (e.g., IDEs; Debuggers; Profilers; Version
Control Systems including those handling binary assets; Development Kits and
Production/Consumer Kits; Emulators) (See also: SDF-Practices, SE-Tools) 4\\.
Game Engines a. Open Game Engines (e.g., Unreal; Unity; Godot; CryEngine;
Phyre; Source 2; Pygame and Ren'Py; Phaser; Twine; Spring RTS) b. Techniques
(e.g., Ideation, Prototyping, Iterative Design and Implementation, Compiling
Executable Builds, Development Operations and Quality Assurance - Play Testing
and Technical Testing, Profiling; Optimization, Porting; Internationalization
and Localization, Networking) (See also: AR-Performance-Energy, SE-
Requirements) 5\\. Game Design a. Vocabulary (e.g., game definitions;
mechanics-dynamics-aesthetics model; industry terminology; experience design;
models of experience and emotion) b. Design Thinking and User-Centered
Experience Design (e.g., methods of designing games; iteration, incrementing,
and the double-diamond; phases of pre- and post-production; quality assurance,
including alpha and beta testing; stakeholder and customer involvement;
community management) (See also: SE-Design) c. Genres (e.g., adventure;
walking simulator; first-person shooter; real-time strategy; multiplayer
online battle arena (MOBA); role-playing game (rpg)) d. Audiences and Player
Taxonomies (e.g., people who play games; diversity and broadening
participation; pleasures, player types, and preferences; Bartle, yee) (See
also: HCI-User) e. Proliferation of digital game technologies to domains
beyond entertainment (e.g., Education and Training; Serious Games; Virtual
Production; eSports; Gamification; Immersive Experience Design; Creative
Industry Practice; Artistic Practice; Procedural Rhetoric) (See also: AI-SEP)
Illustrative Learning Outcomes: KA Core: 1\\. Recall the characteristics of
common general-purpose graphics processing architectures. 2\\. Identify the key
stages of the immediate-mode rendering pipeline. 3\\. Describe the key
constraints a specific game platform will likely impose on developers. 4\\.
Explain how eSports are streamed to large audiences over the internet. 5\\.
Translate complex mathematical functions into performant source code. 6\\. Use
an industry-standard graphics API to render a 3D model in a virtual scene. 7\\.
Modify a shader to change a visual effect according to stated requirements.
8\\. Implement a game for a particular platform according to the specification.
9\\. Optimize a function for processing collision detection in a simulated
environment. 10\\. Assess a game's run-time and memory performance using an
industry-standard tool and development environment. 11\\. Compare the
interfaces of different game platforms, highlighting their respective
implications for human-computer interaction. 12\\. Recommend an appropriate set
of development tools and techniques for implementing a game of a particular
genre for a given platform. 13\\. Discuss the key challenges in making a
digital game that is cross-platform compatible. 14\\. Express how game
developers can enhance the accessibility of a game interface. 15\\. Create
novel forms of gameplay using frontier game platforms."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Specialized_Platform_Development_SPD" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt> .

"SPD-Interactive_Computing_Platforms" ns1:content """Pages : 246-247 CS Core : None, KA Core : 3 (+5) (Additional hours here are
hours shared with other Areas) Non-core: 1\\. Data Analysis Platforms a.
Jupyter notebooks; Google Colab; R; SPSS; Observable. b. Cloud SQL/data
analysis platforms (e.g., BigQuery) (See also: DM-Querying) i. Apache Spark
ii. Data Visualizations (See also: GIT-Visualization) c. Interactive
presentations backed by data d. Design tools requiring low-latency feedback
loops i. Rendering tools ii. Graphic design tools 2\\. Prompt programming a.
Generative AI (e.g., OpenAI's ChatGPT, OpenAI's Codex, GitHub's Copilot) and
LLMs are accessed/interacted 3\\. Quantum Platforms (See also: AR-Quantum) a.
Program quantum logic operators in quantum machines. b. Use API for available
quantum services c. Signal analysis/Fourier analysis/Signal processing (for
music composition, audio/RF analysis) (See also: GIT-Image) Illustrative
Learning Outcomes: Non-core: 1\\. Analyze large datasets interactively. 2\\.
Create a backing track for a musical performance, such as live coding. 3\\.
Create compelling computational notebooks that construct a narrative for a
given journalistic goal/story. 4\\. Implement interactive code that uses a
dataset and generates exploratory graphics. 5\\. Create a program that performs
a task using LLM systems. 6\\. Contrast a program developed by an AI platform
and by a human. 7\\. Implement a system that interacts with a human without
using a screen. 8\\. Contextualize the attributes of different data analysis
styles, such as interactive vs engineered pipeline. 9\\. Write a program using
a notebook computing platform (e.g., searching, sorting, or graph
manipulation). 10\\. Demonstrate a quantum gate outcome using a quantum
platform."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Specialized_Platform_Development_SPD" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Interactive_Computing_Platforms.txt> .

"SPD-Mobile_Platforms" ns1:content """Pages : 241-242 CS Core : None, KA Core : 3 (+5) (Additional hours here are
hours shared with other Areas) KA Core: 1\\. Development with a. Mobile
programming languages b. Mobile programming environments 2\\. Mobile platform
constraints a. User interface design (See also: HCI-User) b. Security 3\\.
Access a. Accessing data through APIs (See also: DM-Querying) b. Designing API
endpoints for mobile apps: pitfalls and design considerations c. Network and
web interfaces (See also: NC-Fundamentals, DM-Modeling) Non-core: 4\\.
Development a. Native versus cross-platform development b. Software
design/architecture patterns for mobile applications (See also: SE-Design) 5\\.
Mobile platform constraints a. Responsive user interface design (See also:
HCI-Accessibility) b. Heterogeneity and mobility of devices c. Differences in
user experiences (e.g., between mobile and web-based applications) d. Power
and performance tradeoff 6\\. Mobile computing affordances a. Location-aware
applications b. Sensor-driven computing (e.g., gyroscope, accelerometer,
health data from a watch) c. Telephony and instant messaging d. Augmented
reality (See also: GIT-Immersion) 7\\. Specification and testing (See also:
SDF-Practices, SE-Validation) 8\\. Asynchronous computing (See also: PDC-
Algorithms) a. Difference from traditional synchronous programming b. Handling
success via callbacks c. Handling errors asynchronously d. Testing
asynchronous code and typical problems in testing Illustrative Learning
Outcomes: KA Core: 1\\. Compare mobile programming with general-purpose
programming. 2\\. Develop a location-aware mobile application with data API
integration. 3\\. Build a sensor-driven mobile application capable of logging
data on a remote server. 4\\. Create a communication app incorporating
telephony and instant messaging. 5\\. Evaluate the pros and cons of native and
cross-platform mobile application development."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Specialized_Platform_Development_SPD" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Mobile_Platforms.txt> .

"SPD-Robot_Platforms" ns1:content """Pages : 242-243 CS Core : None, KA Core : 4 (+6) (Additional hours here are
hours shared with other Areas) KA Core: 1\\. Types of robotic platforms and
devices (See also: AI-Robotics) 2\\. Sensors, embedded computation, and
effectors (actuators) (See also: GIT-Physical) 3\\. Robot-specific languages
and libraries (See also: AI-Robotics) 4\\. Robotic software architecture (e.g.,
using the Robot Operating System (ROS)) 5\\. Robotic platform constraints and
design considerations (See also: AI-Robotics) 6\\. Interconnections with
physical or simulated systems (See also: GIT-Physical, GIT-Simulation) 7\\.
Robotic Algorithms (See also: AI-Robotics, GIT-Animation) a. Forward
kinematics b. Inverse kinematics c. Dynamics d. Navigation and path planning
e. Grasping and manipulation 8\\. Safety and interaction considerations (See
also: SEP-Professional-Ethics, SEP-Context) Illustrative Learning Outcomes: KA
Core: 1\\. Design and implement an application on a given robotic platform. 2\\.
Integrate an Arduino-based robot kit and program it to navigate a maze. 3\\.
Compare robot-specific languages and techniques with those used for general-
purpose software development. 4\\. Explain the rationale behind the design of
the robotic platform and its interconnections with physical or simulated
systems. 5\\. Given a high-level application, design a robot software
architecture using ROS specifying all components and interconnections (ROS
topics) to accomplish that application. 6\\. Discuss the constraints a given
robotic platform imposes on developers."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Specialized_Platform_Development_SPD" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Robot_Platforms.txt> .

"SPD-Society_Ethics_and_the_Profession" ns1:content """Pages : 247-248-249-250 CS Core : None, KA Core : None (This section will be
divided with the SEP area for each platform) SPD-SEP/Mobile Non-core: 1\\.
Privacy and data protection 2\\. Accessibility in mobile design 3\\. Security
and cybersecurity 4\\. Social impacts of mobile technology 5\\. Ethical use of
AI and algorithms Illustrative Learning Outcomes: Non-core: 1\\. Understand and
uphold ethical responsibilities for safeguarding user privacy and data
protection in mobile applications. 2\\. Design mobile applications with
accessibility in mind, ensuring effective use by people with disabilities. 3\\.
Demonstrate proficiency in secure coding practices to mitigate risks
associated with various security threats in mobile development. 4\\. Analyze
the broader social impacts of mobile technology, including its influence on
communication patterns, relationships, and mental health. 5\\. Comprehend the
ethical considerations of using AI in mobile applications, ensuring unbiased
and fair algorithms. SPD-SEP/Web Non-core: 1\\. Privacy concerns with mobile
apps 2\\. Designing for inclusivity and accessibility 3\\. Ethical use of AI in
mobile apps 4\\. Sustainable app development and server hosting 5\\. Avoiding
spam or intrusive notifications 6\\. Addressing cyberbullying and harassment
7\\. Promoting positive online communities 8\\. Monetization and advertising 9\\.
Ethical use of gamification Illustrative Learning Outcomes: Non-core: 1\\.
Understand how mobile computing impacts communications and the flow of
information within society. 2\\. Design mobile apps that have made daily tasks
easier/faster. 3\\. Recognize how the ubiquity of mobile computing has affected
work-life balance. 4\\. Understand how mobile computing impacts health
monitoring and healthcare services. 5\\. Define how mobile apps are used to
educate about and help achieve UN sustainability goals. SPD-SEP/Game Non-core:
1\\. Intellectual Property Rights in Creative Industries a. Intellectual
Property Ownership: copyright, trademark; design right, patent, trade secret,
civil versus criminal law; international agreements; procedural content
generation and the implications of generative artificial intelligence b.
Licensing: Usage and fair usage exceptions; open-source license agreements;
proprietary and bespoke licensing; enforcement 2\\. Fair Access to Play a. Game
Interface Usability: user requirements, affordances, ergonomic design, user
research, experience measurement, and heuristic evaluation methods for games
b. Game Interface Accessibility: forms of impairment and disability; means to
facilitate game access; universal design; legislated requirements for game
platforms; compliance evaluation; challenging game mechanics and access 3\\.
Game-Related Health and Safety a. Injuries in Play: ways of mitigating common
upper body injuries, such as repetitive strain injury; exercise psychology and
physiotherapy in eSports b. Risk Assessment for Events and Manufacturing:
control of substances hazardous to health (COSHH); fire safety; electrical and
electronics safety; risk assessment for games and game events; risk assessment
for manufacturing c. Mental Health: motivation to play; gamification and
gameful design; game psychology -internet gaming disorder 4\\. Platform
Hardware Supply Chain and Sustainability a. Platform Lifecycle: platform
composition - materials, assembly; mineral excavation and processing; power
usage; recycling; planned obsolescence. b. Modern Slavery: supply chains;
forced labor and civil rights; working conditions; detection and remission;
certification bodies and charitable endeavors. 5\\. Representation in the Media
and Industry a. Inclusion: identity and identification; inclusion of a broad
range of characters for diverse audiences; media representation and its
effects; media literacy; content analysis; stereotyping; sexualization b.
Equality: histories and controversies, such as gamergate, quality of life in
the industry, professional discourse and conduct in business contexts,
pathways to game development careers, social mobility, the experience of
developers from different backgrounds and identities, gender, and technology
Illustrative Learning Outcomes: Non-core: 1\\. Discuss how creators can protect
their intellectual property. 2\\. Identify common pitfalls in game interfaces
that exclude players with impaired or non-functional vision. 3\\. Describe how
heuristic evaluation can be used to identify usability problems in game
interfaces. 4\\. Explain why upper body injuries are common in eSports. 5\\.
Discuss how to reform characters and dialogues in a scene to reduce stereotype
threat. 6\\. Illustrate how the portrayal of race in a game can influence the
risk of social exclusion in the associated online community around the game.
7\\. Modify a policy for a LAN party event to include mitigations that lower
the risk of fire. 8\\. Design a gamification strategy to motivate serious play
for an awareness-raising game. 9\\. Analyze the role of company hiring policies
and advocacy on social mobility. 10\\. Assess the appropriateness of two
manufacturers for producing a new game console. 11\\. Compare options for open-
source licensing of a game development tool. 12\\. Recommend changes to a
specific game interface to improve access to players who are deaf or whose
hearing is otherwise impaired. 13\\. Discuss whether games are addictive. 14\\.
Suggest how the portrayal of women in video games influences how players
perceive members of those groups. 15\\. Create a video game that successfully
advocates for climate science. SPD-SEP/Robotics Non-core: 1\\. Fairness,
transparency, and accountability in robotic algorithms 2\\. Mitigating biases
in robot decision-making 3\\. Public safety in shared spaces with robots 4\\.
Compliance with data protection laws 5\\. Patient consent and trust in medical
robots Illustrative Learning Outcomes: Non-core: 1\\. Identify instances of
bias in robotic algorithms and propose strategies to mitigate them. 2\\.
Evaluate and critique robotic systems for ethical and fairness considerations,
suggesting improvements where necessary. 3\\. Analyze real-world examples of
biases in robot decision-making and develop strategies to reduce bias in
robotic systems. 4\\. Assess the potential risks associated with robots in
public spaces and propose safety measures to mitigate those risks. 5\\.
Evaluate the impact of patient consent and trust on the effectiveness of
medical robot deployments in healthcare contexts. SPD-SEP/Interactive Non-
core: 1\\. Ethical guidelines when using AI models to assist in journalism and
content creation 2\\. Accountability for AI-generated outputs 3\\. Behavior
among prompt programmers and AI developers 4\\. Trust with the public when
using AI models Illustrative Learning Outcomes: Non-core: 1\\. Indicate a
framework for accountability in AI model deployment, including clear
documentation and attribution. 2\\. Discuss ethical codes of conduct and
professional standards relevant to prompt programming and AI development. 3\\.
Create communication plans and materials to educate the public about AI
capabilities, limitations, and ethical safeguards."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Specialized_Platform_Development_SPD" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt> .

"SPD-Web_Platforms" ns1:content """Page : 241 CS Core : None, KA Core : 5 (+1) (Additional hours here are hours
shared with other Areas) KA Core: 1\\. Web programming languages (e.g., HTML5,
JavaScript, PHP, CSS) 2\\. Web platforms, frameworks, or meta-frameworks a.
Cloud services b. API, Web Components 3\\. Software as a Service (SaaS) 4\\. Web
standards such as document object model, accessibility (See also: HCI-
Accessibility) 5\\. Security and Privacy Considerations (See also: SEP-
Security) Non-core: 6\\. Analyzing requirements for web applications 7\\.
Computing services (See also: DM-NoSQL) a. Cloud Hosting b. Scalability (e.g.,
Autoscaling, Clusters) c. Cost estimation for services 8\\. Data management
(See also: DM-Core) a. Data residency: where the data is located and what
paths can be taken to access it b. Data integrity: guaranteeing data is
accessible and that data is deleted when required 9\\. Architecture a.
Monoliths vs Microservices b. Micro-frontends c. Event-Driven vs RESTful
architectures: advantages and disadvantages d. Serverless, cloud computing on
demand 10\\. Storage solutions (See also: DM-Relational, DM-NoSQL) a.
Relational Databases b. NoSQL databases Illustrative Learning Outcomes: KA
Core: 1\\. Design and implement a web-based application using a microservice
architecture design. 2\\. Describe the constraints, such as hosting, services,
and scalability, related to web platforms. 3\\. Compare and contrast web
programming with general-purpose programming. 4\\. Describe the differences
between Software-as-a-Service (SaaS) and traditional software products. 5\\.
Discuss how web standards impact software development. 6\\. Evaluate an
existing web application against current web standards."""^^xsd:string ;
    ns1:cs_core_hours "11" ;
    ns1:ka_core_hours "6" ;
    ns1:part_of "Specialized_Platform_Development_SPD" ;
    ns1:path <file:///Users/molli-p/slm-exp/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Web_Platforms.txt> .

