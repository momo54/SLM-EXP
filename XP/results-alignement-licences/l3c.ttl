@prefix ns1: <http://provo.org/> .
@prefix ns2: <http://align.org/> .
@prefix ns3: <http://example.org/course/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

ns3:UE_X31A060 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns2:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns2:score "0.63870883"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on scientific communication in English, while the KU covers programming language design principles." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.64577204"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on communication skills in English for scientific purposes, whereas the KU covers Natural Language Processing topics, such as grammars, parsing, semantics, and machine learning." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.64577204"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on scientific communication in English, while the KU covers technical NLP topics." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns2:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns2:score "0.63870883"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on communication skills in English for scientific purposes, whereas the KU discusses design principles of programming languages, which are unrelated topics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.64577204"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on scientific communication in English, while the KU covers technical NLP topics." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.64215916"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on English communication skills for scientists, while the KU covers programming language design and inclusivity, with no direct overlap." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.64215916"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics related to scientific communication, vocabulary development, and presentation skills, which align with the knowledge unit's focus on programming languages, accessibility, and inclusivity." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.64577204"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on scientific communication skills, while the KU covers technical NLP concepts like parsing algorithms and machine learning models, which are not addressed in the lecture." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.64577204"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on communication skills in English for scientific purposes, whereas the KU covers Natural Language Processing topics, such as grammars, parsing, semantics, and machine learning." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.64215916"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on English communication skills for scientists, while the KU covers programming language design and inclusivity, with no direct overlap." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.64215916"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap; KU focuses on programming accessibility/design while lecture teaches scientific English communication" ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns2:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns2:score "0.63870883"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on communication skills in English for scientific purposes, whereas the KU discusses design principles of programming languages, which are unrelated topics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns2:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns2:score "0.63870883"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap; lecture focuses on scientific English communication skills, while KU addresses programming language design principles." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.64215916"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics related to scientific communication, vocabulary development, and presentation skills, which align with the knowledge unit's focus on programming languages, accessibility, and inclusivity." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.64215916"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap; KU focuses on programming accessibility/design while lecture teaches scientific English communication" ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.64577204"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on scientific communication skills, while the KU covers technical NLP concepts like parsing algorithms and machine learning models, which are not addressed in the lecture." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns2:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns2:score "0.63870883"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap; lecture focuses on scientific English communication skills, while KU addresses programming language design principles." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns2:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns2:score "0.63870883"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on scientific communication in English, while the KU covers programming language design principles." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ] ;
    ns2:uetext """Label: Anglais pour la communication scientifique (info) Objectif: (résultats d'apprentissage)
replacer l’article dans son contexte et expliquer les enjeux de la recherche ou de la thématique
abordée dans cet article.
3. présenter son travail dans un anglais clair et phonologiquement approprié, en utilisant des outils
de présentation adaptés et en communiquant avec un degré d’aisance et de spontanéité qui rende
possible une interaction normale avec un locuteur natif, sans recours excessif aux notes.
1. Développement du vocabulaire scientifique général
2. Développement du vocabulaire scientifique de spécialité
3. Analyse de textes scientifiques
4. Développement de la capacité à adapter son discours à différentes situations de communication Course content: scientifique
4. Analyse de documents audio ou vidéo
5. Pratique de l’oral en contexte
6. Sensibilisation au système phonologique de l’anglais pour améliorer la prise de parole des
étudiant-e-s Course name: http://example.org/course/UE_X31A060""" .

ns3:UE_X31I010 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7138155"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on algorithm verification/complexity, while KU emphasizes logic programming fundamentals (unification, Horn clauses, etc.) not directly covered." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.70884264"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on algorithm verification/complexity proofs, while KU emphasizes algorithm concepts, common examples, and performance impacts." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.70884264"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the objectives of writing formal reductions, choosing properties to prove an algorithm's complexity, and writing proofs of correction and complexity, which aligns with the KU's learning outcomes." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.70884264"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on algorithm verification/complexity proofs, while KU emphasizes algorithm concepts, common examples, and performance impacts." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.6867994"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including formal automata, formal languages, and algorithmic correctness, but does not delve into quantum computation." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7138155"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on algorithm verification and complexity, while the KU covers logic programming concepts." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.6867994"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on algorithm verification and correctness, lacking substantial coverage of formal automata, languages, and computability topics in the KU." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7138155"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics such as algorithm verification, program verification, and logic programming, which are all relevant to the Knowledge Unit." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7138155"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on algorithm verification and complexity, while the KU covers logic programming concepts." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7138155"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics such as algorithm verification, program verification, and logic programming, which are all relevant to the Knowledge Unit." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.6867994"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on algorithm verification and correctness, lacking substantial coverage of formal automata, languages, and computability topics in the KU." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.70884264"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on formal verification and complexity proofs, lacking coverage of common algorithms and their practical efficiency impacts." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.6867994"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on algorithm analysis/proofs, while KU requires extensive automata theory, formal languages, and undecidability proofs not fully covered." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.70884264"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the objectives of writing formal reductions, choosing properties to prove an algorithm's complexity, and writing proofs of correction and complexity, which aligns with the KU's learning outcomes." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7138155"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on algorithm verification/complexity, while KU emphasizes logic programming fundamentals (unification, Horn clauses, etc.) not directly covered." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.70884264"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on formal verification and complexity proofs, lacking coverage of common algorithms and their practical efficiency impacts." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.6867994"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on algorithm analysis/proofs, while KU requires extensive automata theory, formal languages, and undecidability proofs not fully covered." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.6867994"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including formal automata, formal languages, and algorithmic correctness, but does not delve into quantum computation." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ] ;
    ns2:uetext """Label: Etude des algorithmes Objectif: (résultats d'apprentissage) - Être capable d'écrire formellement des réductions, simples, de NP-complétude
- Savoir choisir des propriétés à vérifier pour prouver un algorithme et pour établir sa complexité
temporelle
- Savoir écrire, pour des algorithmes simples, des preuves de correction et des preuves de
complexité temporelle
- Être capable de travailler en groupe Course content: Vérification de programme
• Vérification dynamiques : aléatoire ; fonctionnelle ; structurelle
• Vérification statique : informelle ; formelle (Hoare et Dijkstra) : correction, terminaison. Course name: http://example.org/course/UE_X31I010""" .

ns3:UE_X31I020 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.7006189"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers tree traversal, graph theory, algorithm complexity, and data structure selection, which are central to the KU's focus on algorithms and their efficiency." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6989193"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics such as algorithm implementation, graph theory, and data structures, which align with the knowledge unit's objectives and learning outcomes." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns2:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns2:score "0.6974218"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on tree data structures and graph theory, while the KU covers a broader range of topics including sets, relations, functions, recursive definitions, proof techniques, permutations, combinations, counting, modular arithmetic, and logic. The lecture does not substantially cover the full scope of the KU." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.7006189"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge unit's topics, including algorithm implementation, problem-solving, and complexity calculation." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6989193"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on data structures and algorithms, while the KU covers logic programming, with no overlap." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.7006189"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge unit's topics, including algorithm implementation, problem-solving, and complexity calculation." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns2:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns2:score "0.6974218"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on algorithms/data structures (trees/graphs), while KU covers broader discrete math topics (proofs, logic, counting) not substantially addressed." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns2:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns2:score "0.6974218"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as algorithm implementation, graph theory, and mathematical concepts like sets, relations, and functions." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.7006189"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers algorithms, complexity, and data structure efficiency (tree/graph traversal, greedy approaches, and performance analysis)." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns2:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns2:score "0.6974218"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as algorithm implementation, graph theory, and mathematical concepts like sets, relations, and functions." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6989193"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on data structures/algorithms, while KU covers logic programming concepts (unification, predicate logic) not addressed." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6989193"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on data structures and algorithms, while the KU covers logic programming, with no overlap." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns2:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns2:score "0.6974218"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on algorithms/data structures (trees/graphs), while KU covers broader discrete math topics (proofs, logic, counting) not substantially addressed." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.7006189"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers algorithms, complexity, and data structure efficiency (tree/graph traversal, greedy approaches, and performance analysis)." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt> ;
            ns2:ku_text """Page : 170 CS Core : 6, KA Core : None CS Core: (See also: AL-Foundational,
AL-Complexity) 1\\. Concept of algorithm and notion of algorithm efficiency 2\\.
Some common algorithms (e.g., sorting, searching, tree traversal, graph
traversal) 3\\. Impact of algorithms on time-space efficiency of programs
Illustrative Learning Outcomes: CS Core: 1\\. Explain the role of algorithms
for writing programs. 2\\. Demonstrate how a problem may be solved by different
algorithms, each with different properties. 3\\. Explain some common algorithms
(e.g., sorting, searching, tree traversal, graph traversal). 4\\. Explain the
impact on space/time performance of some algorithms."""^^xsd:string ;
            ns2:score "0.7006189"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers tree traversal, graph theory, algorithm complexity, and data structure selection, which are central to the KU's focus on algorithms and their efficiency." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Algorithms" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns2:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns2:score "0.6974218"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on tree data structures and graph theory, while the KU covers a broader range of topics including sets, relations, functions, recursive definitions, proof techniques, permutations, combinations, counting, modular arithmetic, and logic. The lecture does not substantially cover the full scope of the KU." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6989193"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics such as algorithm implementation, graph theory, and data structures, which align with the knowledge unit's objectives and learning outcomes." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6989193"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on data structures/algorithms, while KU covers logic programming concepts (unification, predicate logic) not addressed." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ] ;
    ns2:uetext """Label: Algorithmique et Structures de données 3 Objectif: (résultats d'apprentissage) •
implémenter des algorithmes de parcours et de manipulation d’arbres (Application) ;
•
résoudre des problèmes simples de la théorie des graphes en employant une approche gloutonne
lorsqu’elle est appropriée (Analyse) ;
•
calculer la complexité d'un algorithme en fonction des structures de données choisies (Synthèse) ;
• choisir la structure de données la plus efficace pour la résolution d'un problème (Synthèse) ; Course content: Structures de données arborescentes
o monodimensionnelles : arbres binaires, arbres AVL, classes-union etc. Course name: http://example.org/course/UE_X31I020""" .

ns3:UE_X31I030 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.6711116"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some related concepts like regular expressions but does not substantially address the broader scripting and system interaction topics of the KU." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.7020704"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including formal automata, formal languages, and grammars, as well as decidability, computability, and halting. The lecture also touches on algorithmic correctness, determinism, and nondeterminism." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.6711116"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics such as automates and transducteurs, which align with the KU's focus on scripting and system tasks." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns2:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns2:score "0.6712515"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on automata/grammars, while KU covers formal semantics, type systems, and proofs." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Formalism_Formal_Semantics" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.7020704"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including formal automata, formal languages, and grammars, as well as decidability, computability, and halting. The lecture also touches on algorithmic correctness, determinism, and nondeterminism." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.6711116"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap beyond basic regex theory; KU focuses on scripting/practical tasks not covered" ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.7020704"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture covers basic automata topics but lacks coverage of decidability, undecidability proofs, and advanced computability theory required by KU." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.7020704"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some aspects of formal automata and grammars but does not address the full scope of the KU, particularly missing key topics like Turing machines, decidability, and the Church-Turing thesis." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.6711116"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap beyond basic regex theory; KU focuses on scripting/practical tasks not covered" ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns2:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns2:score "0.6712515"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics such as formal semantics, automates, and transducteurs, which align with the knowledge unit's objectives and learning outcomes." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Formalism_Formal_Semantics" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns2:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns2:score "0.6712515"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on formal language theory and automata, while the KU covers formal semantics and type systems, which are distinct areas." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Formalism_Formal_Semantics" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.7020704"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture covers basic automata topics but lacks coverage of decidability, undecidability proofs, and advanced computability theory required by KU." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.6711116"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some related concepts like regular expressions but does not substantially address the broader scripting and system interaction topics of the KU." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns2:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns2:score "0.6712515"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics such as formal semantics, automates, and transducteurs, which align with the knowledge unit's objectives and learning outcomes." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Formalism_Formal_Semantics" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns2:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns2:score "0.6712515"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on automata/grammars, while KU covers formal semantics, type systems, and proofs." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Formalism_Formal_Semantics" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.6711116"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics such as automates and transducteurs, which align with the KU's focus on scripting and system tasks." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt> ;
            ns2:ku_text """Pages:93-95 HOURS CS Core = 9 KA Core = 23 AL-Models: Computational Models and
Formal Languages CS Core: 1\\. Formal automata a. Finite State b. Pushdown c.
Linear Bounded d. Turing Machine 2\\. Formal languages, grammars and Chomsky
Hierarchy (See also: FPL-Translation, FPL-Syntax) a. Regular (Type-3) i.
Regular Expressions b. Context-Free (Type-2) c. Context-Sensitive (Type-1) d.
Recursively Enumerable (Type-0) 3\\. Relations among formal automata,
languages, and grammars 4\\. Decidability, (un)computability, and halting 5\\.
The Church-Turing thesis 6\\. Algorithmic correctness a. Invariants (e.g., in
iteration, recursion, tree search) KA Core: 7\\. Deterministic and
nondeterministic automata 8\\. Pumping Lemma proofs a. Proof of Finite
State/Regular-Language limitation b. Pushdown Automata/Context-Free-Language
limitation 9\\. Decidability a. Arithmetization and diagonalization 10\\.
Reducibility and reductions 11\\. Time complexity based on Turing Machine 12\\.
Space complexity (e.g., Pspace, Savitch's Theorem) 13\\. Equivalent models of
algorithmic computation a. Turing Machines and Variations (e.g., multi-tape,
non-deterministic) b. Lambda Calculus (See also: FPL-Functional) c. Mu-
Recursive Functions Non-core: 14\\. Quantum computation (See also: AR-Quantum)
a. Postulates of quantum mechanics i. State space 94 ii. State evolution iii.
State composition iv. State measurement b. Column vector representations of
qubits c. Matrix representations of quantum operations d. Simple quantum gates
(e.g., XNOT, CNOT) Illustrative Learning Outcomes: CS Core: 1\\. For each
formal automaton in this unit: a. Explain its definition comparing its
characteristics with this unit's other automata, b. Using an example, explain
step-by-step how the automaton operates on input including whether it accepts
the associated input, c. Explain an example of inputs that can and cannot be
accepted by the automaton. 2\\. Given a problem, develop an appropriate
automaton that addresses the problem. 3\\. Develop a regular expression for a
given regular language expressed in natural language. 4\\. Explain the
difference between regular expressions (Type-3 acceptors) and the regular
expressions (Type-2 acceptors) used in programming languages. 5\\. For each
formal model in this unit: a. Explain its definition comparing its
characteristics with the others in this unit, b. Explain example inputs that
are and cannot be accepted by the language/grammar. 6\\. Explain a universal
Turing Machine and its operation. 7\\. Present to an audience of co-workers and
managers the impossibility of providing them a program that checks all other
programs, including some seemingly simple ones, for infinite loops including
an explanation of the Halting problem, why it has no algorithmic solution, and
its significance for real-world algorithmic computation. 8\\. Explain examples
of classic uncomputable problems. 9\\. Explain the Church-Turing Thesis and its
significance for algorithmic computation. 10\\. Explain how (loop) invariants
can be used to prove the correctness of an algorithm. Illustrative Learning
Outcomes: KA Core: 11\\. For each formal automaton in this unit explain
(compare/contrast) its deterministic and nondeterministic capabilities. 12\\.
Apply pumping lemmas, or alternative means, to prove the limitations of Finite
State and Pushdown automata. 13\\. Apply arithmetization and diagonalization to
prove the Halting Problem for Turing Machines is Undecidability. 14\\. Given a
known undecidable language, apply a mapping reduction or computational history
to prove that another language is undecidable. 15\\. Convert among equivalently
powerful notations for a language, including among DFAs, NFAs, and regular
expressions, and between PDAs and CFGs. 16\\. Explain Rice's theorem and its
significance. 95 17\\. Explain an example proof of a problem that is
uncomputable by reducing a classic known uncomputable problem to it. 18\\.
Explain the Primitive and General Recursive functions (zero, successor,
selection, primitive recursion, composition, and Mu), their significance, and
Turing Machine implementations. 19\\. Explain how computation is performed in
Lambda Calculus (e.g., Alpha conversion and Beta reduction) Non-core: 20\\. For
a quantum system give examples that explain the following postulates. a. State
Space - system state represented as a unit vector in Hilbert space, b. State
Evolution - the use of unitary operators to evolve system state, c. State
Composition - the use of tensor product to compose systems states, d. State
Measurement - the probabilistic output of measuring a system state. 21\\.
Explain the operation of a quantum XNOT or CNOT gate on a quantum bit
represented as a matrix and column vector, respectively"""^^xsd:string ;
            ns2:score "0.7020704"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some aspects of formal automata and grammars but does not address the full scope of the KU, particularly missing key topics like Turing machines, decidability, and the Church-Turing thesis." ;
            ns3:ka "Algorithmic_Foundations_AL" ;
            ns3:ku "AL-Models_Computational_Models_and_Formal_Languages" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns2:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns2:score "0.6712515"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on formal language theory and automata, while the KU covers formal semantics and type systems, which are distinct areas." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Formalism_Formal_Semantics" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ] ;
    ns2:uetext """Label: Langage et automates Objectif: (résultats d'apprentissage)
- Savoir si un mot est engendré par une grammaire rationnelle, algébrique ou contextuelle
- Connaître les propriétés d'un automate fini
- Savoir rendre déterministe un automate fini
- Savoir minimaliser le nombre d'états d'un automate fini déterministe
- Savoir si un mot est accepté par un automate fini
- Savoir transformer une grammaire rationnelle en une expression rationnelle ou en un automate
fini et inversement Course content: formes normales. Automates à pile et transducteurs finis. Course name: http://example.org/course/UE_X31I030""" .

ns3:UE_X31I040 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.6764391"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental concepts of networking, including the organization of the internet, switching techniques, layers, and network elements, which aligns with the KU's Fundamentals section." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.72909"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers protocols (HTTP/TCP/IP), layers, and core network concepts but lacks explicit details on switching techniques and queueing models." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Applications_Networked_Applications.txt> ;
            ns2:ku_text """Pages: 199 HOURS CS Core = 3.5 + 0.25 (SEP) + 0.25 (PDC) KA Core = . NC-
Applications: Networked Applications CS Core: 1\\. Naming and address schemes
(e.g., DNS, and Uniform Resource Identifiers) 2\\. Distributed application
paradigms (e.g., client/server, peer-to-peer, cloud, edge, and fog) (See also:
PDC-Communication, PDC-Coordination) 3\\. Diversity of networked application
demands (e.g., latency, bandwidth, and loss tolerance) (See also: PDC-
Communication, SEP-Sustainability, SEP-Context) 4\\. Coverage of application-
layer protocols (e.g., HTTP) 5\\. Interactions with TCP, UDP, and Socket APIs
(See also: PDC-Programs) Illustrative Learning Outcomes: CS Core: 1\\. Define
the principles of naming, addressing, resource location. 2\\. Analyze the needs
of specific networked application demands. 3\\. Describe the details of one
application layer protocol. 4\\. Implement a simple client-server socket-based
application."""^^xsd:string ;
            ns2:score "0.6934676"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental protocols of the Internet, including HTTP, TCP, IP, and ARP, which aligns with the KU's focus on naming and address schemes, distributed application paradigms, and application-layer protocols." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Applications_Networked_Applications" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Applications_Networked_Applications.txt> ;
            ns2:ku_text """Pages: 199 HOURS CS Core = 3.5 + 0.25 (SEP) + 0.25 (PDC) KA Core = . NC-
Applications: Networked Applications CS Core: 1\\. Naming and address schemes
(e.g., DNS, and Uniform Resource Identifiers) 2\\. Distributed application
paradigms (e.g., client/server, peer-to-peer, cloud, edge, and fog) (See also:
PDC-Communication, PDC-Coordination) 3\\. Diversity of networked application
demands (e.g., latency, bandwidth, and loss tolerance) (See also: PDC-
Communication, SEP-Sustainability, SEP-Context) 4\\. Coverage of application-
layer protocols (e.g., HTTP) 5\\. Interactions with TCP, UDP, and Socket APIs
(See also: PDC-Programs) Illustrative Learning Outcomes: CS Core: 1\\. Define
the principles of naming, addressing, resource location. 2\\. Analyze the needs
of specific networked application demands. 3\\. Describe the details of one
application layer protocol. 4\\. Implement a simple client-server socket-based
application."""^^xsd:string ;
            ns2:score "0.6934676"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental protocols of the Internet, including HTTP, TCP, IP, and ARP, which aligns with the KU's focus on naming and address schemes, distributed application paradigms, and application-layer protocols." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Applications_Networked_Applications" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.72909"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some aspects of the KU but lacks coverage of the internet's organizational structure, switching techniques, and certain network elements." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.72909"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental concepts of networking, including the organization of the internet, switching techniques, layers, and network elements, which aligns with the KU's Fundamentals section." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.6764391"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some aspects of the KU but lacks coverage of the internet's organizational structure, switching techniques, and certain network elements." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.72909"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers protocols (HTTP/TCP/IP), layers, and core network concepts but lacks explicit details on switching techniques and queueing models." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.6764391"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some aspects of the KU but lacks coverage of the internet's organizational structure, switching techniques, and certain network elements." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Applications_Networked_Applications.txt> ;
            ns2:ku_text """Pages: 199 HOURS CS Core = 3.5 + 0.25 (SEP) + 0.25 (PDC) KA Core = . NC-
Applications: Networked Applications CS Core: 1\\. Naming and address schemes
(e.g., DNS, and Uniform Resource Identifiers) 2\\. Distributed application
paradigms (e.g., client/server, peer-to-peer, cloud, edge, and fog) (See also:
PDC-Communication, PDC-Coordination) 3\\. Diversity of networked application
demands (e.g., latency, bandwidth, and loss tolerance) (See also: PDC-
Communication, SEP-Sustainability, SEP-Context) 4\\. Coverage of application-
layer protocols (e.g., HTTP) 5\\. Interactions with TCP, UDP, and Socket APIs
(See also: PDC-Programs) Illustrative Learning Outcomes: CS Core: 1\\. Define
the principles of naming, addressing, resource location. 2\\. Analyze the needs
of specific networked application demands. 3\\. Describe the details of one
application layer protocol. 4\\. Implement a simple client-server socket-based
application."""^^xsd:string ;
            ns2:score "0.6934676"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers DNS, HTTP, TCP protocols and their roles, aligning with KU's naming, application-layer, and TCP interaction topics." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Applications_Networked_Applications" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.6764391"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers protocols (HTTP/TCP/IP), layers, and core network concepts but lacks explicit details on switching techniques and queueing models." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.72909"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some aspects of the KU but lacks coverage of the internet's organizational structure, switching techniques, and certain network elements." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.6764391"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers protocols (HTTP/TCP/IP), layers, and core network concepts but lacks explicit details on switching techniques and queueing models." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Applications_Networked_Applications.txt> ;
            ns2:ku_text """Pages: 199 HOURS CS Core = 3.5 + 0.25 (SEP) + 0.25 (PDC) KA Core = . NC-
Applications: Networked Applications CS Core: 1\\. Naming and address schemes
(e.g., DNS, and Uniform Resource Identifiers) 2\\. Distributed application
paradigms (e.g., client/server, peer-to-peer, cloud, edge, and fog) (See also:
PDC-Communication, PDC-Coordination) 3\\. Diversity of networked application
demands (e.g., latency, bandwidth, and loss tolerance) (See also: PDC-
Communication, SEP-Sustainability, SEP-Context) 4\\. Coverage of application-
layer protocols (e.g., HTTP) 5\\. Interactions with TCP, UDP, and Socket APIs
(See also: PDC-Programs) Illustrative Learning Outcomes: CS Core: 1\\. Define
the principles of naming, addressing, resource location. 2\\. Analyze the needs
of specific networked application demands. 3\\. Describe the details of one
application layer protocol. 4\\. Implement a simple client-server socket-based
application."""^^xsd:string ;
            ns2:score "0.6934676"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some aspects like HTTP and TCP, but misses key areas such as distributed paradigms and socket implementation." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Applications_Networked_Applications" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.6764391"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental concepts of networking, including the organization of the internet, switching techniques, layers, and network elements, which aligns with the KU's Fundamentals section." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Applications_Networked_Applications.txt> ;
            ns2:ku_text """Pages: 199 HOURS CS Core = 3.5 + 0.25 (SEP) + 0.25 (PDC) KA Core = . NC-
Applications: Networked Applications CS Core: 1\\. Naming and address schemes
(e.g., DNS, and Uniform Resource Identifiers) 2\\. Distributed application
paradigms (e.g., client/server, peer-to-peer, cloud, edge, and fog) (See also:
PDC-Communication, PDC-Coordination) 3\\. Diversity of networked application
demands (e.g., latency, bandwidth, and loss tolerance) (See also: PDC-
Communication, SEP-Sustainability, SEP-Context) 4\\. Coverage of application-
layer protocols (e.g., HTTP) 5\\. Interactions with TCP, UDP, and Socket APIs
(See also: PDC-Programs) Illustrative Learning Outcomes: CS Core: 1\\. Define
the principles of naming, addressing, resource location. 2\\. Analyze the needs
of specific networked application demands. 3\\. Describe the details of one
application layer protocol. 4\\. Implement a simple client-server socket-based
application."""^^xsd:string ;
            ns2:score "0.6934676"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some aspects like HTTP and TCP, but misses key areas such as distributed paradigms and socket implementation." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Applications_Networked_Applications" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Applications_Networked_Applications.txt> ;
            ns2:ku_text """Pages: 199 HOURS CS Core = 3.5 + 0.25 (SEP) + 0.25 (PDC) KA Core = . NC-
Applications: Networked Applications CS Core: 1\\. Naming and address schemes
(e.g., DNS, and Uniform Resource Identifiers) 2\\. Distributed application
paradigms (e.g., client/server, peer-to-peer, cloud, edge, and fog) (See also:
PDC-Communication, PDC-Coordination) 3\\. Diversity of networked application
demands (e.g., latency, bandwidth, and loss tolerance) (See also: PDC-
Communication, SEP-Sustainability, SEP-Context) 4\\. Coverage of application-
layer protocols (e.g., HTTP) 5\\. Interactions with TCP, UDP, and Socket APIs
(See also: PDC-Programs) Illustrative Learning Outcomes: CS Core: 1\\. Define
the principles of naming, addressing, resource location. 2\\. Analyze the needs
of specific networked application demands. 3\\. Describe the details of one
application layer protocol. 4\\. Implement a simple client-server socket-based
application."""^^xsd:string ;
            ns2:score "0.6934676"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers DNS, HTTP, TCP protocols and their roles, aligning with KU's naming, application-layer, and TCP interaction topics." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Applications_Networked_Applications" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt> ;
            ns2:ku_text """Pages: 198-199 HOURS CS Core = 2.5 + 0.25 (SEP) + 0.25 (SF) KA Core = . NC-
Fundamentals: Fundamentals CS Core: 1\\. Importance of networking in
contemporary computing, and associated challenges. (See also: SEPContext, SEP-
Privacy) 2\\. Organization of the internet (e.g., users, Internet Service
Providers, autonomous systems, content providers, content delivery networks)
3\\. Switching techniques (e.g., circuit and packet) 4\\. Layers and their roles
(application, transport, network, datalink, and physical) 5\\. Layering
principles (e.g., encapsulation and hourglass model) (See also: SF-
Foundations) 6\\. Network elements (e.g., routers, switches, hubs, access
points, and hosts) 7\\. Basic queueing concepts (e.g., relationship with
latency, congestion, service levels, etc.) Illustrative Learning Outcomes: CS
Core: 1\\. Articulate the organization of the internet. 2\\. List and define the
appropriate network terminology 3\\. Describe the layered structure of a
typical networked architecture. 4\\. Identify the different types of complexity
in a network (edges, core, etc.)."""^^xsd:string ;
            ns2:score "0.72909"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental concepts of networking, including the organization of the internet, switching techniques, layers, and network elements, which aligns with the KU's Fundamentals section." ;
            ns3:ka "Networking_and_Communication_NC" ;
            ns3:ku "NC-Fundamentals_Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ] ;
    ns2:uetext """Label: Réseaux et Télécoms Objectif: (résultats d'apprentissage)
• Comprendre les mécanismes de base des protocoles de l’Internet (http, tcp, ip, arp);
• Connaître les défis techniques et sociétaux liés aux déploiements des réseaux; Course content: de l'UE : Internet : comment ça marche.
• Introduction : les chiffres de l'Internet, histoire et perspectives.
• Les protocoles applicatifs (http, smtp, dns, ...)
• Le problème du transport fiable de bout en bout. TCP.
• Le problème du contrôle de flux et congestion. TCP. Course name: http://example.org/course/UE_X31I040""" .

ns3:UE_X31I050 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt> ;
            ns2:ku_text """Pages : 230-231 CS Core : 3, KA Core : 0 CS Core: 1\\. Basic building blocks
and components of a computer (gates, flip-flops, registers, interconnections;
datapath + control + memory) 2\\. Hardware as a computational paradigm:
Fundamental logic building blocks; Logic expressions, minimization, sum of
product forms (See also: AR-Logic) 3\\. Programming abstractions, interfaces,
use of libraries (See also: PDC-Programs) 4\\. Distinction and interaction
between application and OS services, remote procedure call (See also: OS-
Purpose) 5\\. Basic concept of pipelining, overlapped processing stages (See
also: AR-Organization) 6\\. Basic concept of scaling: performance vs problem
size Illustrative Learning Outcomes: CS Core: 1\\. Describe the basic building
blocks of computers and their role in the historical development of computer
architecture. 2\\. Design a simple logic circuit using the fundamental building
blocks of logic design to solve a simple problem (e.g., adder). 3\\. Describe
how computing systems are constructed of layers upon layers, based on
separation of concerns, with well-defined interfaces, hiding details of low
layers from the higher layers. 4\\. Describe that hardware, OS, VM, and
application are additional layers of interpretation/processing. 5\\. Describe
the mechanisms of how errors are detected, signaled back, and handled through
the layers. 6\\. Construct a simple program (e.g., a TCP client/server) using
methods of layering, error detection and recovery, and reflection of error
status across layers. 7\\. Identify bugs in a layered program by using tools
for program tracing, single stepping, and debugging. 8\\. Understand the
concept of strong vs weak scaling, i.e., how performance is affected by the
scale of the problem vs the scale of resources to solve the problem. This can
be motivated by simple, real-world examples."""^^xsd:string ;
            ns2:score "0.68781894"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some aspects like datapath and pipelining but lacks detailed coverage of logic design, layered systems, error handling, and scaling concepts." ;
            ns3:ka "System_Fundamentals_SF" ;
            ns3:ku "SF-Overview_of_Computer_Systems" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt> ;
            ns2:ku_text """Pages : 230-231 CS Core : 3, KA Core : 0 CS Core: 1\\. Basic building blocks
and components of a computer (gates, flip-flops, registers, interconnections;
datapath + control + memory) 2\\. Hardware as a computational paradigm:
Fundamental logic building blocks; Logic expressions, minimization, sum of
product forms (See also: AR-Logic) 3\\. Programming abstractions, interfaces,
use of libraries (See also: PDC-Programs) 4\\. Distinction and interaction
between application and OS services, remote procedure call (See also: OS-
Purpose) 5\\. Basic concept of pipelining, overlapped processing stages (See
also: AR-Organization) 6\\. Basic concept of scaling: performance vs problem
size Illustrative Learning Outcomes: CS Core: 1\\. Describe the basic building
blocks of computers and their role in the historical development of computer
architecture. 2\\. Design a simple logic circuit using the fundamental building
blocks of logic design to solve a simple problem (e.g., adder). 3\\. Describe
how computing systems are constructed of layers upon layers, based on
separation of concerns, with well-defined interfaces, hiding details of low
layers from the higher layers. 4\\. Describe that hardware, OS, VM, and
application are additional layers of interpretation/processing. 5\\. Describe
the mechanisms of how errors are detected, signaled back, and handled through
the layers. 6\\. Construct a simple program (e.g., a TCP client/server) using
methods of layering, error detection and recovery, and reflection of error
status across layers. 7\\. Identify bugs in a layered program by using tools
for program tracing, single stepping, and debugging. 8\\. Understand the
concept of strong vs weak scaling, i.e., how performance is affected by the
scale of the problem vs the scale of resources to solve the problem. This can
be motivated by simple, real-world examples."""^^xsd:string ;
            ns2:score "0.68781894"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers logic components, assembly, pipelining, and cache but lacks OS layer details and scaling concepts." ;
            ns3:ka "System_Fundamentals_SF" ;
            ns3:ku "SF-Overview_of_Computer_Systems" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.70315826"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including architecture, programming, and memory organization, with some overlap in topics." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.70315826"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most KU topics but lacks depth in Flynn taxonomy and detailed ISA comparisons." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt> ;
            ns2:ku_text """Pages : 230-231 CS Core : 3, KA Core : 0 CS Core: 1\\. Basic building blocks
and components of a computer (gates, flip-flops, registers, interconnections;
datapath + control + memory) 2\\. Hardware as a computational paradigm:
Fundamental logic building blocks; Logic expressions, minimization, sum of
product forms (See also: AR-Logic) 3\\. Programming abstractions, interfaces,
use of libraries (See also: PDC-Programs) 4\\. Distinction and interaction
between application and OS services, remote procedure call (See also: OS-
Purpose) 5\\. Basic concept of pipelining, overlapped processing stages (See
also: AR-Organization) 6\\. Basic concept of scaling: performance vs problem
size Illustrative Learning Outcomes: CS Core: 1\\. Describe the basic building
blocks of computers and their role in the historical development of computer
architecture. 2\\. Design a simple logic circuit using the fundamental building
blocks of logic design to solve a simple problem (e.g., adder). 3\\. Describe
how computing systems are constructed of layers upon layers, based on
separation of concerns, with well-defined interfaces, hiding details of low
layers from the higher layers. 4\\. Describe that hardware, OS, VM, and
application are additional layers of interpretation/processing. 5\\. Describe
the mechanisms of how errors are detected, signaled back, and handled through
the layers. 6\\. Construct a simple program (e.g., a TCP client/server) using
methods of layering, error detection and recovery, and reflection of error
status across layers. 7\\. Identify bugs in a layered program by using tools
for program tracing, single stepping, and debugging. 8\\. Understand the
concept of strong vs weak scaling, i.e., how performance is affected by the
scale of the problem vs the scale of resources to solve the problem. This can
be motivated by simple, real-world examples."""^^xsd:string ;
            ns2:score "0.68781894"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental building blocks of computers, programming abstractions, and pipelining, which are all key concepts in the KU." ;
            ns3:ka "System_Fundamentals_SF" ;
            ns3:ku "SF-Overview_of_Computer_Systems" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.70315826"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including architecture, programming, and memory organization, with some overlap in topics." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.700032"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most KU topics but lacks depth in Flynn taxonomy and detailed ISA comparisons." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.700032"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including architecture, programming, and memory organization, with some overlap in topics." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.70315826"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers ISA, assembly, processor architectures, and memory/cache, aligning with KA/CS Core topics." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt> ;
            ns2:ku_text """Pages : 230-231 CS Core : 3, KA Core : 0 CS Core: 1\\. Basic building blocks
and components of a computer (gates, flip-flops, registers, interconnections;
datapath + control + memory) 2\\. Hardware as a computational paradigm:
Fundamental logic building blocks; Logic expressions, minimization, sum of
product forms (See also: AR-Logic) 3\\. Programming abstractions, interfaces,
use of libraries (See also: PDC-Programs) 4\\. Distinction and interaction
between application and OS services, remote procedure call (See also: OS-
Purpose) 5\\. Basic concept of pipelining, overlapped processing stages (See
also: AR-Organization) 6\\. Basic concept of scaling: performance vs problem
size Illustrative Learning Outcomes: CS Core: 1\\. Describe the basic building
blocks of computers and their role in the historical development of computer
architecture. 2\\. Design a simple logic circuit using the fundamental building
blocks of logic design to solve a simple problem (e.g., adder). 3\\. Describe
how computing systems are constructed of layers upon layers, based on
separation of concerns, with well-defined interfaces, hiding details of low
layers from the higher layers. 4\\. Describe that hardware, OS, VM, and
application are additional layers of interpretation/processing. 5\\. Describe
the mechanisms of how errors are detected, signaled back, and handled through
the layers. 6\\. Construct a simple program (e.g., a TCP client/server) using
methods of layering, error detection and recovery, and reflection of error
status across layers. 7\\. Identify bugs in a layered program by using tools
for program tracing, single stepping, and debugging. 8\\. Understand the
concept of strong vs weak scaling, i.e., how performance is affected by the
scale of the problem vs the scale of resources to solve the problem. This can
be motivated by simple, real-world examples."""^^xsd:string ;
            ns2:score "0.68781894"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental building blocks of computers, programming abstractions, and pipelining, which are all key concepts in the KU." ;
            ns3:ka "System_Fundamentals_SF" ;
            ns3:ku "SF-Overview_of_Computer_Systems" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt> ;
            ns2:ku_text """Pages : 230-231 CS Core : 3, KA Core : 0 CS Core: 1\\. Basic building blocks
and components of a computer (gates, flip-flops, registers, interconnections;
datapath + control + memory) 2\\. Hardware as a computational paradigm:
Fundamental logic building blocks; Logic expressions, minimization, sum of
product forms (See also: AR-Logic) 3\\. Programming abstractions, interfaces,
use of libraries (See also: PDC-Programs) 4\\. Distinction and interaction
between application and OS services, remote procedure call (See also: OS-
Purpose) 5\\. Basic concept of pipelining, overlapped processing stages (See
also: AR-Organization) 6\\. Basic concept of scaling: performance vs problem
size Illustrative Learning Outcomes: CS Core: 1\\. Describe the basic building
blocks of computers and their role in the historical development of computer
architecture. 2\\. Design a simple logic circuit using the fundamental building
blocks of logic design to solve a simple problem (e.g., adder). 3\\. Describe
how computing systems are constructed of layers upon layers, based on
separation of concerns, with well-defined interfaces, hiding details of low
layers from the higher layers. 4\\. Describe that hardware, OS, VM, and
application are additional layers of interpretation/processing. 5\\. Describe
the mechanisms of how errors are detected, signaled back, and handled through
the layers. 6\\. Construct a simple program (e.g., a TCP client/server) using
methods of layering, error detection and recovery, and reflection of error
status across layers. 7\\. Identify bugs in a layered program by using tools
for program tracing, single stepping, and debugging. 8\\. Understand the
concept of strong vs weak scaling, i.e., how performance is affected by the
scale of the problem vs the scale of resources to solve the problem. This can
be motivated by simple, real-world examples."""^^xsd:string ;
            ns2:score "0.68781894"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some aspects like datapath and pipelining but lacks detailed coverage of logic design, layered systems, error handling, and scaling concepts." ;
            ns3:ka "System_Fundamentals_SF" ;
            ns3:ku "SF-Overview_of_Computer_Systems" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.700032"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most KU topics but lacks depth in Flynn taxonomy and detailed ISA comparisons." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.700032"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including architecture, programming, and memory organization, with some overlap in topics." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt> ;
            ns2:ku_text """Pages : 230-231 CS Core : 3, KA Core : 0 CS Core: 1\\. Basic building blocks
and components of a computer (gates, flip-flops, registers, interconnections;
datapath + control + memory) 2\\. Hardware as a computational paradigm:
Fundamental logic building blocks; Logic expressions, minimization, sum of
product forms (See also: AR-Logic) 3\\. Programming abstractions, interfaces,
use of libraries (See also: PDC-Programs) 4\\. Distinction and interaction
between application and OS services, remote procedure call (See also: OS-
Purpose) 5\\. Basic concept of pipelining, overlapped processing stages (See
also: AR-Organization) 6\\. Basic concept of scaling: performance vs problem
size Illustrative Learning Outcomes: CS Core: 1\\. Describe the basic building
blocks of computers and their role in the historical development of computer
architecture. 2\\. Design a simple logic circuit using the fundamental building
blocks of logic design to solve a simple problem (e.g., adder). 3\\. Describe
how computing systems are constructed of layers upon layers, based on
separation of concerns, with well-defined interfaces, hiding details of low
layers from the higher layers. 4\\. Describe that hardware, OS, VM, and
application are additional layers of interpretation/processing. 5\\. Describe
the mechanisms of how errors are detected, signaled back, and handled through
the layers. 6\\. Construct a simple program (e.g., a TCP client/server) using
methods of layering, error detection and recovery, and reflection of error
status across layers. 7\\. Identify bugs in a layered program by using tools
for program tracing, single stepping, and debugging. 8\\. Understand the
concept of strong vs weak scaling, i.e., how performance is affected by the
scale of the problem vs the scale of resources to solve the problem. This can
be motivated by simple, real-world examples."""^^xsd:string ;
            ns2:score "0.68781894"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers logic components, assembly, pipelining, and cache but lacks OS layer details and scaling concepts." ;
            ns3:ka "System_Fundamentals_SF" ;
            ns3:ku "SF-Overview_of_Computer_Systems" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.700032"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers ISA, assembly, processor architectures, and memory/cache, aligning with KA/CS Core topics." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.70315826"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most KU topics but lacks depth in Flynn taxonomy and detailed ISA comparisons." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.700032"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers ISA, assembly, processor architectures, and memory/cache, aligning with KA/CS Core topics." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt> ;
            ns2:ku_text """Pages:103-104 HOURS CS Core = 1 KA Core = 2 AR-Assembly: Assembly Level
Machine Organization CS Core: 1\\. von Neumann machine architecture 2\\. Control
unit: instruction fetch, decode, and execution (See also: OS-Principles) 3\\.
Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs,
OS-Scheduling, OS-Process) 104 4\\. Shared memory multiprocessors/multicore
organization (See also: PDC-Programs, OS-Scheduling) KA Core: 5\\. Instruction
set architecture (ISA) (e.g., x86, ARM and RISC-V) a. Fixed vs variable-width
instruction sets b. Instruction formats c. Data manipulation, control, I/O d.
Addressing modes e. Machine language programming f. Assembly language
programming 6\\. Subroutine call and return mechanisms (See also: FPL-
Translation, OS-Principles) 7\\. I/O and interrupts (See also: OS-Principles)
8\\. Heap, static, stack, and code segments (See also: FPL-Translation, OS-
Process) Illustrative Learning Outcomes: CS Core: 1\\. Discuss how the
classical von Neumann functional units are implemented in embedded systems,
particularly on-chip and off-chip memory. 2\\. Describe how instructions are
executed in a classical von Neumann machine, with extensions for threads,
multiprocessor synchronization, and SIMD execution. 3\\. Assess an example
diagram with instruction-level parallelism and hazards to describe how they
are managed in typical processor pipelines. KA Core: 4\\. Discuss how
instructions are represented at the machine level and in the context of a
symbolic assembler. 5\\. Map an example of high-level language patterns into
assembly/machine language notations. 6\\. Contrast different instruction
formats considering aspects such as addresses per instruction and variable-
length vs fixed-length formats. 7\\. Analyze a subroutine diagram to comment on
how subroutine calls are handled at the assembly level. 8\\. Describe basic
concepts of interrupts and I/O operations. 9\\. Write a simple assembly
language program for string/array processing and manipulation."""^^xsd:string ;
            ns2:score "0.70315826"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers ISA, assembly, processor architectures, and memory/cache, aligning with KA/CS Core topics." ;
            ns3:ka "Architecture_and_Organization_AR" ;
            ns3:ku "AR-Assembly_Assembly_Level_Machine_Organization" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ] ;
    ns2:uetext """Label: Architecture des ordinateurs Objectif: (résultats d'apprentissage)
l'implémentation des éléments logiques de base (mux/demux, registres, ...);
• connaître les principes de la programmation dans un langage d'assemblage et savoir traduire les
appels de fonctions et de procédures en respectant les conventions dictées par l'environnement;
• savoir mettre en oeuvre un processeur monocycle simple en définissant les chemins de données
de son jeu d'instructions;
• connaître les principes sous-tendant les processeurs multicycles et les architectures pipelinées
• connaître la notion de cache mémoire et ses différentes implémentations, et en connaître les
impacts sur les algorithmes. Course content: données et de
contrôle).
* Les mémoires: communication par bus, principe de localité, cache, virtualisation
* Multiprocesseurs, multicœurs et GPU [optionnel, en fonction du temps disponible] Course name: http://example.org/course/UE_X31I050""" .

ns3:UE_X31T060 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns2:score "0.654318"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional integration and general work structures, not on software engineering or testing concepts." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Testing_and_Quality_Assurance" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.6692901"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics related to intellectual property, responsibility, and professional ethics, which align with the KU's learning outcomes." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns2:score "0.654318"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional integration and general work structures, not on software engineering or testing concepts." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Testing_and_Quality_Assurance" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt> ;
            ns2:ku_text """Pages:71-75 HOURS CS Core = 4 KA Core = 6 AI-ML: Machine Learning CS Core: 1\\.
Definition and examples of a broad variety of machine learning tasks a.
Supervised learning i. Classification ii. Regression b. Reinforcement learning
c. Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability in machine
learning 3\\. A simple statistical-based supervised learning such as linear
regression or decision trees a. Focus on how they work without going into
mathematical or optimization details; enough to understand and use existing
implementations correctly 4\\. The overfitting problem/controlling solution
complexity (regularization, pruning - intuition only) a. The bias
(underfitting) - variance (overfitting) tradeoff 5\\. Working with Data a. Data
preprocessing i. Importance and pitfalls of preprocessing choices b. Handling
missing values (imputing, flag-as-missing) i. Implications of imputing vs
flag-as-missing c. Encoding categorical variables, encoding real-valued data
d. Normalization/standardization e. Emphasis on real data, not textbook
examples 6\\. Representations a. Hypothesis spaces and complexity b. Simple
basis feature expansion, such as squaring univariate features c. Learned
feature representations 7\\. Machine learning evaluation a. Separation of
train, validation, and test sets b. Performance metrics for classifiers c.
Estimation of test performance on held-out data d. Tuning the parameters of a
machine learning model with a validation set e. Importance of understanding
what a model is doing, where its pitfalls/shortcomings are, and the
implications of its decisions 8\\. Basic neural networks a. Fundamentals of
understanding how neural networks work and their training process, without
details of the calculations b. Basic introduction to generative neural
networks (e.g., large language models) 9\\. Ethics for Machine Learning (See
also: SEP-Context) a. Focus on real data, real scenarios, and case studies b.
Dataset/algorithmic/evaluation bias and unintended consequences 72 KA Core:
10\\. Formulation of simple machine learning as an optimization problem, such
as least squares linear regression or logistic regression a. Objective
function b. Gradient descent c. Regularization to avoid overfitting
(mathematical formulation) 11\\. Ensembles of models a. Simple weighted
majority combination 12\\. Deep learning a. Deep feed-forward networks
(intuition only, no mathematics) b. Convolutional neural networks (intuition
only, no mathematics) c. Visualization of learned feature representations from
deep nets d. Other architectures (generative NN, recurrent NN, transformers,
etc.) 13\\. Performance evaluation a. Other metrics for classification (e.g.,
error, precision, recall) b. Performance metrics for regressors c. Confusion
matrix d. Cross-validation i. Parameter tuning (grid/random search, via cross-
validation) 14\\. Overview of reinforcement learning methods 15\\. Two or more
applications of machine learning algorithms a. E.g., medicine and health,
economics, vision, natural language, robotics, game play 16\\. Ethics for
Machine Learning a. Continued focus on real data, real scenarios, and case
studies (See also: SEP-Context) b. Privacy (See also: SEP-Privacy) c. Fairness
(See also: SEP-Privacy) d. Intellectual property e. Explainability Non-core:
17\\. General statistical-based learning, parameter estimation (maximum
likelihood) 18\\. Supervised learning a. Decision trees b. Nearest-neighbor
classification and regression c. Learning simple neural networks / multi-layer
perceptrons d. Linear regression e. Logistic regression f. Support vector
machines (SVMs) and kernels g. Gaussian Processes 19\\. Overfitting a. The
curse of dimensionality b. Regularization (mathematical computations, L2 and
L1 regularization) 20\\. Experimental design 73 a. Data preparation (e.g.,
standardization, representation, one-hot encoding) b. Hypothesis space c.
Biases (e.g., algorithmic, search) d. Partitioning data: stratification,
training set, validation set, test set e. Parameter tuning (grid/random
search, via cross-validation) f. Performance evaluation i. Cross-validation
ii. Metric: error, precision, recall, confusion matrix iii. Receiver operating
characteristic (ROC) curve and area under ROC curve 21\\. Bayesian learning
(Cross-Reference AI/Reasoning Under Uncertainty) a. Naive Bayes and its
relationship to linear models b. Bayesian networks c. Prior/posterior d.
Generative models 22\\. Deep learning a. Deep feed-forward networks b. Neural
tangent kernel and understanding neural network training c. Convolutional
neural networks d. Autoencoders e. Recurrent networks f. Representations and
knowledge transfer g. Adversarial training and generative adversarial networks
h. Attention mechanisms 23\\. Representations a. Manually crafted
representations b. Basis expansion c. Learned representations (e.g., deep
neural networks) 24\\. Unsupervised learning and clustering a. K-means b.
Gaussian mixture models c. Expectation maximization (EM) d. Self-organizing
maps 25\\. Graph analysis (e.g., PageRank) 26\\. Semi-supervised learning 27\\.
Graphical models (See also: AI-Probability) 28\\. Ensembles a. Weighted
majority b. Boosting/bagging c. Random forest d. Gated ensemble 29\\. Learning
theory a. General overview of learning theory / why learning works b. VC
dimension c. Generalization bounds 74 30\\. Reinforcement learning a.
Exploration vs exploitation tradeoff b. Markov decision processes c. Value and
policy iteration d. Policy gradient methods e. Deep reinforcement learning f.
Learning from demonstration and inverse RL 31\\. Explainable / interpretable
machine learning a. Understanding feature importance (e.g., LIME, Shapley
values) b. Interpretable models and representations 32\\. Recommender systems
33\\. Hardware for machine learning a. GPUs / TPUs 34\\. Application of machine
learning algorithms to: a. Medicine and health b. Economics c. Education d.
Vision e. Natural language f. Robotics g. Game play h. Data mining (Cross-
reference DM/Data Analytics) 35\\. Ethics for Machine Learning a. Continued
focus on real data, real scenarios, and case studies (See also: SEP-Context)
b. In depth exploration of dataset/algorithmic/evaluation bias, data privacy,
and fairness (See also: SEP-Privacy, SEP-Context) c. Trust / explainability
Illustrative Learning Outcomes: 1\\. Describe the differences among the three
main styles of learning (supervised, reinforcement, and unsupervised) and
determine which is appropriate to a particular problem domain. 2\\.
Differentiate the terms of AI, machine learning, and deep learning. 3\\. Frame
an application as a classification problem, including the available input
features and output to be predicted (e.g., identifying alphabetic characters
from pixel grid input). 4\\. Apply two or more simple statistical learning
algorithms to a classification task and measure the classifiers' accuracy. 5\\.
Identify overfitting in the context of a problem and learning curves and
describe solutions to overfitting. 6\\. Explain how machine learning works as
an optimization/search process. 7\\. Implement a statistical learning algorithm
and the corresponding optimization process to train the classifier and obtain
a prediction on new data. 8\\. Describe the neural network training process and
resulting learned representations. 75 9\\. Explain proper ML evaluation
procedures, including the differences between training and testing
performance, and what can go wrong with the evaluation process leading to
inaccurate reporting of ML performance. 10\\. Compare two machine learning
algorithms on a dataset, implementing the data preprocessing and evaluation
methodology (e.g., metrics and handling of train/test splits) from scratch.
11\\. Visualize the training progress of a neural network through learning
curves in a well-established toolkit (e.g., TensorBoard) and visualize the
learned features of the network. 12\\. Compare and contrast several learning
techniques (e.g., decision trees, logistic regression, naive Bayes, neural
networks, and belief networks), providing examples of when each strategy is
superior. 13\\. Evaluate the performance of a simple learning system on a real-
world dataset. 14\\. Characterize the state of the art in learning theory,
including its achievements and shortcomings. 15\\. Explain the problem of
overfitting, along with techniques for detecting and managing the problem.
16\\. Explain the triple tradeoff among the size of a hypothesis space, the
size of the training set, and performance accuracy. 17\\. Given a real-world
application of machine learning, describe ethical issues regarding the choices
of data, preprocessing steps, algorithm selection, and
visualization/presentation of results"""^^xsd:string ;
            ns2:score "0.65111214"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on professional skills and basic ML concepts (e.g., overfitting, data preprocessing), but lacks depth on algorithms, mathematical foundations, and extensive evaluation/ethical analysis required by the KU." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-ML_Machine_Learning" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.6692901"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on professional roles/entrepreneurship, not intellectual property, plagiarism, or programmer ethics." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt> ;
            ns2:ku_text """Pages:71-75 HOURS CS Core = 4 KA Core = 6 AI-ML: Machine Learning CS Core: 1\\.
Definition and examples of a broad variety of machine learning tasks a.
Supervised learning i. Classification ii. Regression b. Reinforcement learning
c. Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability in machine
learning 3\\. A simple statistical-based supervised learning such as linear
regression or decision trees a. Focus on how they work without going into
mathematical or optimization details; enough to understand and use existing
implementations correctly 4\\. The overfitting problem/controlling solution
complexity (regularization, pruning - intuition only) a. The bias
(underfitting) - variance (overfitting) tradeoff 5\\. Working with Data a. Data
preprocessing i. Importance and pitfalls of preprocessing choices b. Handling
missing values (imputing, flag-as-missing) i. Implications of imputing vs
flag-as-missing c. Encoding categorical variables, encoding real-valued data
d. Normalization/standardization e. Emphasis on real data, not textbook
examples 6\\. Representations a. Hypothesis spaces and complexity b. Simple
basis feature expansion, such as squaring univariate features c. Learned
feature representations 7\\. Machine learning evaluation a. Separation of
train, validation, and test sets b. Performance metrics for classifiers c.
Estimation of test performance on held-out data d. Tuning the parameters of a
machine learning model with a validation set e. Importance of understanding
what a model is doing, where its pitfalls/shortcomings are, and the
implications of its decisions 8\\. Basic neural networks a. Fundamentals of
understanding how neural networks work and their training process, without
details of the calculations b. Basic introduction to generative neural
networks (e.g., large language models) 9\\. Ethics for Machine Learning (See
also: SEP-Context) a. Focus on real data, real scenarios, and case studies b.
Dataset/algorithmic/evaluation bias and unintended consequences 72 KA Core:
10\\. Formulation of simple machine learning as an optimization problem, such
as least squares linear regression or logistic regression a. Objective
function b. Gradient descent c. Regularization to avoid overfitting
(mathematical formulation) 11\\. Ensembles of models a. Simple weighted
majority combination 12\\. Deep learning a. Deep feed-forward networks
(intuition only, no mathematics) b. Convolutional neural networks (intuition
only, no mathematics) c. Visualization of learned feature representations from
deep nets d. Other architectures (generative NN, recurrent NN, transformers,
etc.) 13\\. Performance evaluation a. Other metrics for classification (e.g.,
error, precision, recall) b. Performance metrics for regressors c. Confusion
matrix d. Cross-validation i. Parameter tuning (grid/random search, via cross-
validation) 14\\. Overview of reinforcement learning methods 15\\. Two or more
applications of machine learning algorithms a. E.g., medicine and health,
economics, vision, natural language, robotics, game play 16\\. Ethics for
Machine Learning a. Continued focus on real data, real scenarios, and case
studies (See also: SEP-Context) b. Privacy (See also: SEP-Privacy) c. Fairness
(See also: SEP-Privacy) d. Intellectual property e. Explainability Non-core:
17\\. General statistical-based learning, parameter estimation (maximum
likelihood) 18\\. Supervised learning a. Decision trees b. Nearest-neighbor
classification and regression c. Learning simple neural networks / multi-layer
perceptrons d. Linear regression e. Logistic regression f. Support vector
machines (SVMs) and kernels g. Gaussian Processes 19\\. Overfitting a. The
curse of dimensionality b. Regularization (mathematical computations, L2 and
L1 regularization) 20\\. Experimental design 73 a. Data preparation (e.g.,
standardization, representation, one-hot encoding) b. Hypothesis space c.
Biases (e.g., algorithmic, search) d. Partitioning data: stratification,
training set, validation set, test set e. Parameter tuning (grid/random
search, via cross-validation) f. Performance evaluation i. Cross-validation
ii. Metric: error, precision, recall, confusion matrix iii. Receiver operating
characteristic (ROC) curve and area under ROC curve 21\\. Bayesian learning
(Cross-Reference AI/Reasoning Under Uncertainty) a. Naive Bayes and its
relationship to linear models b. Bayesian networks c. Prior/posterior d.
Generative models 22\\. Deep learning a. Deep feed-forward networks b. Neural
tangent kernel and understanding neural network training c. Convolutional
neural networks d. Autoencoders e. Recurrent networks f. Representations and
knowledge transfer g. Adversarial training and generative adversarial networks
h. Attention mechanisms 23\\. Representations a. Manually crafted
representations b. Basis expansion c. Learned representations (e.g., deep
neural networks) 24\\. Unsupervised learning and clustering a. K-means b.
Gaussian mixture models c. Expectation maximization (EM) d. Self-organizing
maps 25\\. Graph analysis (e.g., PageRank) 26\\. Semi-supervised learning 27\\.
Graphical models (See also: AI-Probability) 28\\. Ensembles a. Weighted
majority b. Boosting/bagging c. Random forest d. Gated ensemble 29\\. Learning
theory a. General overview of learning theory / why learning works b. VC
dimension c. Generalization bounds 74 30\\. Reinforcement learning a.
Exploration vs exploitation tradeoff b. Markov decision processes c. Value and
policy iteration d. Policy gradient methods e. Deep reinforcement learning f.
Learning from demonstration and inverse RL 31\\. Explainable / interpretable
machine learning a. Understanding feature importance (e.g., LIME, Shapley
values) b. Interpretable models and representations 32\\. Recommender systems
33\\. Hardware for machine learning a. GPUs / TPUs 34\\. Application of machine
learning algorithms to: a. Medicine and health b. Economics c. Education d.
Vision e. Natural language f. Robotics g. Game play h. Data mining (Cross-
reference DM/Data Analytics) 35\\. Ethics for Machine Learning a. Continued
focus on real data, real scenarios, and case studies (See also: SEP-Context)
b. In depth exploration of dataset/algorithmic/evaluation bias, data privacy,
and fairness (See also: SEP-Privacy, SEP-Context) c. Trust / explainability
Illustrative Learning Outcomes: 1\\. Describe the differences among the three
main styles of learning (supervised, reinforcement, and unsupervised) and
determine which is appropriate to a particular problem domain. 2\\.
Differentiate the terms of AI, machine learning, and deep learning. 3\\. Frame
an application as a classification problem, including the available input
features and output to be predicted (e.g., identifying alphabetic characters
from pixel grid input). 4\\. Apply two or more simple statistical learning
algorithms to a classification task and measure the classifiers' accuracy. 5\\.
Identify overfitting in the context of a problem and learning curves and
describe solutions to overfitting. 6\\. Explain how machine learning works as
an optimization/search process. 7\\. Implement a statistical learning algorithm
and the corresponding optimization process to train the classifier and obtain
a prediction on new data. 8\\. Describe the neural network training process and
resulting learned representations. 75 9\\. Explain proper ML evaluation
procedures, including the differences between training and testing
performance, and what can go wrong with the evaluation process leading to
inaccurate reporting of ML performance. 10\\. Compare two machine learning
algorithms on a dataset, implementing the data preprocessing and evaluation
methodology (e.g., metrics and handling of train/test splits) from scratch.
11\\. Visualize the training progress of a neural network through learning
curves in a well-established toolkit (e.g., TensorBoard) and visualize the
learned features of the network. 12\\. Compare and contrast several learning
techniques (e.g., decision trees, logistic regression, naive Bayes, neural
networks, and belief networks), providing examples of when each strategy is
superior. 13\\. Evaluate the performance of a simple learning system on a real-
world dataset. 14\\. Characterize the state of the art in learning theory,
including its achievements and shortcomings. 15\\. Explain the problem of
overfitting, along with techniques for detecting and managing the problem.
16\\. Explain the triple tradeoff among the size of a hypothesis space, the
size of the training set, and performance accuracy. 17\\. Given a real-world
application of machine learning, describe ethical issues regarding the choices
of data, preprocessing steps, algorithm selection, and
visualization/presentation of results"""^^xsd:string ;
            ns2:score "0.65111214"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on professional skills and basic ML concepts (e.g., overfitting, data preprocessing), but lacks depth on algorithms, mathematical foundations, and extensive evaluation/ethical analysis required by the KU." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-ML_Machine_Learning" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns2:score "0.654318"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap in topics; lecture focuses on professional skills, not SE-TQA concepts." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Testing_and_Quality_Assurance" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt> ;
            ns2:ku_text """Pages:71-75 HOURS CS Core = 4 KA Core = 6 AI-ML: Machine Learning CS Core: 1\\.
Definition and examples of a broad variety of machine learning tasks a.
Supervised learning i. Classification ii. Regression b. Reinforcement learning
c. Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability in machine
learning 3\\. A simple statistical-based supervised learning such as linear
regression or decision trees a. Focus on how they work without going into
mathematical or optimization details; enough to understand and use existing
implementations correctly 4\\. The overfitting problem/controlling solution
complexity (regularization, pruning - intuition only) a. The bias
(underfitting) - variance (overfitting) tradeoff 5\\. Working with Data a. Data
preprocessing i. Importance and pitfalls of preprocessing choices b. Handling
missing values (imputing, flag-as-missing) i. Implications of imputing vs
flag-as-missing c. Encoding categorical variables, encoding real-valued data
d. Normalization/standardization e. Emphasis on real data, not textbook
examples 6\\. Representations a. Hypothesis spaces and complexity b. Simple
basis feature expansion, such as squaring univariate features c. Learned
feature representations 7\\. Machine learning evaluation a. Separation of
train, validation, and test sets b. Performance metrics for classifiers c.
Estimation of test performance on held-out data d. Tuning the parameters of a
machine learning model with a validation set e. Importance of understanding
what a model is doing, where its pitfalls/shortcomings are, and the
implications of its decisions 8\\. Basic neural networks a. Fundamentals of
understanding how neural networks work and their training process, without
details of the calculations b. Basic introduction to generative neural
networks (e.g., large language models) 9\\. Ethics for Machine Learning (See
also: SEP-Context) a. Focus on real data, real scenarios, and case studies b.
Dataset/algorithmic/evaluation bias and unintended consequences 72 KA Core:
10\\. Formulation of simple machine learning as an optimization problem, such
as least squares linear regression or logistic regression a. Objective
function b. Gradient descent c. Regularization to avoid overfitting
(mathematical formulation) 11\\. Ensembles of models a. Simple weighted
majority combination 12\\. Deep learning a. Deep feed-forward networks
(intuition only, no mathematics) b. Convolutional neural networks (intuition
only, no mathematics) c. Visualization of learned feature representations from
deep nets d. Other architectures (generative NN, recurrent NN, transformers,
etc.) 13\\. Performance evaluation a. Other metrics for classification (e.g.,
error, precision, recall) b. Performance metrics for regressors c. Confusion
matrix d. Cross-validation i. Parameter tuning (grid/random search, via cross-
validation) 14\\. Overview of reinforcement learning methods 15\\. Two or more
applications of machine learning algorithms a. E.g., medicine and health,
economics, vision, natural language, robotics, game play 16\\. Ethics for
Machine Learning a. Continued focus on real data, real scenarios, and case
studies (See also: SEP-Context) b. Privacy (See also: SEP-Privacy) c. Fairness
(See also: SEP-Privacy) d. Intellectual property e. Explainability Non-core:
17\\. General statistical-based learning, parameter estimation (maximum
likelihood) 18\\. Supervised learning a. Decision trees b. Nearest-neighbor
classification and regression c. Learning simple neural networks / multi-layer
perceptrons d. Linear regression e. Logistic regression f. Support vector
machines (SVMs) and kernels g. Gaussian Processes 19\\. Overfitting a. The
curse of dimensionality b. Regularization (mathematical computations, L2 and
L1 regularization) 20\\. Experimental design 73 a. Data preparation (e.g.,
standardization, representation, one-hot encoding) b. Hypothesis space c.
Biases (e.g., algorithmic, search) d. Partitioning data: stratification,
training set, validation set, test set e. Parameter tuning (grid/random
search, via cross-validation) f. Performance evaluation i. Cross-validation
ii. Metric: error, precision, recall, confusion matrix iii. Receiver operating
characteristic (ROC) curve and area under ROC curve 21\\. Bayesian learning
(Cross-Reference AI/Reasoning Under Uncertainty) a. Naive Bayes and its
relationship to linear models b. Bayesian networks c. Prior/posterior d.
Generative models 22\\. Deep learning a. Deep feed-forward networks b. Neural
tangent kernel and understanding neural network training c. Convolutional
neural networks d. Autoencoders e. Recurrent networks f. Representations and
knowledge transfer g. Adversarial training and generative adversarial networks
h. Attention mechanisms 23\\. Representations a. Manually crafted
representations b. Basis expansion c. Learned representations (e.g., deep
neural networks) 24\\. Unsupervised learning and clustering a. K-means b.
Gaussian mixture models c. Expectation maximization (EM) d. Self-organizing
maps 25\\. Graph analysis (e.g., PageRank) 26\\. Semi-supervised learning 27\\.
Graphical models (See also: AI-Probability) 28\\. Ensembles a. Weighted
majority b. Boosting/bagging c. Random forest d. Gated ensemble 29\\. Learning
theory a. General overview of learning theory / why learning works b. VC
dimension c. Generalization bounds 74 30\\. Reinforcement learning a.
Exploration vs exploitation tradeoff b. Markov decision processes c. Value and
policy iteration d. Policy gradient methods e. Deep reinforcement learning f.
Learning from demonstration and inverse RL 31\\. Explainable / interpretable
machine learning a. Understanding feature importance (e.g., LIME, Shapley
values) b. Interpretable models and representations 32\\. Recommender systems
33\\. Hardware for machine learning a. GPUs / TPUs 34\\. Application of machine
learning algorithms to: a. Medicine and health b. Economics c. Education d.
Vision e. Natural language f. Robotics g. Game play h. Data mining (Cross-
reference DM/Data Analytics) 35\\. Ethics for Machine Learning a. Continued
focus on real data, real scenarios, and case studies (See also: SEP-Context)
b. In depth exploration of dataset/algorithmic/evaluation bias, data privacy,
and fairness (See also: SEP-Privacy, SEP-Context) c. Trust / explainability
Illustrative Learning Outcomes: 1\\. Describe the differences among the three
main styles of learning (supervised, reinforcement, and unsupervised) and
determine which is appropriate to a particular problem domain. 2\\.
Differentiate the terms of AI, machine learning, and deep learning. 3\\. Frame
an application as a classification problem, including the available input
features and output to be predicted (e.g., identifying alphabetic characters
from pixel grid input). 4\\. Apply two or more simple statistical learning
algorithms to a classification task and measure the classifiers' accuracy. 5\\.
Identify overfitting in the context of a problem and learning curves and
describe solutions to overfitting. 6\\. Explain how machine learning works as
an optimization/search process. 7\\. Implement a statistical learning algorithm
and the corresponding optimization process to train the classifier and obtain
a prediction on new data. 8\\. Describe the neural network training process and
resulting learned representations. 75 9\\. Explain proper ML evaluation
procedures, including the differences between training and testing
performance, and what can go wrong with the evaluation process leading to
inaccurate reporting of ML performance. 10\\. Compare two machine learning
algorithms on a dataset, implementing the data preprocessing and evaluation
methodology (e.g., metrics and handling of train/test splits) from scratch.
11\\. Visualize the training progress of a neural network through learning
curves in a well-established toolkit (e.g., TensorBoard) and visualize the
learned features of the network. 12\\. Compare and contrast several learning
techniques (e.g., decision trees, logistic regression, naive Bayes, neural
networks, and belief networks), providing examples of when each strategy is
superior. 13\\. Evaluate the performance of a simple learning system on a real-
world dataset. 14\\. Characterize the state of the art in learning theory,
including its achievements and shortcomings. 15\\. Explain the problem of
overfitting, along with techniques for detecting and managing the problem.
16\\. Explain the triple tradeoff among the size of a hypothesis space, the
size of the training set, and performance accuracy. 17\\. Given a real-world
application of machine learning, describe ethical issues regarding the choices
of data, preprocessing steps, algorithm selection, and
visualization/presentation of results"""^^xsd:string ;
            ns2:score "0.65111214"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional integration and soft skills, while the KU covers technical machine learning topics." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-ML_Machine_Learning" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.6692901"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers topics related to intellectual property, responsibility, and professional ethics, which align with the KU's learning outcomes." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.6692901"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional integration and general ethics but does not cover intellectual property, plagiarism, or specific programmer responsibilities as outlined in the KU." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt> ;
            ns2:ku_text """Pages:71-75 HOURS CS Core = 4 KA Core = 6 AI-ML: Machine Learning CS Core: 1\\.
Definition and examples of a broad variety of machine learning tasks a.
Supervised learning i. Classification ii. Regression b. Reinforcement learning
c. Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability in machine
learning 3\\. A simple statistical-based supervised learning such as linear
regression or decision trees a. Focus on how they work without going into
mathematical or optimization details; enough to understand and use existing
implementations correctly 4\\. The overfitting problem/controlling solution
complexity (regularization, pruning - intuition only) a. The bias
(underfitting) - variance (overfitting) tradeoff 5\\. Working with Data a. Data
preprocessing i. Importance and pitfalls of preprocessing choices b. Handling
missing values (imputing, flag-as-missing) i. Implications of imputing vs
flag-as-missing c. Encoding categorical variables, encoding real-valued data
d. Normalization/standardization e. Emphasis on real data, not textbook
examples 6\\. Representations a. Hypothesis spaces and complexity b. Simple
basis feature expansion, such as squaring univariate features c. Learned
feature representations 7\\. Machine learning evaluation a. Separation of
train, validation, and test sets b. Performance metrics for classifiers c.
Estimation of test performance on held-out data d. Tuning the parameters of a
machine learning model with a validation set e. Importance of understanding
what a model is doing, where its pitfalls/shortcomings are, and the
implications of its decisions 8\\. Basic neural networks a. Fundamentals of
understanding how neural networks work and their training process, without
details of the calculations b. Basic introduction to generative neural
networks (e.g., large language models) 9\\. Ethics for Machine Learning (See
also: SEP-Context) a. Focus on real data, real scenarios, and case studies b.
Dataset/algorithmic/evaluation bias and unintended consequences 72 KA Core:
10\\. Formulation of simple machine learning as an optimization problem, such
as least squares linear regression or logistic regression a. Objective
function b. Gradient descent c. Regularization to avoid overfitting
(mathematical formulation) 11\\. Ensembles of models a. Simple weighted
majority combination 12\\. Deep learning a. Deep feed-forward networks
(intuition only, no mathematics) b. Convolutional neural networks (intuition
only, no mathematics) c. Visualization of learned feature representations from
deep nets d. Other architectures (generative NN, recurrent NN, transformers,
etc.) 13\\. Performance evaluation a. Other metrics for classification (e.g.,
error, precision, recall) b. Performance metrics for regressors c. Confusion
matrix d. Cross-validation i. Parameter tuning (grid/random search, via cross-
validation) 14\\. Overview of reinforcement learning methods 15\\. Two or more
applications of machine learning algorithms a. E.g., medicine and health,
economics, vision, natural language, robotics, game play 16\\. Ethics for
Machine Learning a. Continued focus on real data, real scenarios, and case
studies (See also: SEP-Context) b. Privacy (See also: SEP-Privacy) c. Fairness
(See also: SEP-Privacy) d. Intellectual property e. Explainability Non-core:
17\\. General statistical-based learning, parameter estimation (maximum
likelihood) 18\\. Supervised learning a. Decision trees b. Nearest-neighbor
classification and regression c. Learning simple neural networks / multi-layer
perceptrons d. Linear regression e. Logistic regression f. Support vector
machines (SVMs) and kernels g. Gaussian Processes 19\\. Overfitting a. The
curse of dimensionality b. Regularization (mathematical computations, L2 and
L1 regularization) 20\\. Experimental design 73 a. Data preparation (e.g.,
standardization, representation, one-hot encoding) b. Hypothesis space c.
Biases (e.g., algorithmic, search) d. Partitioning data: stratification,
training set, validation set, test set e. Parameter tuning (grid/random
search, via cross-validation) f. Performance evaluation i. Cross-validation
ii. Metric: error, precision, recall, confusion matrix iii. Receiver operating
characteristic (ROC) curve and area under ROC curve 21\\. Bayesian learning
(Cross-Reference AI/Reasoning Under Uncertainty) a. Naive Bayes and its
relationship to linear models b. Bayesian networks c. Prior/posterior d.
Generative models 22\\. Deep learning a. Deep feed-forward networks b. Neural
tangent kernel and understanding neural network training c. Convolutional
neural networks d. Autoencoders e. Recurrent networks f. Representations and
knowledge transfer g. Adversarial training and generative adversarial networks
h. Attention mechanisms 23\\. Representations a. Manually crafted
representations b. Basis expansion c. Learned representations (e.g., deep
neural networks) 24\\. Unsupervised learning and clustering a. K-means b.
Gaussian mixture models c. Expectation maximization (EM) d. Self-organizing
maps 25\\. Graph analysis (e.g., PageRank) 26\\. Semi-supervised learning 27\\.
Graphical models (See also: AI-Probability) 28\\. Ensembles a. Weighted
majority b. Boosting/bagging c. Random forest d. Gated ensemble 29\\. Learning
theory a. General overview of learning theory / why learning works b. VC
dimension c. Generalization bounds 74 30\\. Reinforcement learning a.
Exploration vs exploitation tradeoff b. Markov decision processes c. Value and
policy iteration d. Policy gradient methods e. Deep reinforcement learning f.
Learning from demonstration and inverse RL 31\\. Explainable / interpretable
machine learning a. Understanding feature importance (e.g., LIME, Shapley
values) b. Interpretable models and representations 32\\. Recommender systems
33\\. Hardware for machine learning a. GPUs / TPUs 34\\. Application of machine
learning algorithms to: a. Medicine and health b. Economics c. Education d.
Vision e. Natural language f. Robotics g. Game play h. Data mining (Cross-
reference DM/Data Analytics) 35\\. Ethics for Machine Learning a. Continued
focus on real data, real scenarios, and case studies (See also: SEP-Context)
b. In depth exploration of dataset/algorithmic/evaluation bias, data privacy,
and fairness (See also: SEP-Privacy, SEP-Context) c. Trust / explainability
Illustrative Learning Outcomes: 1\\. Describe the differences among the three
main styles of learning (supervised, reinforcement, and unsupervised) and
determine which is appropriate to a particular problem domain. 2\\.
Differentiate the terms of AI, machine learning, and deep learning. 3\\. Frame
an application as a classification problem, including the available input
features and output to be predicted (e.g., identifying alphabetic characters
from pixel grid input). 4\\. Apply two or more simple statistical learning
algorithms to a classification task and measure the classifiers' accuracy. 5\\.
Identify overfitting in the context of a problem and learning curves and
describe solutions to overfitting. 6\\. Explain how machine learning works as
an optimization/search process. 7\\. Implement a statistical learning algorithm
and the corresponding optimization process to train the classifier and obtain
a prediction on new data. 8\\. Describe the neural network training process and
resulting learned representations. 75 9\\. Explain proper ML evaluation
procedures, including the differences between training and testing
performance, and what can go wrong with the evaluation process leading to
inaccurate reporting of ML performance. 10\\. Compare two machine learning
algorithms on a dataset, implementing the data preprocessing and evaluation
methodology (e.g., metrics and handling of train/test splits) from scratch.
11\\. Visualize the training progress of a neural network through learning
curves in a well-established toolkit (e.g., TensorBoard) and visualize the
learned features of the network. 12\\. Compare and contrast several learning
techniques (e.g., decision trees, logistic regression, naive Bayes, neural
networks, and belief networks), providing examples of when each strategy is
superior. 13\\. Evaluate the performance of a simple learning system on a real-
world dataset. 14\\. Characterize the state of the art in learning theory,
including its achievements and shortcomings. 15\\. Explain the problem of
overfitting, along with techniques for detecting and managing the problem.
16\\. Explain the triple tradeoff among the size of a hypothesis space, the
size of the training set, and performance accuracy. 17\\. Given a real-world
application of machine learning, describe ethical issues regarding the choices
of data, preprocessing steps, algorithm selection, and
visualization/presentation of results"""^^xsd:string ;
            ns2:score "0.65111214"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as machine learning, supervised and unsupervised learning, neural networks, and ethics. The lecture also provides practical examples and illustrations, which align with the KU's emphasis on real-world applications." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-ML_Machine_Learning" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns2:score "0.654318"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional opening and entrepreneurship, whereas the KU covers SE-Testing and Quality Assurance, which are unrelated topics." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Testing_and_Quality_Assurance" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt> ;
            ns2:ku_text """Pages:71-75 HOURS CS Core = 4 KA Core = 6 AI-ML: Machine Learning CS Core: 1\\.
Definition and examples of a broad variety of machine learning tasks a.
Supervised learning i. Classification ii. Regression b. Reinforcement learning
c. Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability in machine
learning 3\\. A simple statistical-based supervised learning such as linear
regression or decision trees a. Focus on how they work without going into
mathematical or optimization details; enough to understand and use existing
implementations correctly 4\\. The overfitting problem/controlling solution
complexity (regularization, pruning - intuition only) a. The bias
(underfitting) - variance (overfitting) tradeoff 5\\. Working with Data a. Data
preprocessing i. Importance and pitfalls of preprocessing choices b. Handling
missing values (imputing, flag-as-missing) i. Implications of imputing vs
flag-as-missing c. Encoding categorical variables, encoding real-valued data
d. Normalization/standardization e. Emphasis on real data, not textbook
examples 6\\. Representations a. Hypothesis spaces and complexity b. Simple
basis feature expansion, such as squaring univariate features c. Learned
feature representations 7\\. Machine learning evaluation a. Separation of
train, validation, and test sets b. Performance metrics for classifiers c.
Estimation of test performance on held-out data d. Tuning the parameters of a
machine learning model with a validation set e. Importance of understanding
what a model is doing, where its pitfalls/shortcomings are, and the
implications of its decisions 8\\. Basic neural networks a. Fundamentals of
understanding how neural networks work and their training process, without
details of the calculations b. Basic introduction to generative neural
networks (e.g., large language models) 9\\. Ethics for Machine Learning (See
also: SEP-Context) a. Focus on real data, real scenarios, and case studies b.
Dataset/algorithmic/evaluation bias and unintended consequences 72 KA Core:
10\\. Formulation of simple machine learning as an optimization problem, such
as least squares linear regression or logistic regression a. Objective
function b. Gradient descent c. Regularization to avoid overfitting
(mathematical formulation) 11\\. Ensembles of models a. Simple weighted
majority combination 12\\. Deep learning a. Deep feed-forward networks
(intuition only, no mathematics) b. Convolutional neural networks (intuition
only, no mathematics) c. Visualization of learned feature representations from
deep nets d. Other architectures (generative NN, recurrent NN, transformers,
etc.) 13\\. Performance evaluation a. Other metrics for classification (e.g.,
error, precision, recall) b. Performance metrics for regressors c. Confusion
matrix d. Cross-validation i. Parameter tuning (grid/random search, via cross-
validation) 14\\. Overview of reinforcement learning methods 15\\. Two or more
applications of machine learning algorithms a. E.g., medicine and health,
economics, vision, natural language, robotics, game play 16\\. Ethics for
Machine Learning a. Continued focus on real data, real scenarios, and case
studies (See also: SEP-Context) b. Privacy (See also: SEP-Privacy) c. Fairness
(See also: SEP-Privacy) d. Intellectual property e. Explainability Non-core:
17\\. General statistical-based learning, parameter estimation (maximum
likelihood) 18\\. Supervised learning a. Decision trees b. Nearest-neighbor
classification and regression c. Learning simple neural networks / multi-layer
perceptrons d. Linear regression e. Logistic regression f. Support vector
machines (SVMs) and kernels g. Gaussian Processes 19\\. Overfitting a. The
curse of dimensionality b. Regularization (mathematical computations, L2 and
L1 regularization) 20\\. Experimental design 73 a. Data preparation (e.g.,
standardization, representation, one-hot encoding) b. Hypothesis space c.
Biases (e.g., algorithmic, search) d. Partitioning data: stratification,
training set, validation set, test set e. Parameter tuning (grid/random
search, via cross-validation) f. Performance evaluation i. Cross-validation
ii. Metric: error, precision, recall, confusion matrix iii. Receiver operating
characteristic (ROC) curve and area under ROC curve 21\\. Bayesian learning
(Cross-Reference AI/Reasoning Under Uncertainty) a. Naive Bayes and its
relationship to linear models b. Bayesian networks c. Prior/posterior d.
Generative models 22\\. Deep learning a. Deep feed-forward networks b. Neural
tangent kernel and understanding neural network training c. Convolutional
neural networks d. Autoencoders e. Recurrent networks f. Representations and
knowledge transfer g. Adversarial training and generative adversarial networks
h. Attention mechanisms 23\\. Representations a. Manually crafted
representations b. Basis expansion c. Learned representations (e.g., deep
neural networks) 24\\. Unsupervised learning and clustering a. K-means b.
Gaussian mixture models c. Expectation maximization (EM) d. Self-organizing
maps 25\\. Graph analysis (e.g., PageRank) 26\\. Semi-supervised learning 27\\.
Graphical models (See also: AI-Probability) 28\\. Ensembles a. Weighted
majority b. Boosting/bagging c. Random forest d. Gated ensemble 29\\. Learning
theory a. General overview of learning theory / why learning works b. VC
dimension c. Generalization bounds 74 30\\. Reinforcement learning a.
Exploration vs exploitation tradeoff b. Markov decision processes c. Value and
policy iteration d. Policy gradient methods e. Deep reinforcement learning f.
Learning from demonstration and inverse RL 31\\. Explainable / interpretable
machine learning a. Understanding feature importance (e.g., LIME, Shapley
values) b. Interpretable models and representations 32\\. Recommender systems
33\\. Hardware for machine learning a. GPUs / TPUs 34\\. Application of machine
learning algorithms to: a. Medicine and health b. Economics c. Education d.
Vision e. Natural language f. Robotics g. Game play h. Data mining (Cross-
reference DM/Data Analytics) 35\\. Ethics for Machine Learning a. Continued
focus on real data, real scenarios, and case studies (See also: SEP-Context)
b. In depth exploration of dataset/algorithmic/evaluation bias, data privacy,
and fairness (See also: SEP-Privacy, SEP-Context) c. Trust / explainability
Illustrative Learning Outcomes: 1\\. Describe the differences among the three
main styles of learning (supervised, reinforcement, and unsupervised) and
determine which is appropriate to a particular problem domain. 2\\.
Differentiate the terms of AI, machine learning, and deep learning. 3\\. Frame
an application as a classification problem, including the available input
features and output to be predicted (e.g., identifying alphabetic characters
from pixel grid input). 4\\. Apply two or more simple statistical learning
algorithms to a classification task and measure the classifiers' accuracy. 5\\.
Identify overfitting in the context of a problem and learning curves and
describe solutions to overfitting. 6\\. Explain how machine learning works as
an optimization/search process. 7\\. Implement a statistical learning algorithm
and the corresponding optimization process to train the classifier and obtain
a prediction on new data. 8\\. Describe the neural network training process and
resulting learned representations. 75 9\\. Explain proper ML evaluation
procedures, including the differences between training and testing
performance, and what can go wrong with the evaluation process leading to
inaccurate reporting of ML performance. 10\\. Compare two machine learning
algorithms on a dataset, implementing the data preprocessing and evaluation
methodology (e.g., metrics and handling of train/test splits) from scratch.
11\\. Visualize the training progress of a neural network through learning
curves in a well-established toolkit (e.g., TensorBoard) and visualize the
learned features of the network. 12\\. Compare and contrast several learning
techniques (e.g., decision trees, logistic regression, naive Bayes, neural
networks, and belief networks), providing examples of when each strategy is
superior. 13\\. Evaluate the performance of a simple learning system on a real-
world dataset. 14\\. Characterize the state of the art in learning theory,
including its achievements and shortcomings. 15\\. Explain the problem of
overfitting, along with techniques for detecting and managing the problem.
16\\. Explain the triple tradeoff among the size of a hypothesis space, the
size of the training set, and performance accuracy. 17\\. Given a real-world
application of machine learning, describe ethical issues regarding the choices
of data, preprocessing steps, algorithm selection, and
visualization/presentation of results"""^^xsd:string ;
            ns2:score "0.65111214"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional integration and soft skills, while the KU covers technical machine learning topics." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-ML_Machine_Learning" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns2:score "0.654318"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap in topics; lecture focuses on professional skills, not SE-TQA concepts." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Testing_and_Quality_Assurance" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt> ;
            ns2:ku_text """Pages:71-75 HOURS CS Core = 4 KA Core = 6 AI-ML: Machine Learning CS Core: 1\\.
Definition and examples of a broad variety of machine learning tasks a.
Supervised learning i. Classification ii. Regression b. Reinforcement learning
c. Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability in machine
learning 3\\. A simple statistical-based supervised learning such as linear
regression or decision trees a. Focus on how they work without going into
mathematical or optimization details; enough to understand and use existing
implementations correctly 4\\. The overfitting problem/controlling solution
complexity (regularization, pruning - intuition only) a. The bias
(underfitting) - variance (overfitting) tradeoff 5\\. Working with Data a. Data
preprocessing i. Importance and pitfalls of preprocessing choices b. Handling
missing values (imputing, flag-as-missing) i. Implications of imputing vs
flag-as-missing c. Encoding categorical variables, encoding real-valued data
d. Normalization/standardization e. Emphasis on real data, not textbook
examples 6\\. Representations a. Hypothesis spaces and complexity b. Simple
basis feature expansion, such as squaring univariate features c. Learned
feature representations 7\\. Machine learning evaluation a. Separation of
train, validation, and test sets b. Performance metrics for classifiers c.
Estimation of test performance on held-out data d. Tuning the parameters of a
machine learning model with a validation set e. Importance of understanding
what a model is doing, where its pitfalls/shortcomings are, and the
implications of its decisions 8\\. Basic neural networks a. Fundamentals of
understanding how neural networks work and their training process, without
details of the calculations b. Basic introduction to generative neural
networks (e.g., large language models) 9\\. Ethics for Machine Learning (See
also: SEP-Context) a. Focus on real data, real scenarios, and case studies b.
Dataset/algorithmic/evaluation bias and unintended consequences 72 KA Core:
10\\. Formulation of simple machine learning as an optimization problem, such
as least squares linear regression or logistic regression a. Objective
function b. Gradient descent c. Regularization to avoid overfitting
(mathematical formulation) 11\\. Ensembles of models a. Simple weighted
majority combination 12\\. Deep learning a. Deep feed-forward networks
(intuition only, no mathematics) b. Convolutional neural networks (intuition
only, no mathematics) c. Visualization of learned feature representations from
deep nets d. Other architectures (generative NN, recurrent NN, transformers,
etc.) 13\\. Performance evaluation a. Other metrics for classification (e.g.,
error, precision, recall) b. Performance metrics for regressors c. Confusion
matrix d. Cross-validation i. Parameter tuning (grid/random search, via cross-
validation) 14\\. Overview of reinforcement learning methods 15\\. Two or more
applications of machine learning algorithms a. E.g., medicine and health,
economics, vision, natural language, robotics, game play 16\\. Ethics for
Machine Learning a. Continued focus on real data, real scenarios, and case
studies (See also: SEP-Context) b. Privacy (See also: SEP-Privacy) c. Fairness
(See also: SEP-Privacy) d. Intellectual property e. Explainability Non-core:
17\\. General statistical-based learning, parameter estimation (maximum
likelihood) 18\\. Supervised learning a. Decision trees b. Nearest-neighbor
classification and regression c. Learning simple neural networks / multi-layer
perceptrons d. Linear regression e. Logistic regression f. Support vector
machines (SVMs) and kernels g. Gaussian Processes 19\\. Overfitting a. The
curse of dimensionality b. Regularization (mathematical computations, L2 and
L1 regularization) 20\\. Experimental design 73 a. Data preparation (e.g.,
standardization, representation, one-hot encoding) b. Hypothesis space c.
Biases (e.g., algorithmic, search) d. Partitioning data: stratification,
training set, validation set, test set e. Parameter tuning (grid/random
search, via cross-validation) f. Performance evaluation i. Cross-validation
ii. Metric: error, precision, recall, confusion matrix iii. Receiver operating
characteristic (ROC) curve and area under ROC curve 21\\. Bayesian learning
(Cross-Reference AI/Reasoning Under Uncertainty) a. Naive Bayes and its
relationship to linear models b. Bayesian networks c. Prior/posterior d.
Generative models 22\\. Deep learning a. Deep feed-forward networks b. Neural
tangent kernel and understanding neural network training c. Convolutional
neural networks d. Autoencoders e. Recurrent networks f. Representations and
knowledge transfer g. Adversarial training and generative adversarial networks
h. Attention mechanisms 23\\. Representations a. Manually crafted
representations b. Basis expansion c. Learned representations (e.g., deep
neural networks) 24\\. Unsupervised learning and clustering a. K-means b.
Gaussian mixture models c. Expectation maximization (EM) d. Self-organizing
maps 25\\. Graph analysis (e.g., PageRank) 26\\. Semi-supervised learning 27\\.
Graphical models (See also: AI-Probability) 28\\. Ensembles a. Weighted
majority b. Boosting/bagging c. Random forest d. Gated ensemble 29\\. Learning
theory a. General overview of learning theory / why learning works b. VC
dimension c. Generalization bounds 74 30\\. Reinforcement learning a.
Exploration vs exploitation tradeoff b. Markov decision processes c. Value and
policy iteration d. Policy gradient methods e. Deep reinforcement learning f.
Learning from demonstration and inverse RL 31\\. Explainable / interpretable
machine learning a. Understanding feature importance (e.g., LIME, Shapley
values) b. Interpretable models and representations 32\\. Recommender systems
33\\. Hardware for machine learning a. GPUs / TPUs 34\\. Application of machine
learning algorithms to: a. Medicine and health b. Economics c. Education d.
Vision e. Natural language f. Robotics g. Game play h. Data mining (Cross-
reference DM/Data Analytics) 35\\. Ethics for Machine Learning a. Continued
focus on real data, real scenarios, and case studies (See also: SEP-Context)
b. In depth exploration of dataset/algorithmic/evaluation bias, data privacy,
and fairness (See also: SEP-Privacy, SEP-Context) c. Trust / explainability
Illustrative Learning Outcomes: 1\\. Describe the differences among the three
main styles of learning (supervised, reinforcement, and unsupervised) and
determine which is appropriate to a particular problem domain. 2\\.
Differentiate the terms of AI, machine learning, and deep learning. 3\\. Frame
an application as a classification problem, including the available input
features and output to be predicted (e.g., identifying alphabetic characters
from pixel grid input). 4\\. Apply two or more simple statistical learning
algorithms to a classification task and measure the classifiers' accuracy. 5\\.
Identify overfitting in the context of a problem and learning curves and
describe solutions to overfitting. 6\\. Explain how machine learning works as
an optimization/search process. 7\\. Implement a statistical learning algorithm
and the corresponding optimization process to train the classifier and obtain
a prediction on new data. 8\\. Describe the neural network training process and
resulting learned representations. 75 9\\. Explain proper ML evaluation
procedures, including the differences between training and testing
performance, and what can go wrong with the evaluation process leading to
inaccurate reporting of ML performance. 10\\. Compare two machine learning
algorithms on a dataset, implementing the data preprocessing and evaluation
methodology (e.g., metrics and handling of train/test splits) from scratch.
11\\. Visualize the training progress of a neural network through learning
curves in a well-established toolkit (e.g., TensorBoard) and visualize the
learned features of the network. 12\\. Compare and contrast several learning
techniques (e.g., decision trees, logistic regression, naive Bayes, neural
networks, and belief networks), providing examples of when each strategy is
superior. 13\\. Evaluate the performance of a simple learning system on a real-
world dataset. 14\\. Characterize the state of the art in learning theory,
including its achievements and shortcomings. 15\\. Explain the problem of
overfitting, along with techniques for detecting and managing the problem.
16\\. Explain the triple tradeoff among the size of a hypothesis space, the
size of the training set, and performance accuracy. 17\\. Given a real-world
application of machine learning, describe ethical issues regarding the choices
of data, preprocessing steps, algorithm selection, and
visualization/presentation of results"""^^xsd:string ;
            ns2:score "0.65111214"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as machine learning, supervised and unsupervised learning, neural networks, and ethics. The lecture also provides practical examples and illustrations, which align with the KU's emphasis on real-world applications." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-ML_Machine_Learning" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.6692901"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on professional roles/entrepreneurship, not intellectual property, plagiarism, or programmer ethics." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns2:score "0.654318"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional opening and entrepreneurship, whereas the KU covers SE-Testing and Quality Assurance, which are unrelated topics." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Testing_and_Quality_Assurance" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.6692901"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional integration and general ethics but does not cover intellectual property, plagiarism, or specific programmer responsibilities as outlined in the KU." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ] ;
    ns2:uetext """Label: Ouverture professionnelle - Informatique Objectif: (résultats d'apprentissage) - étudié une structure en particulier, en lien avec son projet professionnel
- par le biais d’un jeu de rôle, pris conscience du rôle des différents services (RH, marketing,
commercial,…) d’une structure dans le développement et le déploiement d’un projet
- connaissance de ses droits et devoirs en tant que stagiaire et aura travaillé sur sa manière de
s’intégrer et de s’adapter dans un nouveau milieu professionnel
- connaissance de ce qu’est l’entreprenariat et des dispositifs en lien à l’université Course content: 4h00 : TD 4 : Simulations d’entretiens en sous-groupes autonomes et présentation du pitch
(évaluation).
4h00 : TD 5 : Les différentes structures et organisations possibles dans le monde du travail / Droits
et devoirs du stagiaire.
1h20 : TD 6 : L’après licence : en sous-groupes, argumentation de ses perspectives post-licence. Course name: http://example.org/course/UE_X31T060""" .

ns3:UE_X32A060 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Constructs_Advanced_Programming_Constructs.txt> ;
            ns2:ku_text """Pages: 144 HOURS CS Core = 0 KA Core = 0 FPL-Constructs: Advanced Programming
Constructs Non-core: 1\\. Encapsulation mechanisms 2\\. Delayed evaluation and
infinite streams 3\\. Compare and contrast delayed evaluation vs eager
evaluation 4\\. Unification vs assertion vs expression evaluation 5\\. Control
abstractions: exception handling, continuations, monads. 6\\. Object-oriented
abstractions: multiple inheritance, mixins, traits, multimethods 7\\.
Metaprogramming: macros, generative programming, model-based development 8\\.
String manipulation via pattern-matching (regular expressions) 9\\. Dynamic
code evaluation ("eval") 10\\. Language support for checking assertions,
invariants, and pre/post-conditions 11\\. Domain specific languages, such as
database languages, data science languages, embedded computing languages,
synchronous languages, hardware interface languages 12\\. Massive parallel high
performance computing models and languages Illustrative learning outcomes:
Non-core: 1\\. Use various advanced programming constructs and idioms
correctly. 2\\. Discuss how various advanced programming constructs aim to
improve program structure, software quality, and programmer productivity. 3\\.
Discuss how various advanced programming constructs interact with the
definition and implementation of other language features."""^^xsd:string ;
            ns2:score "0.6455945"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover any of the advanced programming constructs listed in the KU, and its focus is on English language skills and presentation techniques." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Constructs_Advanced_Programming_Constructs" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6445035"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional English and presentation skills, while the KU covers technical aspects of development platforms in computer science. There is no overlap in content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Constructs_Advanced_Programming_Constructs.txt> ;
            ns2:ku_text """Pages: 144 HOURS CS Core = 0 KA Core = 0 FPL-Constructs: Advanced Programming
Constructs Non-core: 1\\. Encapsulation mechanisms 2\\. Delayed evaluation and
infinite streams 3\\. Compare and contrast delayed evaluation vs eager
evaluation 4\\. Unification vs assertion vs expression evaluation 5\\. Control
abstractions: exception handling, continuations, monads. 6\\. Object-oriented
abstractions: multiple inheritance, mixins, traits, multimethods 7\\.
Metaprogramming: macros, generative programming, model-based development 8\\.
String manipulation via pattern-matching (regular expressions) 9\\. Dynamic
code evaluation ("eval") 10\\. Language support for checking assertions,
invariants, and pre/post-conditions 11\\. Domain specific languages, such as
database languages, data science languages, embedded computing languages,
synchronous languages, hardware interface languages 12\\. Massive parallel high
performance computing models and languages Illustrative learning outcomes:
Non-core: 1\\. Use various advanced programming constructs and idioms
correctly. 2\\. Discuss how various advanced programming constructs aim to
improve program structure, software quality, and programmer productivity. 3\\.
Discuss how various advanced programming constructs interact with the
definition and implementation of other language features."""^^xsd:string ;
            ns2:score "0.6455945"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap; lecture focuses on language skills while KU covers advanced programming constructs" ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Constructs_Advanced_Programming_Constructs" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6445035"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on language skills, not technical CS platform/programming topics" ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6445035"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional English for IT, while the KU covers computer science development platforms, programming languages, and constraints, with no apparent overlap." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.63936734"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap; lecture focuses on English communication skills, while KU addresses programming language design and accessibility." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.63936734"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional English and presentation skills, while the KU covers programming language ethics and accessibility." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.63936734"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on presentation skills and vocabulary in English for IT professionals, whereas the KU covers a broader range of topics, including programming languages, accessibility, and ethics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.63936734"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap; lecture focuses on English communication skills, while KU addresses programming language design and accessibility." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6445035"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on language skills, not technical CS platform/programming topics" ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.63936734"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on presentation skills and vocabulary in English for IT professionals, whereas the KU covers a broader range of topics, including programming languages, accessibility, and ethics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6445035"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional English for IT, while the KU covers computer science development platforms, programming languages, and constraints, with no apparent overlap." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Constructs_Advanced_Programming_Constructs.txt> ;
            ns2:ku_text """Pages: 144 HOURS CS Core = 0 KA Core = 0 FPL-Constructs: Advanced Programming
Constructs Non-core: 1\\. Encapsulation mechanisms 2\\. Delayed evaluation and
infinite streams 3\\. Compare and contrast delayed evaluation vs eager
evaluation 4\\. Unification vs assertion vs expression evaluation 5\\. Control
abstractions: exception handling, continuations, monads. 6\\. Object-oriented
abstractions: multiple inheritance, mixins, traits, multimethods 7\\.
Metaprogramming: macros, generative programming, model-based development 8\\.
String manipulation via pattern-matching (regular expressions) 9\\. Dynamic
code evaluation ("eval") 10\\. Language support for checking assertions,
invariants, and pre/post-conditions 11\\. Domain specific languages, such as
database languages, data science languages, embedded computing languages,
synchronous languages, hardware interface languages 12\\. Massive parallel high
performance computing models and languages Illustrative learning outcomes:
Non-core: 1\\. Use various advanced programming constructs and idioms
correctly. 2\\. Discuss how various advanced programming constructs aim to
improve program structure, software quality, and programmer productivity. 3\\.
Discuss how various advanced programming constructs interact with the
definition and implementation of other language features."""^^xsd:string ;
            ns2:score "0.6455945"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional English and presentation skills, while the KU covers advanced programming constructs, with no overlap in content." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Constructs_Advanced_Programming_Constructs" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6445035"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional English and presentation skills, while the KU covers technical aspects of development platforms in computer science. There is no overlap in content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Constructs_Advanced_Programming_Constructs.txt> ;
            ns2:ku_text """Pages: 144 HOURS CS Core = 0 KA Core = 0 FPL-Constructs: Advanced Programming
Constructs Non-core: 1\\. Encapsulation mechanisms 2\\. Delayed evaluation and
infinite streams 3\\. Compare and contrast delayed evaluation vs eager
evaluation 4\\. Unification vs assertion vs expression evaluation 5\\. Control
abstractions: exception handling, continuations, monads. 6\\. Object-oriented
abstractions: multiple inheritance, mixins, traits, multimethods 7\\.
Metaprogramming: macros, generative programming, model-based development 8\\.
String manipulation via pattern-matching (regular expressions) 9\\. Dynamic
code evaluation ("eval") 10\\. Language support for checking assertions,
invariants, and pre/post-conditions 11\\. Domain specific languages, such as
database languages, data science languages, embedded computing languages,
synchronous languages, hardware interface languages 12\\. Massive parallel high
performance computing models and languages Illustrative learning outcomes:
Non-core: 1\\. Use various advanced programming constructs and idioms
correctly. 2\\. Discuss how various advanced programming constructs aim to
improve program structure, software quality, and programmer productivity. 3\\.
Discuss how various advanced programming constructs interact with the
definition and implementation of other language features."""^^xsd:string ;
            ns2:score "0.6455945"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap; lecture focuses on language skills while KU covers advanced programming constructs" ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Constructs_Advanced_Programming_Constructs" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Constructs_Advanced_Programming_Constructs.txt> ;
            ns2:ku_text """Pages: 144 HOURS CS Core = 0 KA Core = 0 FPL-Constructs: Advanced Programming
Constructs Non-core: 1\\. Encapsulation mechanisms 2\\. Delayed evaluation and
infinite streams 3\\. Compare and contrast delayed evaluation vs eager
evaluation 4\\. Unification vs assertion vs expression evaluation 5\\. Control
abstractions: exception handling, continuations, monads. 6\\. Object-oriented
abstractions: multiple inheritance, mixins, traits, multimethods 7\\.
Metaprogramming: macros, generative programming, model-based development 8\\.
String manipulation via pattern-matching (regular expressions) 9\\. Dynamic
code evaluation ("eval") 10\\. Language support for checking assertions,
invariants, and pre/post-conditions 11\\. Domain specific languages, such as
database languages, data science languages, embedded computing languages,
synchronous languages, hardware interface languages 12\\. Massive parallel high
performance computing models and languages Illustrative learning outcomes:
Non-core: 1\\. Use various advanced programming constructs and idioms
correctly. 2\\. Discuss how various advanced programming constructs aim to
improve program structure, software quality, and programmer productivity. 3\\.
Discuss how various advanced programming constructs interact with the
definition and implementation of other language features."""^^xsd:string ;
            ns2:score "0.6455945"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover any of the advanced programming constructs listed in the KU, and its focus is on English language skills and presentation techniques." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Constructs_Advanced_Programming_Constructs" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages: 147 HOURS CS Core = SEP hours KA Core = SEP hours FPL-SEP: Society,
Ethics, and the Profession Non-core: 1\\. Impact of English-centric programming
languages 2\\. Enhancing accessibility and inclusivity for people with
disabilities - Supporting assistive technologies 3\\. Human factors related to
programming languages and usability a. Impact of syntax on accessibility b.
Supporting cultural differences (e.g., currency, decimals, dates) c.
Neurodiversity 4\\. Etymology of terms such as "class," "master," and "slave"
in programming languages 5\\. Increasing accessibility by supporting multiple
languages within applications (UTF) Illustrative learning outcomes: Non-core:
1\\. Consciously design programming languages to be inclusive and non-
offensive."""^^xsd:string ;
            ns2:score "0.63936734"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional English and presentation skills, while the KU covers programming language ethics and accessibility." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-SEP_Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Constructs_Advanced_Programming_Constructs.txt> ;
            ns2:ku_text """Pages: 144 HOURS CS Core = 0 KA Core = 0 FPL-Constructs: Advanced Programming
Constructs Non-core: 1\\. Encapsulation mechanisms 2\\. Delayed evaluation and
infinite streams 3\\. Compare and contrast delayed evaluation vs eager
evaluation 4\\. Unification vs assertion vs expression evaluation 5\\. Control
abstractions: exception handling, continuations, monads. 6\\. Object-oriented
abstractions: multiple inheritance, mixins, traits, multimethods 7\\.
Metaprogramming: macros, generative programming, model-based development 8\\.
String manipulation via pattern-matching (regular expressions) 9\\. Dynamic
code evaluation ("eval") 10\\. Language support for checking assertions,
invariants, and pre/post-conditions 11\\. Domain specific languages, such as
database languages, data science languages, embedded computing languages,
synchronous languages, hardware interface languages 12\\. Massive parallel high
performance computing models and languages Illustrative learning outcomes:
Non-core: 1\\. Use various advanced programming constructs and idioms
correctly. 2\\. Discuss how various advanced programming constructs aim to
improve program structure, software quality, and programmer productivity. 3\\.
Discuss how various advanced programming constructs interact with the
definition and implementation of other language features."""^^xsd:string ;
            ns2:score "0.6455945"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on professional English and presentation skills, while the KU covers advanced programming constructs, with no overlap in content." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Constructs_Advanced_Programming_Constructs" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ] ;
    ns2:uetext """Label: Anglais Professionnel Informatique Objectif: (résultats d'apprentissage) 3. faire une présentation orale s’appuyant sur le travail de groupe préparé dans le rapport écrit, en
s’exprimant dans un anglais clair et phonologiquement approprié et en communiquant avec un
degré d’aisance et de spontanéité qui rende possible une interaction normale avec un locuteur natif,
sans recours excessif aux notes
4. utiliser des outils de présentation adaptés à la situation de communication
5. répondre à des questions de compréhension sur des documents audio authentiques
1. Développement du vocabulaire utilisé en anglais professionnel (vocabulaire susceptible d’être
utilisé dans les tests TOEIC)
2. Discussion des spécificités des CV aux États-Unis et en Grande-Bretagne
3. Contenu d’une lettre de motivation Course content: d’une lettre de motivation Course name: http://example.org/course/UE_X32A060""" .

ns3:UE_X32I010 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt> ;
            ns2:ku_text """Pages: 130-131 HOURS CS Core = 4 + 1 (SDF) KA Core = 1 FPL-OOP: Object-
Oriented Programming CS Core: 1\\. Imperative programming as a subset of
object-oriented programming. 2\\. Object-oriented design: a. Decomposition into
objects carrying state and having behavior. b. Class-hierarchy design for
modeling. 3\\. Definition of classes: fields, methods, and constructors. (See
also: SDF-Fundamentals) 4\\. Subclasses, inheritance (including multiple
inheritance), and method overriding. 5\\. Dynamic dispatch: definition of
method-call. 6\\. Exception handling. (See also: SDF-Fundamentals, PDC-
Coordination, SE-Construction) 7\\. Object-oriented idioms for encapsulation:
a. Privacy, data hiding, and visibility of class members. b. Interfaces
revealing only method signatures. c. Abstract base classes, traits and mixins.
8\\. Dynamic vs static properties. 9\\. Composition vs inheritance. 10\\.
Subtyping: a. Subtype polymorphism; implicit upcasts in typed languages. b.
Notion of behavioral replacement: subtypes acting like supertype. c.
Relationship between subtyping and inheritance. KA Core: 11\\. Collection
classes, iterators, and other common library components. 12\\. Metaprogramming
and reflection. Illustrative Learning Outcomes: CS Core: 1\\. Enumerate the
differences between imperative and object-oriented programming paradigms. 2\\.
Compose a class through design, implementation, and testing to meet behavioral
requirements. 3\\. Build a simple class hierarchy utilizing subclassing that
allows code to be reused for distinct subclasses. 4\\. Predict and validate
control flow in a program using dynamic dispatch. 5\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 6\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. 7\\. Compare and contrast the benefits and costs/impact of using
inheritance (subclasses) and composition (specifically, how to base
composition on higher order functions). 8\\. Explain the relationship between
object-oriented inheritance (code-sharing and overriding) and subtyping (the
idea of a subtype being usable in a context that expects the supertype). 9\\.
Use object-oriented encapsulation mechanisms such as interfaces and private
members. 10\\. Define and use iterators and other operations on aggregates,
including operations that take functions as arguments, in multiple programming
languages, selecting the most natural idioms for each language. (See also:
FPL-Functional) KA Core: 11\\. Use collection classes and iterators effectively
to solve a problem."""^^xsd:string ;
            ns2:score "0.67110866"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental concepts of object-oriented programming, including classes, inheritance, polymorphism, and encapsulation, which aligns with the knowledge unit's objectives." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-OOP_Object-Oriented_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt> ;
            ns2:ku_text """Pages: 130-131 HOURS CS Core = 4 + 1 (SDF) KA Core = 1 FPL-OOP: Object-
Oriented Programming CS Core: 1\\. Imperative programming as a subset of
object-oriented programming. 2\\. Object-oriented design: a. Decomposition into
objects carrying state and having behavior. b. Class-hierarchy design for
modeling. 3\\. Definition of classes: fields, methods, and constructors. (See
also: SDF-Fundamentals) 4\\. Subclasses, inheritance (including multiple
inheritance), and method overriding. 5\\. Dynamic dispatch: definition of
method-call. 6\\. Exception handling. (See also: SDF-Fundamentals, PDC-
Coordination, SE-Construction) 7\\. Object-oriented idioms for encapsulation:
a. Privacy, data hiding, and visibility of class members. b. Interfaces
revealing only method signatures. c. Abstract base classes, traits and mixins.
8\\. Dynamic vs static properties. 9\\. Composition vs inheritance. 10\\.
Subtyping: a. Subtype polymorphism; implicit upcasts in typed languages. b.
Notion of behavioral replacement: subtypes acting like supertype. c.
Relationship between subtyping and inheritance. KA Core: 11\\. Collection
classes, iterators, and other common library components. 12\\. Metaprogramming
and reflection. Illustrative Learning Outcomes: CS Core: 1\\. Enumerate the
differences between imperative and object-oriented programming paradigms. 2\\.
Compose a class through design, implementation, and testing to meet behavioral
requirements. 3\\. Build a simple class hierarchy utilizing subclassing that
allows code to be reused for distinct subclasses. 4\\. Predict and validate
control flow in a program using dynamic dispatch. 5\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 6\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. 7\\. Compare and contrast the benefits and costs/impact of using
inheritance (subclasses) and composition (specifically, how to base
composition on higher order functions). 8\\. Explain the relationship between
object-oriented inheritance (code-sharing and overriding) and subtyping (the
idea of a subtype being usable in a context that expects the supertype). 9\\.
Use object-oriented encapsulation mechanisms such as interfaces and private
members. 10\\. Define and use iterators and other operations on aggregates,
including operations that take functions as arguments, in multiple programming
languages, selecting the most natural idioms for each language. (See also:
FPL-Functional) KA Core: 11\\. Use collection classes and iterators effectively
to solve a problem."""^^xsd:string ;
            ns2:score "0.67110866"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on theoretical CS (decidability, recursion), while KU addresses object-oriented programming concepts, which are unrelated." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-OOP_Object-Oriented_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns2:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns2:score "0.680581"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental concepts of functional programming, including lambda expressions, recursion, and higher-order functions, which aligns with the KU's objectives." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Functional_Functional_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns2:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns2:score "0.680581"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers foundational concepts but lacks depth in functional programming specifics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Functional_Functional_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt> ;
            ns2:ku_text """Pages: 130-131 HOURS CS Core = 4 + 1 (SDF) KA Core = 1 FPL-OOP: Object-
Oriented Programming CS Core: 1\\. Imperative programming as a subset of
object-oriented programming. 2\\. Object-oriented design: a. Decomposition into
objects carrying state and having behavior. b. Class-hierarchy design for
modeling. 3\\. Definition of classes: fields, methods, and constructors. (See
also: SDF-Fundamentals) 4\\. Subclasses, inheritance (including multiple
inheritance), and method overriding. 5\\. Dynamic dispatch: definition of
method-call. 6\\. Exception handling. (See also: SDF-Fundamentals, PDC-
Coordination, SE-Construction) 7\\. Object-oriented idioms for encapsulation:
a. Privacy, data hiding, and visibility of class members. b. Interfaces
revealing only method signatures. c. Abstract base classes, traits and mixins.
8\\. Dynamic vs static properties. 9\\. Composition vs inheritance. 10\\.
Subtyping: a. Subtype polymorphism; implicit upcasts in typed languages. b.
Notion of behavioral replacement: subtypes acting like supertype. c.
Relationship between subtyping and inheritance. KA Core: 11\\. Collection
classes, iterators, and other common library components. 12\\. Metaprogramming
and reflection. Illustrative Learning Outcomes: CS Core: 1\\. Enumerate the
differences between imperative and object-oriented programming paradigms. 2\\.
Compose a class through design, implementation, and testing to meet behavioral
requirements. 3\\. Build a simple class hierarchy utilizing subclassing that
allows code to be reused for distinct subclasses. 4\\. Predict and validate
control flow in a program using dynamic dispatch. 5\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 6\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. 7\\. Compare and contrast the benefits and costs/impact of using
inheritance (subclasses) and composition (specifically, how to base
composition on higher order functions). 8\\. Explain the relationship between
object-oriented inheritance (code-sharing and overriding) and subtyping (the
idea of a subtype being usable in a context that expects the supertype). 9\\.
Use object-oriented encapsulation mechanisms such as interfaces and private
members. 10\\. Define and use iterators and other operations on aggregates,
including operations that take functions as arguments, in multiple programming
languages, selecting the most natural idioms for each language. (See also:
FPL-Functional) KA Core: 11\\. Use collection classes and iterators effectively
to solve a problem."""^^xsd:string ;
            ns2:score "0.67110866"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on theoretical computer science topics, while the KU covers object-oriented programming concepts." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-OOP_Object-Oriented_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.67663896"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers unification, recursion, induction, and logic program structures (e.g., Horn clauses) aligned with KU core topics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.67663896"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some related topics like unification and recursive functions, but misses several key KU areas such as quantifiers, Horn clauses, and logic programming constructs." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns2:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns2:score "0.680581"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on decidability, recursion, induction, and unification, while KU emphasizes functional programming concepts like closures, higher-order functions, and evaluation strategies not explicitly covered." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Functional_Functional_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns2:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns2:score "0.680581"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental concepts of functional programming, including lambda expressions, recursion, and higher-order functions, which aligns with the KU's objectives." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Functional_Functional_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.67663896"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some related topics like unification and recursive functions, but misses several key KU areas such as quantifiers, Horn clauses, and logic programming constructs." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt> ;
            ns2:ku_text """Pages: 130-131 HOURS CS Core = 4 + 1 (SDF) KA Core = 1 FPL-OOP: Object-
Oriented Programming CS Core: 1\\. Imperative programming as a subset of
object-oriented programming. 2\\. Object-oriented design: a. Decomposition into
objects carrying state and having behavior. b. Class-hierarchy design for
modeling. 3\\. Definition of classes: fields, methods, and constructors. (See
also: SDF-Fundamentals) 4\\. Subclasses, inheritance (including multiple
inheritance), and method overriding. 5\\. Dynamic dispatch: definition of
method-call. 6\\. Exception handling. (See also: SDF-Fundamentals, PDC-
Coordination, SE-Construction) 7\\. Object-oriented idioms for encapsulation:
a. Privacy, data hiding, and visibility of class members. b. Interfaces
revealing only method signatures. c. Abstract base classes, traits and mixins.
8\\. Dynamic vs static properties. 9\\. Composition vs inheritance. 10\\.
Subtyping: a. Subtype polymorphism; implicit upcasts in typed languages. b.
Notion of behavioral replacement: subtypes acting like supertype. c.
Relationship between subtyping and inheritance. KA Core: 11\\. Collection
classes, iterators, and other common library components. 12\\. Metaprogramming
and reflection. Illustrative Learning Outcomes: CS Core: 1\\. Enumerate the
differences between imperative and object-oriented programming paradigms. 2\\.
Compose a class through design, implementation, and testing to meet behavioral
requirements. 3\\. Build a simple class hierarchy utilizing subclassing that
allows code to be reused for distinct subclasses. 4\\. Predict and validate
control flow in a program using dynamic dispatch. 5\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 6\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. 7\\. Compare and contrast the benefits and costs/impact of using
inheritance (subclasses) and composition (specifically, how to base
composition on higher order functions). 8\\. Explain the relationship between
object-oriented inheritance (code-sharing and overriding) and subtyping (the
idea of a subtype being usable in a context that expects the supertype). 9\\.
Use object-oriented encapsulation mechanisms such as interfaces and private
members. 10\\. Define and use iterators and other operations on aggregates,
including operations that take functions as arguments, in multiple programming
languages, selecting the most natural idioms for each language. (See also:
FPL-Functional) KA Core: 11\\. Use collection classes and iterators effectively
to solve a problem."""^^xsd:string ;
            ns2:score "0.67110866"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on theoretical computer science topics, while the KU covers object-oriented programming concepts." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-OOP_Object-Oriented_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.67663896"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including Godel's enumeration, recursive functions, and logical programming concepts, indicating a substantial coverage of the KU." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.67663896"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including Godel's enumeration, recursive functions, and logical programming concepts, indicating a substantial coverage of the KU." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns2:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns2:score "0.680581"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers foundational concepts but lacks depth in functional programming specifics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Functional_Functional_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.67663896"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers unification, recursion, induction, and logic program structures (e.g., Horn clauses) aligned with KU core topics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns2:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns2:score "0.680581"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on decidability, recursion, induction, and unification, while KU emphasizes functional programming concepts like closures, higher-order functions, and evaluation strategies not explicitly covered." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Functional_Functional_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt> ;
            ns2:ku_text """Pages: 130-131 HOURS CS Core = 4 + 1 (SDF) KA Core = 1 FPL-OOP: Object-
Oriented Programming CS Core: 1\\. Imperative programming as a subset of
object-oriented programming. 2\\. Object-oriented design: a. Decomposition into
objects carrying state and having behavior. b. Class-hierarchy design for
modeling. 3\\. Definition of classes: fields, methods, and constructors. (See
also: SDF-Fundamentals) 4\\. Subclasses, inheritance (including multiple
inheritance), and method overriding. 5\\. Dynamic dispatch: definition of
method-call. 6\\. Exception handling. (See also: SDF-Fundamentals, PDC-
Coordination, SE-Construction) 7\\. Object-oriented idioms for encapsulation:
a. Privacy, data hiding, and visibility of class members. b. Interfaces
revealing only method signatures. c. Abstract base classes, traits and mixins.
8\\. Dynamic vs static properties. 9\\. Composition vs inheritance. 10\\.
Subtyping: a. Subtype polymorphism; implicit upcasts in typed languages. b.
Notion of behavioral replacement: subtypes acting like supertype. c.
Relationship between subtyping and inheritance. KA Core: 11\\. Collection
classes, iterators, and other common library components. 12\\. Metaprogramming
and reflection. Illustrative Learning Outcomes: CS Core: 1\\. Enumerate the
differences between imperative and object-oriented programming paradigms. 2\\.
Compose a class through design, implementation, and testing to meet behavioral
requirements. 3\\. Build a simple class hierarchy utilizing subclassing that
allows code to be reused for distinct subclasses. 4\\. Predict and validate
control flow in a program using dynamic dispatch. 5\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 6\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. 7\\. Compare and contrast the benefits and costs/impact of using
inheritance (subclasses) and composition (specifically, how to base
composition on higher order functions). 8\\. Explain the relationship between
object-oriented inheritance (code-sharing and overriding) and subtyping (the
idea of a subtype being usable in a context that expects the supertype). 9\\.
Use object-oriented encapsulation mechanisms such as interfaces and private
members. 10\\. Define and use iterators and other operations on aggregates,
including operations that take functions as arguments, in multiple programming
languages, selecting the most natural idioms for each language. (See also:
FPL-Functional) KA Core: 11\\. Use collection classes and iterators effectively
to solve a problem."""^^xsd:string ;
            ns2:score "0.67110866"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the fundamental concepts of object-oriented programming, including classes, inheritance, polymorphism, and encapsulation, which aligns with the knowledge unit's objectives." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-OOP_Object-Oriented_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt> ;
            ns2:ku_text """Pages: 130-131 HOURS CS Core = 4 + 1 (SDF) KA Core = 1 FPL-OOP: Object-
Oriented Programming CS Core: 1\\. Imperative programming as a subset of
object-oriented programming. 2\\. Object-oriented design: a. Decomposition into
objects carrying state and having behavior. b. Class-hierarchy design for
modeling. 3\\. Definition of classes: fields, methods, and constructors. (See
also: SDF-Fundamentals) 4\\. Subclasses, inheritance (including multiple
inheritance), and method overriding. 5\\. Dynamic dispatch: definition of
method-call. 6\\. Exception handling. (See also: SDF-Fundamentals, PDC-
Coordination, SE-Construction) 7\\. Object-oriented idioms for encapsulation:
a. Privacy, data hiding, and visibility of class members. b. Interfaces
revealing only method signatures. c. Abstract base classes, traits and mixins.
8\\. Dynamic vs static properties. 9\\. Composition vs inheritance. 10\\.
Subtyping: a. Subtype polymorphism; implicit upcasts in typed languages. b.
Notion of behavioral replacement: subtypes acting like supertype. c.
Relationship between subtyping and inheritance. KA Core: 11\\. Collection
classes, iterators, and other common library components. 12\\. Metaprogramming
and reflection. Illustrative Learning Outcomes: CS Core: 1\\. Enumerate the
differences between imperative and object-oriented programming paradigms. 2\\.
Compose a class through design, implementation, and testing to meet behavioral
requirements. 3\\. Build a simple class hierarchy utilizing subclassing that
allows code to be reused for distinct subclasses. 4\\. Predict and validate
control flow in a program using dynamic dispatch. 5\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 6\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. 7\\. Compare and contrast the benefits and costs/impact of using
inheritance (subclasses) and composition (specifically, how to base
composition on higher order functions). 8\\. Explain the relationship between
object-oriented inheritance (code-sharing and overriding) and subtyping (the
idea of a subtype being usable in a context that expects the supertype). 9\\.
Use object-oriented encapsulation mechanisms such as interfaces and private
members. 10\\. Define and use iterators and other operations on aggregates,
including operations that take functions as arguments, in multiple programming
languages, selecting the most natural idioms for each language. (See also:
FPL-Functional) KA Core: 11\\. Use collection classes and iterators effectively
to solve a problem."""^^xsd:string ;
            ns2:score "0.67110866"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on theoretical CS (decidability, recursion), while KU addresses object-oriented programming concepts, which are unrelated." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-OOP_Object-Oriented_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ] ;
    ns2:uetext """Label: Informatique Fondamentale 2 Objectif: (résultats d'apprentissage) - distinguer un problème décidable d'un problème indécidable
- comprendre la résolution de problèmes par réduction
- comprendre la construction des fonctions et prédicats récursifs primitifs
- savoir faire une preuve par induction
- savoir construire des objets inductivement
- savoir construire des termes, les manipuler, et les transformer
- comprendre le mécanisme d'unification
- savoir ordonner des termes Course content: Énumérations de Godel. Fonctions récursives. Course name: http://example.org/course/UE_X32I010""" .

ns3:UE_X32I020 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.69681424"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on functional programming concepts, while the KU covers ethical and legal aspects of programming, with no overlap in content." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6917418"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap in topics; different focus areas." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6953278"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including universal vs existential quantifiers, first-order predicate logic, and unification algorithm, which are the core topics of the KU." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6953278"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on functional programming, while the KU covers logic programming topics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6917418"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on functional programming concepts and does not cover the formal methods topics described in the KU." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6917418"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, such as conceiving and employing higher-order functions, and explaining the mechanism of type inference, which aligns with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.69681424"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the topics of intellectual property rights, plagiarism, responsibility and liability, and professional work ethics, which are all part of the KU." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6917418"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, such as conceiving and employing higher-order functions, and explaining the mechanism of type inference, which aligns with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.69681424"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the topics of intellectual property rights, plagiarism, responsibility and liability, and professional work ethics, which are all part of the KU." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6953278"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on functional programming (higher-order functions, pattern matching, type inference), while KU emphasizes logic programming (Horn clauses, unification, Prolog concepts). Core topics don't overlap." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6917418"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on functional programming concepts and does not cover the formal methods topics described in the KU." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6917418"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap in topics; different focus areas." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6953278"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on functional programming (higher-order functions, pattern matching, type inference), while KU emphasizes logic programming (Horn clauses, unification, Prolog concepts). Core topics don't overlap." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.69681424"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on functional programming concepts, while the KU covers ethical and legal aspects of programming, with no overlap in content." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6953278"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including universal vs existential quantifiers, first-order predicate logic, and unification algorithm, which are the core topics of the KU." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.6953278"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on functional programming, while the KU covers logic programming topics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.69681424"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on functional programming techniques, while KU addresses professional ethics/legal responsibilities." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt> ;
            ns2:ku_text """Pages : 171 CS Core : None, KA Core : None (Hours here are included in
Society, Ethics and the Profession Area) CS Core: 1\\. Intellectual property
rights of programmers for programs they develop. 2\\. Plagiarism and academic
integrity. 3\\. Responsibility and liability of programmers regarding code they
develop for solutions. (See also: SEC-Foundations) 4\\. Basic professional work
ethics of programmers. Illustrative Learning Outcomes: CS Core: 1\\.
Explain/understand some of the intellectual property issues relating to
programs. 2\\. Explain/understand when code developed by others can be used and
proper ways of disclosing their use. 3\\. Explain/understand the responsibility
of programmers when developing code for an overall solution (which may be
developed by a team). 4\\. Explain/understand one or more codes of conduct
applicable to programmers."""^^xsd:string ;
            ns2:score "0.69681424"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on functional programming techniques, while KU addresses professional ethics/legal responsibilities." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Society_Ethics_and_the_Profession" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ] ;
    ns2:uetext """Label: Programmation fonctionnelle Objectif: (résultats d'apprentissage) •
concevoir et employer des fonctions d’ordre supérieure (Application) ;
•
employer la programmation par filtrage de motifs pour les traitements symboliques (Application) ;
• expliquer et savoir simuler le mécanisme d’inférence de type (Compréhension) ; Course content: • Course name: http://example.org/course/UE_X32I020""" .

ns3:UE_X32I030 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6306107"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on operational research and optimization, while the KU covers programming fundamentals, with no overlapping content." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6306107"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on optimization modeling and scheduling, while KU covers programming language abstractions/semantics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns2:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns2:score "0.6273762"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on operational research methods (scheduling, MIP solvers), while KU requires calculus fundamentals (derivatives, integrals, ODEs) not covered." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Calculus" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6306107"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on optimization modeling and scheduling, while KU covers programming language abstractions/semantics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns2:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns2:score "0.6273762"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on operational research methods (scheduling, MIP solvers), while KU requires calculus fundamentals (derivatives, integrals, ODEs) not covered." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Calculus" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns2:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns2:score "0.6273762"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as optimization, calculus, and problem-solving, which align with the learning outcomes described in the KU." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Calculus" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns2:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns2:score "0.6273762"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on operational research and optimization techniques, which only partially overlap with the calculus topics in the KU." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Calculus" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns2:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns2:score "0.6273762"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on operational research and optimization techniques, which only partially overlap with the calculus topics in the KU." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Calculus" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6225283"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as program abstraction, representation, and semantics, as well as data structures and control abstraction." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6225283"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on optimization modeling and scheduling, while KU covers programming language abstractions/semantics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6225283"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as program abstraction, representation, and semantics, as well as data structures and control abstraction." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6306107"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on operational research and optimization, while the KU covers programming fundamentals, with no overlapping content." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6306107"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as program abstraction, representation, and semantics, as well as data structures and control abstraction." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6225283"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on operational research and optimization, while the KU covers programming fundamentals, with no overlapping content." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6306107"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on operational research and optimization, while the KU covers programming fundamentals, with no overlapping content." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6225283"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as program abstraction, representation, and semantics, as well as data structures and control abstraction." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns2:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns2:score "0.6273762"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as optimization, calculus, and problem-solving, which align with the learning outcomes described in the KU." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Calculus" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6306107"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on optimization modeling and scheduling, while KU covers programming language abstractions/semantics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns2:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns2:score "0.6273762"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as optimization, calculus, and problem-solving, which align with the learning outcomes described in the KU." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Calculus" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6225283"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on operational research and optimization, while the KU covers programming fundamentals, with no overlapping content." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6306107"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as program abstraction, representation, and semantics, as well as data structures and control abstraction." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns2:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns2:score "0.6273762"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on operational research and optimization techniques, which only partially overlap with the calculus topics in the KU." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Calculus" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6306107"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as program abstraction, representation, and semantics, as well as data structures and control abstraction." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6225283"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on operational research and optimization, while the KU covers programming fundamentals, with no overlapping content." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6225283"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on optimization modeling and scheduling, while KU covers programming language abstractions/semantics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns2:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns2:score "0.6273762"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on operational research methods (scheduling, MIP solvers), while KU requires calculus fundamentals (derivatives, integrals, ODEs) not covered." ;
            ns3:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns3:ku "MSF-Calculus" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt> ;
            ns2:ku_text """Pages: 140-141 HOURS CS Core = 0 KA Core = 3 FPL-Abstraction: Program
Abstraction and Representation KA Core: 1\\. BNF and regular expressions 2\\.
Programs that take (other) programs as input such as interpreters, compilers,
type-checkers, documentation generators 3\\. Components of a language: a.
Definitions of alphabets, delimiters, sentences, syntax, and semantics b.
Syntax vs semantics 4\\. Program as a set of non-ambiguous meaningful sentences
5\\. Basic programming abstractions: constants, variables, declarations
(including nested declarations), command, expression, assignment, selection,
definite and indefinite iteration, iterators, function, procedure, modules,
exception handling (See also: SDF-Fundamentals) 6\\. Mutable vs immutable
variables: advantages and disadvantages of reusing existing memory location vs
advantages of copying and keeping old values; storing partial computation vs
recomputation 7\\. Types of variables: static, local, nonlocal, global; need
and issues with nonlocal and global variables. 8\\. Scope rules: static vs
dynamic; visibility of variables; side-effects. 9\\. Side-effects induced by
nonlocal variables, global variables and aliased variables. Non-core: 10\\.
L-values and R-values: mapping mutable variable-name to L-values; mapping
immutable variablenames to R-values 11\\. Environment vs store and their
properties 12\\. Data and control abstraction 13\\. Mechanisms for information
exchange between program units such as procedures, functions, and modules:
nonlocal variables, global variables, parameter-passing, import-export between
modules 14\\. Data structures to represent code for execution, translation, or
transmission. 15\\. Low level instruction representation such as virtual
machine instructions, assembly language, and binary representation (See also:
AR-Representation, AR-Assembly) 16\\. Lambda calculus, variable binding, and
variable renaming. (See also: AL-Models, FPL-Formalism) 17\\. Types of
semantics: operational, axiomatic, denotational, behavioral; define and use
abstract syntax trees; contrast with concrete syntax. Illustrative learning
outcomes: KA Core: 1\\. Illustrate the scope of variables and visibility using
simple programs. 2\\. Illustrate different types of parameter-passing using
simple pseudo programming language. 3\\. Explain side-effect using global and
nonlocal variables and how to fix such programs. 4\\. Explain how programs that
process other programs treat the other programs as their input data. 5\\.
Describe a grammar and an abstract syntax tree for a small language. 6\\.
Describe the benefits of having program representations other than strings of
source code. 7\\. Implement a program to process some representation of code
for some purpose, such as an interpreter, an expression optimizer, or a
documentation generator."""^^xsd:string ;
            ns2:score "0.6225283"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on optimization modeling and scheduling, while KU covers programming language abstractions/semantics." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Abstraction_Program_Abstraction_and_Representation" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ] ;
    ns2:uetext """Label: Recherche opérationnelle Objectif: (résultats d'apprentissage)
(A-M)
- Connaître les notions de calendrier au plus tôt, calendrier au plus tard pour un ensemble de
tâche, et la notion de marge d'une tâche dans le contexte d'un problème d'ordonnancement simple
(M)
- Etre capable de déterminer un calendrier au plus tôt, un calendrier au plus tard et les marges
des tâches, dans le contexte d'un problème d'ordonnancement simple (A)
- Introduction à la problématique de l'optimisation multi-objectif : connaissance de la notion de
solution efficace, limite de l'utilisation de la somme pondérée (I)
- Utilisation d'un langage de modélisation algébrique : comprendre la différence entre un modèle
explicite et un modèle implicite (I)
- Utilisation d'un langage de modélisation algébrique : être capable d'écrire un modèle implicite
(A)
- Utilisation d'un langage de modélisation algébrique : comprendre l'utilisation d'une structure de
matrice creuse pour décrire des contraintes (I)
- Utilisation d'un langage de modélisation algébrique : être capable d'utiliser une structure de
matrice creuse pour décrire des contraintes (A)
- Utilisation d'un langage de modélisation algébrique : être capable de détermine si le choix d'une
matrice creuse est pertinent ou pas pour décrire des contraintes (A)
- Utilisation d'un solveur MIP : comprendre l'utilisation d'un solveur MIP en tant que bibliothèque
de fonction et être capable de l'utiliser pour résoudre un unique problème de programmation
linéaire en variables mixtes (A)
- Utilisation d'un solveur MIP : être capable d'implémenter un algorithme donné, en faisant des
appels successifs à un solveur MIP pour résoudre un problème de programmation linéaire en
variables mixtes (A) Course content: fondamental :
- Course name: http://example.org/course/UE_X32I030""" .

ns3:UE_X32I040 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt> ;
            ns2:ku_text """Pages: 117-118 HOURS CS Core = 1 KA Core = 3 DM-Relational: Relational
Databases CS Core: 1\\. Entity and referential integrity: Candidate key,
superkeys 2\\. Relational database design KA Core: 3\\. Mapping conceptual
schema to a relational schema 4\\. Physical database design: file and storage
structures (See also: OS-Files) 5\\. Introduction to Functional dependency
theory 6\\. Normalization Theory a. Decomposition of a schema; lossless-join,
and dependency-preservation properties of a decomposition b. Normal forms
(BCNF) c. Denormalization (for efficiency) Non-core: 7\\. Functional dependency
theory a. Closure of a set of attributes b. Canonical Cover 8\\. Normalization
theory a. Multi-valued dependency (4NF) b. Join dependency (PJNF, 5NF) c.
Representation theory Illustrative Learning Outcomes: CS Core: 1\\. Describe
the defining characteristics behind the relational data model. 2\\. Comment on
the difference between a foreign key and a superkey. 3\\. Enumerate the
different types of integrity constraints. KA Core: 4\\. Compose a relational
schema from a conceptual schema which contains 1:1, 1:n, and n:m
relationships. 5\\. Map appropriate file structure to relations and indices.
6\\. Describe how functional dependency theory generalizes the notion of key.
7\\. Defend a given decomposition as lossless and or dependency preserving. 8\\.
Detect which normal form a given decomposition yields. 9\\. Comment on reasons
for denormalizing a relation."""^^xsd:string ;
            ns2:score "0.68290746"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including entity and referential integrity, relational database design, normalization theory, and functional dependency theory." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Relational_Relational_Databases" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.685809"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some related topics but lacks substantial coverage of the KU's core elements." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt> ;
            ns2:ku_text """Pages: 117-118 HOURS CS Core = 1 KA Core = 3 DM-Relational: Relational
Databases CS Core: 1\\. Entity and referential integrity: Candidate key,
superkeys 2\\. Relational database design KA Core: 3\\. Mapping conceptual
schema to a relational schema 4\\. Physical database design: file and storage
structures (See also: OS-Files) 5\\. Introduction to Functional dependency
theory 6\\. Normalization Theory a. Decomposition of a schema; lossless-join,
and dependency-preservation properties of a decomposition b. Normal forms
(BCNF) c. Denormalization (for efficiency) Non-core: 7\\. Functional dependency
theory a. Closure of a set of attributes b. Canonical Cover 8\\. Normalization
theory a. Multi-valued dependency (4NF) b. Join dependency (PJNF, 5NF) c.
Representation theory Illustrative Learning Outcomes: CS Core: 1\\. Describe
the defining characteristics behind the relational data model. 2\\. Comment on
the difference between a foreign key and a superkey. 3\\. Enumerate the
different types of integrity constraints. KA Core: 4\\. Compose a relational
schema from a conceptual schema which contains 1:1, 1:n, and n:m
relationships. 5\\. Map appropriate file structure to relations and indices.
6\\. Describe how functional dependency theory generalizes the notion of key.
7\\. Defend a given decomposition as lossless and or dependency preserving. 8\\.
Detect which normal form a given decomposition yields. 9\\. Comment on reasons
for denormalizing a relation."""^^xsd:string ;
            ns2:score "0.68290746"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including entity and referential integrity, relational database design, normalization theory, and functional dependency theory." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Relational_Relational_Databases" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.7250526"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers constraints, triggers, transactions, and querying basics (views, SQL extensions). Partial overlap with core SQL query operations." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt> ;
            ns2:ku_text """Pages: 117-118 HOURS CS Core = 1 KA Core = 3 DM-Relational: Relational
Databases CS Core: 1\\. Entity and referential integrity: Candidate key,
superkeys 2\\. Relational database design KA Core: 3\\. Mapping conceptual
schema to a relational schema 4\\. Physical database design: file and storage
structures (See also: OS-Files) 5\\. Introduction to Functional dependency
theory 6\\. Normalization Theory a. Decomposition of a schema; lossless-join,
and dependency-preservation properties of a decomposition b. Normal forms
(BCNF) c. Denormalization (for efficiency) Non-core: 7\\. Functional dependency
theory a. Closure of a set of attributes b. Canonical Cover 8\\. Normalization
theory a. Multi-valued dependency (4NF) b. Join dependency (PJNF, 5NF) c.
Representation theory Illustrative Learning Outcomes: CS Core: 1\\. Describe
the defining characteristics behind the relational data model. 2\\. Comment on
the difference between a foreign key and a superkey. 3\\. Enumerate the
different types of integrity constraints. KA Core: 4\\. Compose a relational
schema from a conceptual schema which contains 1:1, 1:n, and n:m
relationships. 5\\. Map appropriate file structure to relations and indices.
6\\. Describe how functional dependency theory generalizes the notion of key.
7\\. Defend a given decomposition as lossless and or dependency preserving. 8\\.
Detect which normal form a given decomposition yields. 9\\. Comment on reasons
for denormalizing a relation."""^^xsd:string ;
            ns2:score "0.68290746"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers core topics like integrity constraints, normalization (BCNF), physical structuring, transactions, and query optimization." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Relational_Relational_Databases" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.685809"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers constraints, triggers, transactions, and querying basics (views, SQL extensions). Partial overlap with core SQL query operations." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.7250526"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some related topics but lacks substantial coverage of the KU's core elements." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt> ;
            ns2:ku_text """Pages: 117-118 HOURS CS Core = 1 KA Core = 3 DM-Relational: Relational
Databases CS Core: 1\\. Entity and referential integrity: Candidate key,
superkeys 2\\. Relational database design KA Core: 3\\. Mapping conceptual
schema to a relational schema 4\\. Physical database design: file and storage
structures (See also: OS-Files) 5\\. Introduction to Functional dependency
theory 6\\. Normalization Theory a. Decomposition of a schema; lossless-join,
and dependency-preservation properties of a decomposition b. Normal forms
(BCNF) c. Denormalization (for efficiency) Non-core: 7\\. Functional dependency
theory a. Closure of a set of attributes b. Canonical Cover 8\\. Normalization
theory a. Multi-valued dependency (4NF) b. Join dependency (PJNF, 5NF) c.
Representation theory Illustrative Learning Outcomes: CS Core: 1\\. Describe
the defining characteristics behind the relational data model. 2\\. Comment on
the difference between a foreign key and a superkey. 3\\. Enumerate the
different types of integrity constraints. KA Core: 4\\. Compose a relational
schema from a conceptual schema which contains 1:1, 1:n, and n:m
relationships. 5\\. Map appropriate file structure to relations and indices.
6\\. Describe how functional dependency theory generalizes the notion of key.
7\\. Defend a given decomposition as lossless and or dependency preserving. 8\\.
Detect which normal form a given decomposition yields. 9\\. Comment on reasons
for denormalizing a relation."""^^xsd:string ;
            ns2:score "0.68290746"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some related topics but lacks core KU content like functional dependency theory and normalization." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Relational_Relational_Databases" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.7250526"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including SQL query formation, relational algebra, and data definition, but does not cover relational calculus, QBE, and other query languages." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt> ;
            ns2:ku_text """Pages: 117-118 HOURS CS Core = 1 KA Core = 3 DM-Relational: Relational
Databases CS Core: 1\\. Entity and referential integrity: Candidate key,
superkeys 2\\. Relational database design KA Core: 3\\. Mapping conceptual
schema to a relational schema 4\\. Physical database design: file and storage
structures (See also: OS-Files) 5\\. Introduction to Functional dependency
theory 6\\. Normalization Theory a. Decomposition of a schema; lossless-join,
and dependency-preservation properties of a decomposition b. Normal forms
(BCNF) c. Denormalization (for efficiency) Non-core: 7\\. Functional dependency
theory a. Closure of a set of attributes b. Canonical Cover 8\\. Normalization
theory a. Multi-valued dependency (4NF) b. Join dependency (PJNF, 5NF) c.
Representation theory Illustrative Learning Outcomes: CS Core: 1\\. Describe
the defining characteristics behind the relational data model. 2\\. Comment on
the difference between a foreign key and a superkey. 3\\. Enumerate the
different types of integrity constraints. KA Core: 4\\. Compose a relational
schema from a conceptual schema which contains 1:1, 1:n, and n:m
relationships. 5\\. Map appropriate file structure to relations and indices.
6\\. Describe how functional dependency theory generalizes the notion of key.
7\\. Defend a given decomposition as lossless and or dependency preserving. 8\\.
Detect which normal form a given decomposition yields. 9\\. Comment on reasons
for denormalizing a relation."""^^xsd:string ;
            ns2:score "0.68290746"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some related topics but lacks core KU content like functional dependency theory and normalization." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Relational_Relational_Databases" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.7250526"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers constraints, triggers, transactions, and querying basics (views, SQL extensions). Partial overlap with core SQL query operations." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt> ;
            ns2:ku_text """Pages: 117-118 HOURS CS Core = 1 KA Core = 3 DM-Relational: Relational
Databases CS Core: 1\\. Entity and referential integrity: Candidate key,
superkeys 2\\. Relational database design KA Core: 3\\. Mapping conceptual
schema to a relational schema 4\\. Physical database design: file and storage
structures (See also: OS-Files) 5\\. Introduction to Functional dependency
theory 6\\. Normalization Theory a. Decomposition of a schema; lossless-join,
and dependency-preservation properties of a decomposition b. Normal forms
(BCNF) c. Denormalization (for efficiency) Non-core: 7\\. Functional dependency
theory a. Closure of a set of attributes b. Canonical Cover 8\\. Normalization
theory a. Multi-valued dependency (4NF) b. Join dependency (PJNF, 5NF) c.
Representation theory Illustrative Learning Outcomes: CS Core: 1\\. Describe
the defining characteristics behind the relational data model. 2\\. Comment on
the difference between a foreign key and a superkey. 3\\. Enumerate the
different types of integrity constraints. KA Core: 4\\. Compose a relational
schema from a conceptual schema which contains 1:1, 1:n, and n:m
relationships. 5\\. Map appropriate file structure to relations and indices.
6\\. Describe how functional dependency theory generalizes the notion of key.
7\\. Defend a given decomposition as lossless and or dependency preserving. 8\\.
Detect which normal form a given decomposition yields. 9\\. Comment on reasons
for denormalizing a relation."""^^xsd:string ;
            ns2:score "0.68290746"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers core topics like integrity constraints, normalization (BCNF), physical structuring, transactions, and query optimization." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Relational_Relational_Databases" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.685809"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some related topics but lacks substantial coverage of the KU's core elements." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.7250526"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including SQL query formation, relational algebra, and data definition, but does not cover relational calculus, QBE, and other query languages." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.685809"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including SQL query formation, relational algebra, and data definition, but does not cover relational calculus, QBE, and other query languages." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.685809"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "Covers constraints, triggers, transactions, and querying basics (views, SQL extensions). Partial overlap with core SQL query operations." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.685809"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers most of the knowledge units, including SQL query formation, relational algebra, and data definition, but does not cover relational calculus, QBE, and other query languages." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns2:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns2:score "0.7250526"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture covers some related topics but lacks substantial coverage of the KU's core elements." ;
            ns3:ka "Date_Management_DM" ;
            ns3:ku "DM-Querying_Query_Construction" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ] ;
    ns2:uetext """Label: Bases de données 2 Objectif: (résultats d'apprentissage) • Savoir déterminer des contraintes d’intégrité
• Savoir appliquer un contrôle d’accès basique à une base de données
• Comprendre la notion de vue
• Connaître la structuration physique des données
• Comprendre la notion de transaction
• Comprendre la notion d’ordonnancement sérialisable
• Comprendre la technique de contrôle de concurrence par verrouillage
• Comprendre les fonctions d’un optimiseur de requêtes
• Comprendre un plan d’exécution d’une requête
• Connaître les structures accélératrices d’accès aux données (indexes) Course content: Extension procédurale de SQL (PL/SQL) , BD actives (Déclencheurs) Interrogation d'une base avec Course name: http://example.org/course/UE_X32I040""" .

ns3:UE_X32I050 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7228141"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as software construction, maintenance, and documentation, as well as logic programming concepts like quantifiers, logical connectives, and unification." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt> ;
            ns2:ku_text """Pages:76-77 HOURS CS Core = 0 KA Core = 0 AI-LRR: Logical Representation and
Reasoning Non-core: 77 1\\. Review of propositional and predicate logic (See
also: MSF-Discrete) 2\\. Resolution and theorem proving (propositional logic
only) a. Forward chaining, backward chaining 3\\. Knowledge representation
issues a. Description logics b. Ontology engineering 4\\. Semantic web 5\\. Non-
monotonic reasoning (e.g., non-classical logics, default reasoning) 6\\.
Argumentation 7\\. Reasoning about action and change (e.g., situation and event
calculus) 8\\. Temporal and spatial reasoning 9\\. Logic programming a. Prolog,
Answer Set Programming 10\\. Rule-based Expert Systems 11\\. Semantic networks
12\\. Model-based and Case-based reasoning Illustrative Learning Outcomes: 1\\.
Translate a natural language (e.g., English) sentence into a predicate logic
statement. 2\\. Convert a logic statement into clausal form. 3\\. Apply
resolution to a set of logic statements to answer a query. 4\\. Compare and
contrast the most common models used for structured knowledge representation,
highlighting their strengths and weaknesses. 5\\. Identify the components of
non-monotonic reasoning and its usefulness as a representational mechanism for
belief systems. 6\\. Compare and contrast the basic techniques for representing
uncertainty. 7\\. Compare and contrast the basic techniques for qualitative
representation. 8\\. Apply situation and event calculus to problems of action
and change. 9\\. Explain the distinction between temporal and spatial
reasoning, and how they interrelate. 10\\. Explain the difference between rule-
based, case-based, and model-based reasoning techniques. 11\\. Define the
concept of a planning system and how it differs from classical search
techniques. 12\\. Describe the differences between planning as search,
operator-based planning, and propositional planning, providing examples of
domains where each is most applicable. 13\\. Explain the distinction between
monotonic and non-monotonic inference."""^^xsd:string ;
            ns2:score "0.70038986"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on software construction and evolution, whereas the KU covers logical representation and reasoning, with little overlap between the two topics." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-LRR_Logical_Representation_and_Reasoning" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt> ;
            ns2:ku_text """Pages:76-77 HOURS CS Core = 0 KA Core = 0 AI-LRR: Logical Representation and
Reasoning Non-core: 77 1\\. Review of propositional and predicate logic (See
also: MSF-Discrete) 2\\. Resolution and theorem proving (propositional logic
only) a. Forward chaining, backward chaining 3\\. Knowledge representation
issues a. Description logics b. Ontology engineering 4\\. Semantic web 5\\. Non-
monotonic reasoning (e.g., non-classical logics, default reasoning) 6\\.
Argumentation 7\\. Reasoning about action and change (e.g., situation and event
calculus) 8\\. Temporal and spatial reasoning 9\\. Logic programming a. Prolog,
Answer Set Programming 10\\. Rule-based Expert Systems 11\\. Semantic networks
12\\. Model-based and Case-based reasoning Illustrative Learning Outcomes: 1\\.
Translate a natural language (e.g., English) sentence into a predicate logic
statement. 2\\. Convert a logic statement into clausal form. 3\\. Apply
resolution to a set of logic statements to answer a query. 4\\. Compare and
contrast the most common models used for structured knowledge representation,
highlighting their strengths and weaknesses. 5\\. Identify the components of
non-monotonic reasoning and its usefulness as a representational mechanism for
belief systems. 6\\. Compare and contrast the basic techniques for representing
uncertainty. 7\\. Compare and contrast the basic techniques for qualitative
representation. 8\\. Apply situation and event calculus to problems of action
and change. 9\\. Explain the distinction between temporal and spatial
reasoning, and how they interrelate. 10\\. Explain the difference between rule-
based, case-based, and model-based reasoning techniques. 11\\. Define the
concept of a planning system and how it differs from classical search
techniques. 12\\. Describe the differences between planning as search,
operator-based planning, and propositional planning, providing examples of
domains where each is most applicable. 13\\. Explain the distinction between
monotonic and non-monotonic inference."""^^xsd:string ;
            ns2:score "0.70038986"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on software construction and evolution, whereas the KU covers logical representation and reasoning, with little overlap between the two topics." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-LRR_Logical_Representation_and_Reasoning" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt> ;
            ns2:ku_text """Pages:76-77 HOURS CS Core = 0 KA Core = 0 AI-LRR: Logical Representation and
Reasoning Non-core: 77 1\\. Review of propositional and predicate logic (See
also: MSF-Discrete) 2\\. Resolution and theorem proving (propositional logic
only) a. Forward chaining, backward chaining 3\\. Knowledge representation
issues a. Description logics b. Ontology engineering 4\\. Semantic web 5\\. Non-
monotonic reasoning (e.g., non-classical logics, default reasoning) 6\\.
Argumentation 7\\. Reasoning about action and change (e.g., situation and event
calculus) 8\\. Temporal and spatial reasoning 9\\. Logic programming a. Prolog,
Answer Set Programming 10\\. Rule-based Expert Systems 11\\. Semantic networks
12\\. Model-based and Case-based reasoning Illustrative Learning Outcomes: 1\\.
Translate a natural language (e.g., English) sentence into a predicate logic
statement. 2\\. Convert a logic statement into clausal form. 3\\. Apply
resolution to a set of logic statements to answer a query. 4\\. Compare and
contrast the most common models used for structured knowledge representation,
highlighting their strengths and weaknesses. 5\\. Identify the components of
non-monotonic reasoning and its usefulness as a representational mechanism for
belief systems. 6\\. Compare and contrast the basic techniques for representing
uncertainty. 7\\. Compare and contrast the basic techniques for qualitative
representation. 8\\. Apply situation and event calculus to problems of action
and change. 9\\. Explain the distinction between temporal and spatial
reasoning, and how they interrelate. 10\\. Explain the difference between rule-
based, case-based, and model-based reasoning techniques. 11\\. Define the
concept of a planning system and how it differs from classical search
techniques. 12\\. Describe the differences between planning as search,
operator-based planning, and propositional planning, providing examples of
domains where each is most applicable. 13\\. Explain the distinction between
monotonic and non-monotonic inference."""^^xsd:string ;
            ns2:score "0.70038986"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on software construction and evolution, while the KU covers logical representation and reasoning, which are distinct areas." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-LRR_Logical_Representation_and_Reasoning" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt> ;
            ns2:ku_text """Pages : 168-169 CS Core : 20, KA Core : None CS Core: 1\\. Basic concepts such
as variables, primitive data types, expressions, and their evaluation 2\\. How
imperative programs work: state and state transitions on execution of
statements, flow of control 3\\. Basic constructs such as assignment
statements, conditional and iterative statements, basic I/O 4\\. Key modularity
constructs such as functions (and methods and classes, if supported in the
language) and related concepts like parameter passing, scope, abstraction,
data encapsulation (See also: FPL-OOP) 5\\. Input and output using files and
APIs 6\\. Structured data types available in the chosen programming language
like sequences (e.g., arrays, lists), associative containers (e.g.,
dictionaries, maps), others (e.g., sets, tuples) and when and how to use them
(See also: AL-Foundational) 7\\. Libraries and frameworks provided by the
language (when/where applicable) 8\\. Recursion 9\\. Dealing with runtime errors
in programs (e.g., exception handling). 10\\. Basic concepts of programming
errors, testing, and debugging (See also: SE-Construction, SEC-Coding) 11\\.
Documenting/commenting code at the program and module level.(See also: SE-
Construction) 12\\. Develop a security mindset. (See also: SEC-Foundations)
Illustrative Learning Outcomes: CS Core: In these learning outcomes, the term
"develop" means "design, write, test, and debug." 1\\. Develop programs that
use the fundamental programming constructs: assignment and expressions, basic
I/O, conditional and iterative statements. 2\\. Develop programs using
functions with parameter passing. 3\\. Develop programs that effectively use
the different structured data types provided in the language like
arrays/lists, dictionaries, and sets. 4\\. Develop programs that use file I/O
to provide data persistence across multiple executions. 5\\. Develop programs
that use language-provided libraries and frameworks (where applicable). 6\\.
Develop programs that use APIs to access or update data (e.g., from the web).
7\\. Develop programs that create simple classes and instantiate objects of
those classes (if supported by the language). 8\\. Explain the concept of
recursion and identify when and how to use it effectively. 9\\. Develop
recursive functions. 10\\. Develop programs that can handle runtime errors.
11\\. Read a given program and explain what it does. 12\\. Write comments for a
program or a module specifying what it does. 13\\. Trace the flow of control
during the execution of a program. 14\\. Use appropriate terminology to
identify elements of a program (e.g., identifier, operator, operand)."""^^xsd:string ;
            ns2:score "0.70751655"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as software construction, maintenance, and testing, as well as programming concepts like variables, data types, and control structures." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Fundamental_Programming_Concepts_and_Practices" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt> ;
            ns2:ku_text """Pages : 168-169 CS Core : 20, KA Core : None CS Core: 1\\. Basic concepts such
as variables, primitive data types, expressions, and their evaluation 2\\. How
imperative programs work: state and state transitions on execution of
statements, flow of control 3\\. Basic constructs such as assignment
statements, conditional and iterative statements, basic I/O 4\\. Key modularity
constructs such as functions (and methods and classes, if supported in the
language) and related concepts like parameter passing, scope, abstraction,
data encapsulation (See also: FPL-OOP) 5\\. Input and output using files and
APIs 6\\. Structured data types available in the chosen programming language
like sequences (e.g., arrays, lists), associative containers (e.g.,
dictionaries, maps), others (e.g., sets, tuples) and when and how to use them
(See also: AL-Foundational) 7\\. Libraries and frameworks provided by the
language (when/where applicable) 8\\. Recursion 9\\. Dealing with runtime errors
in programs (e.g., exception handling). 10\\. Basic concepts of programming
errors, testing, and debugging (See also: SE-Construction, SEC-Coding) 11\\.
Documenting/commenting code at the program and module level.(See also: SE-
Construction) 12\\. Develop a security mindset. (See also: SEC-Foundations)
Illustrative Learning Outcomes: CS Core: In these learning outcomes, the term
"develop" means "design, write, test, and debug." 1\\. Develop programs that
use the fundamental programming constructs: assignment and expressions, basic
I/O, conditional and iterative statements. 2\\. Develop programs using
functions with parameter passing. 3\\. Develop programs that effectively use
the different structured data types provided in the language like
arrays/lists, dictionaries, and sets. 4\\. Develop programs that use file I/O
to provide data persistence across multiple executions. 5\\. Develop programs
that use language-provided libraries and frameworks (where applicable). 6\\.
Develop programs that use APIs to access or update data (e.g., from the web).
7\\. Develop programs that create simple classes and instantiate objects of
those classes (if supported by the language). 8\\. Explain the concept of
recursion and identify when and how to use it effectively. 9\\. Develop
recursive functions. 10\\. Develop programs that can handle runtime errors.
11\\. Read a given program and explain what it does. 12\\. Write comments for a
program or a module specifying what it does. 13\\. Trace the flow of control
during the execution of a program. 14\\. Use appropriate terminology to
identify elements of a program (e.g., identifier, operator, operand)."""^^xsd:string ;
            ns2:score "0.70751655"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on software maintenance/documentation/teamwork, while KU covers foundational programming concepts (data types, control structures, recursion, etc.) not explicitly addressed." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Fundamental_Programming_Concepts_and_Practices" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt> ;
            ns2:ku_text """Pages:76-77 HOURS CS Core = 0 KA Core = 0 AI-LRR: Logical Representation and
Reasoning Non-core: 77 1\\. Review of propositional and predicate logic (See
also: MSF-Discrete) 2\\. Resolution and theorem proving (propositional logic
only) a. Forward chaining, backward chaining 3\\. Knowledge representation
issues a. Description logics b. Ontology engineering 4\\. Semantic web 5\\. Non-
monotonic reasoning (e.g., non-classical logics, default reasoning) 6\\.
Argumentation 7\\. Reasoning about action and change (e.g., situation and event
calculus) 8\\. Temporal and spatial reasoning 9\\. Logic programming a. Prolog,
Answer Set Programming 10\\. Rule-based Expert Systems 11\\. Semantic networks
12\\. Model-based and Case-based reasoning Illustrative Learning Outcomes: 1\\.
Translate a natural language (e.g., English) sentence into a predicate logic
statement. 2\\. Convert a logic statement into clausal form. 3\\. Apply
resolution to a set of logic statements to answer a query. 4\\. Compare and
contrast the most common models used for structured knowledge representation,
highlighting their strengths and weaknesses. 5\\. Identify the components of
non-monotonic reasoning and its usefulness as a representational mechanism for
belief systems. 6\\. Compare and contrast the basic techniques for representing
uncertainty. 7\\. Compare and contrast the basic techniques for qualitative
representation. 8\\. Apply situation and event calculus to problems of action
and change. 9\\. Explain the distinction between temporal and spatial
reasoning, and how they interrelate. 10\\. Explain the difference between rule-
based, case-based, and model-based reasoning techniques. 11\\. Define the
concept of a planning system and how it differs from classical search
techniques. 12\\. Describe the differences between planning as search,
operator-based planning, and propositional planning, providing examples of
domains where each is most applicable. 13\\. Explain the distinction between
monotonic and non-monotonic inference."""^^xsd:string ;
            ns2:score "0.70038986"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap; lecture covers software maintenance, KU focuses on logic systems" ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-LRR_Logical_Representation_and_Reasoning" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7228141"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap: Lecture focuses on software maintenance and development practices, while KU covers logic programming theory." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt> ;
            ns2:ku_text """Pages:76-77 HOURS CS Core = 0 KA Core = 0 AI-LRR: Logical Representation and
Reasoning Non-core: 77 1\\. Review of propositional and predicate logic (See
also: MSF-Discrete) 2\\. Resolution and theorem proving (propositional logic
only) a. Forward chaining, backward chaining 3\\. Knowledge representation
issues a. Description logics b. Ontology engineering 4\\. Semantic web 5\\. Non-
monotonic reasoning (e.g., non-classical logics, default reasoning) 6\\.
Argumentation 7\\. Reasoning about action and change (e.g., situation and event
calculus) 8\\. Temporal and spatial reasoning 9\\. Logic programming a. Prolog,
Answer Set Programming 10\\. Rule-based Expert Systems 11\\. Semantic networks
12\\. Model-based and Case-based reasoning Illustrative Learning Outcomes: 1\\.
Translate a natural language (e.g., English) sentence into a predicate logic
statement. 2\\. Convert a logic statement into clausal form. 3\\. Apply
resolution to a set of logic statements to answer a query. 4\\. Compare and
contrast the most common models used for structured knowledge representation,
highlighting their strengths and weaknesses. 5\\. Identify the components of
non-monotonic reasoning and its usefulness as a representational mechanism for
belief systems. 6\\. Compare and contrast the basic techniques for representing
uncertainty. 7\\. Compare and contrast the basic techniques for qualitative
representation. 8\\. Apply situation and event calculus to problems of action
and change. 9\\. Explain the distinction between temporal and spatial
reasoning, and how they interrelate. 10\\. Explain the difference between rule-
based, case-based, and model-based reasoning techniques. 11\\. Define the
concept of a planning system and how it differs from classical search
techniques. 12\\. Describe the differences between planning as search,
operator-based planning, and propositional planning, providing examples of
domains where each is most applicable. 13\\. Explain the distinction between
monotonic and non-monotonic inference."""^^xsd:string ;
            ns2:score "0.70038986"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on software construction and evolution, while the KU covers logical representation and reasoning, which are distinct areas." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-LRR_Logical_Representation_and_Reasoning" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7228141"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as software construction, maintenance, and documentation, as well as logic programming concepts like quantifiers, logical connectives, and unification." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt> ;
            ns2:ku_text """Pages : 168-169 CS Core : 20, KA Core : None CS Core: 1\\. Basic concepts such
as variables, primitive data types, expressions, and their evaluation 2\\. How
imperative programs work: state and state transitions on execution of
statements, flow of control 3\\. Basic constructs such as assignment
statements, conditional and iterative statements, basic I/O 4\\. Key modularity
constructs such as functions (and methods and classes, if supported in the
language) and related concepts like parameter passing, scope, abstraction,
data encapsulation (See also: FPL-OOP) 5\\. Input and output using files and
APIs 6\\. Structured data types available in the chosen programming language
like sequences (e.g., arrays, lists), associative containers (e.g.,
dictionaries, maps), others (e.g., sets, tuples) and when and how to use them
(See also: AL-Foundational) 7\\. Libraries and frameworks provided by the
language (when/where applicable) 8\\. Recursion 9\\. Dealing with runtime errors
in programs (e.g., exception handling). 10\\. Basic concepts of programming
errors, testing, and debugging (See also: SE-Construction, SEC-Coding) 11\\.
Documenting/commenting code at the program and module level.(See also: SE-
Construction) 12\\. Develop a security mindset. (See also: SEC-Foundations)
Illustrative Learning Outcomes: CS Core: In these learning outcomes, the term
"develop" means "design, write, test, and debug." 1\\. Develop programs that
use the fundamental programming constructs: assignment and expressions, basic
I/O, conditional and iterative statements. 2\\. Develop programs using
functions with parameter passing. 3\\. Develop programs that effectively use
the different structured data types provided in the language like
arrays/lists, dictionaries, and sets. 4\\. Develop programs that use file I/O
to provide data persistence across multiple executions. 5\\. Develop programs
that use language-provided libraries and frameworks (where applicable). 6\\.
Develop programs that use APIs to access or update data (e.g., from the web).
7\\. Develop programs that create simple classes and instantiate objects of
those classes (if supported by the language). 8\\. Explain the concept of
recursion and identify when and how to use it effectively. 9\\. Develop
recursive functions. 10\\. Develop programs that can handle runtime errors.
11\\. Read a given program and explain what it does. 12\\. Write comments for a
program or a module specifying what it does. 13\\. Trace the flow of control
during the execution of a program. 14\\. Use appropriate terminology to
identify elements of a program (e.g., identifier, operator, operand)."""^^xsd:string ;
            ns2:score "0.70751655"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on software construction and evolution, covering topics like maintenance, documentation, and exception handling, but does not substantially address the core programming concepts detailed in the KU." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Fundamental_Programming_Concepts_and_Practices" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7228141"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap: Lecture focuses on software maintenance and development practices, while KU covers logic programming theory." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt> ;
            ns2:ku_text """Pages : 168-169 CS Core : 20, KA Core : None CS Core: 1\\. Basic concepts such
as variables, primitive data types, expressions, and their evaluation 2\\. How
imperative programs work: state and state transitions on execution of
statements, flow of control 3\\. Basic constructs such as assignment
statements, conditional and iterative statements, basic I/O 4\\. Key modularity
constructs such as functions (and methods and classes, if supported in the
language) and related concepts like parameter passing, scope, abstraction,
data encapsulation (See also: FPL-OOP) 5\\. Input and output using files and
APIs 6\\. Structured data types available in the chosen programming language
like sequences (e.g., arrays, lists), associative containers (e.g.,
dictionaries, maps), others (e.g., sets, tuples) and when and how to use them
(See also: AL-Foundational) 7\\. Libraries and frameworks provided by the
language (when/where applicable) 8\\. Recursion 9\\. Dealing with runtime errors
in programs (e.g., exception handling). 10\\. Basic concepts of programming
errors, testing, and debugging (See also: SE-Construction, SEC-Coding) 11\\.
Documenting/commenting code at the program and module level.(See also: SE-
Construction) 12\\. Develop a security mindset. (See also: SEC-Foundations)
Illustrative Learning Outcomes: CS Core: In these learning outcomes, the term
"develop" means "design, write, test, and debug." 1\\. Develop programs that
use the fundamental programming constructs: assignment and expressions, basic
I/O, conditional and iterative statements. 2\\. Develop programs using
functions with parameter passing. 3\\. Develop programs that effectively use
the different structured data types provided in the language like
arrays/lists, dictionaries, and sets. 4\\. Develop programs that use file I/O
to provide data persistence across multiple executions. 5\\. Develop programs
that use language-provided libraries and frameworks (where applicable). 6\\.
Develop programs that use APIs to access or update data (e.g., from the web).
7\\. Develop programs that create simple classes and instantiate objects of
those classes (if supported by the language). 8\\. Explain the concept of
recursion and identify when and how to use it effectively. 9\\. Develop
recursive functions. 10\\. Develop programs that can handle runtime errors.
11\\. Read a given program and explain what it does. 12\\. Write comments for a
program or a module specifying what it does. 13\\. Trace the flow of control
during the execution of a program. 14\\. Use appropriate terminology to
identify elements of a program (e.g., identifier, operator, operand)."""^^xsd:string ;
            ns2:score "0.70751655"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including topics such as software construction, maintenance, and testing, as well as programming concepts like variables, data types, and control structures." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Fundamental_Programming_Concepts_and_Practices" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7228141"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the specific logic programming topics outlined in the KU." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt> ;
            ns2:ku_text """Pages:76-77 HOURS CS Core = 0 KA Core = 0 AI-LRR: Logical Representation and
Reasoning Non-core: 77 1\\. Review of propositional and predicate logic (See
also: MSF-Discrete) 2\\. Resolution and theorem proving (propositional logic
only) a. Forward chaining, backward chaining 3\\. Knowledge representation
issues a. Description logics b. Ontology engineering 4\\. Semantic web 5\\. Non-
monotonic reasoning (e.g., non-classical logics, default reasoning) 6\\.
Argumentation 7\\. Reasoning about action and change (e.g., situation and event
calculus) 8\\. Temporal and spatial reasoning 9\\. Logic programming a. Prolog,
Answer Set Programming 10\\. Rule-based Expert Systems 11\\. Semantic networks
12\\. Model-based and Case-based reasoning Illustrative Learning Outcomes: 1\\.
Translate a natural language (e.g., English) sentence into a predicate logic
statement. 2\\. Convert a logic statement into clausal form. 3\\. Apply
resolution to a set of logic statements to answer a query. 4\\. Compare and
contrast the most common models used for structured knowledge representation,
highlighting their strengths and weaknesses. 5\\. Identify the components of
non-monotonic reasoning and its usefulness as a representational mechanism for
belief systems. 6\\. Compare and contrast the basic techniques for representing
uncertainty. 7\\. Compare and contrast the basic techniques for qualitative
representation. 8\\. Apply situation and event calculus to problems of action
and change. 9\\. Explain the distinction between temporal and spatial
reasoning, and how they interrelate. 10\\. Explain the difference between rule-
based, case-based, and model-based reasoning techniques. 11\\. Define the
concept of a planning system and how it differs from classical search
techniques. 12\\. Describe the differences between planning as search,
operator-based planning, and propositional planning, providing examples of
domains where each is most applicable. 13\\. Explain the distinction between
monotonic and non-monotonic inference."""^^xsd:string ;
            ns2:score "0.70038986"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap; lecture covers software maintenance, KU focuses on logic systems" ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-LRR_Logical_Representation_and_Reasoning" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns2:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns2:score "0.7228141"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the specific logic programming topics outlined in the KU." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Logic_Logic_Programming" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt> ;
            ns2:ku_text """Pages : 168-169 CS Core : 20, KA Core : None CS Core: 1\\. Basic concepts such
as variables, primitive data types, expressions, and their evaluation 2\\. How
imperative programs work: state and state transitions on execution of
statements, flow of control 3\\. Basic constructs such as assignment
statements, conditional and iterative statements, basic I/O 4\\. Key modularity
constructs such as functions (and methods and classes, if supported in the
language) and related concepts like parameter passing, scope, abstraction,
data encapsulation (See also: FPL-OOP) 5\\. Input and output using files and
APIs 6\\. Structured data types available in the chosen programming language
like sequences (e.g., arrays, lists), associative containers (e.g.,
dictionaries, maps), others (e.g., sets, tuples) and when and how to use them
(See also: AL-Foundational) 7\\. Libraries and frameworks provided by the
language (when/where applicable) 8\\. Recursion 9\\. Dealing with runtime errors
in programs (e.g., exception handling). 10\\. Basic concepts of programming
errors, testing, and debugging (See also: SE-Construction, SEC-Coding) 11\\.
Documenting/commenting code at the program and module level.(See also: SE-
Construction) 12\\. Develop a security mindset. (See also: SEC-Foundations)
Illustrative Learning Outcomes: CS Core: In these learning outcomes, the term
"develop" means "design, write, test, and debug." 1\\. Develop programs that
use the fundamental programming constructs: assignment and expressions, basic
I/O, conditional and iterative statements. 2\\. Develop programs using
functions with parameter passing. 3\\. Develop programs that effectively use
the different structured data types provided in the language like
arrays/lists, dictionaries, and sets. 4\\. Develop programs that use file I/O
to provide data persistence across multiple executions. 5\\. Develop programs
that use language-provided libraries and frameworks (where applicable). 6\\.
Develop programs that use APIs to access or update data (e.g., from the web).
7\\. Develop programs that create simple classes and instantiate objects of
those classes (if supported by the language). 8\\. Explain the concept of
recursion and identify when and how to use it effectively. 9\\. Develop
recursive functions. 10\\. Develop programs that can handle runtime errors.
11\\. Read a given program and explain what it does. 12\\. Write comments for a
program or a module specifying what it does. 13\\. Trace the flow of control
during the execution of a program. 14\\. Use appropriate terminology to
identify elements of a program (e.g., identifier, operator, operand)."""^^xsd:string ;
            ns2:score "0.70751655"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on software maintenance/documentation/teamwork, while KU covers foundational programming concepts (data types, control structures, recursion, etc.) not explicitly addressed." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Fundamental_Programming_Concepts_and_Practices" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt> ;
            ns2:ku_text """Pages : 168-169 CS Core : 20, KA Core : None CS Core: 1\\. Basic concepts such
as variables, primitive data types, expressions, and their evaluation 2\\. How
imperative programs work: state and state transitions on execution of
statements, flow of control 3\\. Basic constructs such as assignment
statements, conditional and iterative statements, basic I/O 4\\. Key modularity
constructs such as functions (and methods and classes, if supported in the
language) and related concepts like parameter passing, scope, abstraction,
data encapsulation (See also: FPL-OOP) 5\\. Input and output using files and
APIs 6\\. Structured data types available in the chosen programming language
like sequences (e.g., arrays, lists), associative containers (e.g.,
dictionaries, maps), others (e.g., sets, tuples) and when and how to use them
(See also: AL-Foundational) 7\\. Libraries and frameworks provided by the
language (when/where applicable) 8\\. Recursion 9\\. Dealing with runtime errors
in programs (e.g., exception handling). 10\\. Basic concepts of programming
errors, testing, and debugging (See also: SE-Construction, SEC-Coding) 11\\.
Documenting/commenting code at the program and module level.(See also: SE-
Construction) 12\\. Develop a security mindset. (See also: SEC-Foundations)
Illustrative Learning Outcomes: CS Core: In these learning outcomes, the term
"develop" means "design, write, test, and debug." 1\\. Develop programs that
use the fundamental programming constructs: assignment and expressions, basic
I/O, conditional and iterative statements. 2\\. Develop programs using
functions with parameter passing. 3\\. Develop programs that effectively use
the different structured data types provided in the language like
arrays/lists, dictionaries, and sets. 4\\. Develop programs that use file I/O
to provide data persistence across multiple executions. 5\\. Develop programs
that use language-provided libraries and frameworks (where applicable). 6\\.
Develop programs that use APIs to access or update data (e.g., from the web).
7\\. Develop programs that create simple classes and instantiate objects of
those classes (if supported by the language). 8\\. Explain the concept of
recursion and identify when and how to use it effectively. 9\\. Develop
recursive functions. 10\\. Develop programs that can handle runtime errors.
11\\. Read a given program and explain what it does. 12\\. Write comments for a
program or a module specifying what it does. 13\\. Trace the flow of control
during the execution of a program. 14\\. Use appropriate terminology to
identify elements of a program (e.g., identifier, operator, operand)."""^^xsd:string ;
            ns2:score "0.70751655"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on software construction and evolution, covering topics like maintenance, documentation, and exception handling, but does not substantially address the core programming concepts detailed in the KU." ;
            ns3:ka "Software_Development_Fundamentals_SDF" ;
            ns3:ku "SDF-Fundamental_Programming_Concepts_and_Practices" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ] ;
    ns2:uetext """Label: Construction et évolution de logiciels Objectif: (résultats d'apprentissage) • Être capable d'appliquer des heuristiques connues de construction et de maintenance pour
améliorer un logiciel existant, comme par exemple, éliminer des variables globales, appliquer des
conventions de codage et rendre le logiciel testable.
• Être capable de traduire la conception détaillée d'un logiciel en code source. En ce faisant, il doit
démontrer sa maîtrise des règles génériques de correspondance entre la conception et le code.
• Savoir organiser et rédiger le documentation utilisateur d'un logiciel dans le but de le rendre
utilisable à long terme.
• Être capable d'effectuer des opération de maintenance corrective, perfective, adaptative et
préventive.
• Être capable d'utiliser des outils d'analyse de code source pour appréhender un logiciel existant.
• Être capable d'utiliser la gestion d'exception, ainsi que d'autre techniques spécifiques aux
langages de programmation pour améliorer la tolérance aux fautes. Course content: modernisation. Les principes de travail dans une équipe de développement en entreprise. La
rédaction de documentation logicielle, la maintenance logicielle, l'analyse de code et la gestion
d'exception seront aussi abordés dans ce module. Course name: http://example.org/course/UE_X32I050""" .

ns3:UE_X32T060 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.6353462"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including deterministic and stochastic grammars, parsing algorithms, and semantic representations, as well as information retrieval, language translation, and text classification." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.63506424"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not address the specific topics of the Knowledge Unit." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6427871"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.6353462"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods/learning outcomes, not NLP technical content" ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.6353462"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods/learning outcomes, not NLP technical content" ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6427871"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6427871"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods/learning outcomes, while KU covers technical platform-specific programming constraints and languages." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.63506424"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not address the specific topics of the Knowledge Unit." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.63506424"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of this topic in computing, aligning with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6427871"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods/learning outcomes, while KU covers technical platform-specific programming constraints and languages." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.63506424"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of this topic in computing, aligning with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.63506424"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods/learning objectives, not SE-Formal Methods content." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.63506424"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods/learning objectives, not SE-Formal Methods content." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.6353462"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the detailed NLP topics outlined in the KU." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.6353462"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including deterministic and stochastic grammars, parsing algorithms, and semantic representations, as well as information retrieval, language translation, and text classification." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6427871"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the technical content described in the KU." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6427871"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the technical content described in the KU." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns2:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns2:score "0.6353462"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the detailed NLP topics outlined in the KU." ;
            ns3:ka "Artificial_Intelligence_AI" ;
            ns3:ku "AI-NLP_Natural_Language_Processing" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ] ;
    ns2:uetext "Label: Stage Objectif: (résultats d'apprentissage) Course content: Méthodes d’enseignement Course name: http://example.org/course/UE_X32T060" .

ns3:UE_XLG5TU200 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6374133"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, not SE-Formal Methods content." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6374133"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods rather than the specific formal methods content." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6374133"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6453911"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the detailed technical aspects of development platforms, programming languages, and constraints outlined in the KU." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.62935567"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, not technical scripting topics" ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6453911"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6453911"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the detailed technical aspects of development platforms, programming languages, and constraints outlined in the KU." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6374133"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, not SE-Formal Methods content." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6374133"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6374133"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6374133"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, not SE-Formal Methods content." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.62935567"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including scripting, error handling, piping, system commands, environment variables, file abstraction, data structures, and regular expressions." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6453911"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, not technical platform constraints or programming languages." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6453911"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.62935567"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including scripting, error handling, piping, system commands, environment variables, file abstraction, data structures, and regular expressions." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.62935567"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, not technical scripting topics" ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6453911"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, not technical platform constraints or programming languages." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6453911"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, not technical platform constraints or programming languages." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6453911"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.62935567"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods and educational objectives, not the technical shell scripting content described in the KU." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6374133"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods rather than the specific formal methods content." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.62935567"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods and educational objectives, not the technical shell scripting content described in the KU." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.62935567"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods and educational objectives, not the technical shell scripting content described in the KU." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.62935567"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, not technical scripting topics" ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6374133"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods rather than the specific formal methods content." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6453911"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the detailed technical aspects of development platforms, programming languages, and constraints outlined in the KU." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns2:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns2:score "0.62935567"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers a significant portion of the KU, including scripting, error handling, piping, system commands, environment variables, file abstraction, data structures, and regular expressions." ;
            ns3:ka "Foundations_of_Programming_Languages_FPL" ;
            ns3:ku "FPL-Scripting_Shell_Scripting" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ] ;
    ns2:uetext "Label: Stage libre Objectif: (résultats d'apprentissage) Course content: Méthodes d’enseignement Course name: http://example.org/course/UE_XLG5TU200" .

ns3:UE_XLG6TU200 ns2:to [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the technical graphics and visualization topics outlined in the Knowledge Unit." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, while KU covers technical platform/programming concepts." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods, not the technical content of the KU." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap in subject matter; lecture focuses on teaching methods while KU is about formal methods in SE" ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, while KU covers technical platform/programming concepts." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods, not the technical graphics content of the KU." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods, not the technical graphics content of the KU." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods, not the technical graphics content of the KU." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods, not the technical content of the KU." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap in subject matter; lecture focuses on teaching methods while KU is about formal methods in SE" ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not substantially cover the detailed technical content of the Knowledge Unit." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the technical graphics and visualization topics outlined in the Knowledge Unit." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, while KU covers technical platform/programming concepts." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap in subject matter; lecture focuses on teaching methods while KU is about formal methods in SE" ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods, not the technical graphics content of the KU." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods, not the technical content of the KU." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap in subject matter; lecture focuses on teaching methods while KU is about formal methods in SE" ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, while KU covers technical platform/programming concepts." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods, not the technical content of the KU." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not substantially cover the detailed technical content of the Knowledge Unit." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not substantially cover the detailed technical content of the Knowledge Unit." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the technical graphics and visualization topics outlined in the Knowledge Unit." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods, not the technical graphics content of the KU." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not substantially cover the detailed technical content of the Knowledge Unit." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture focuses on teaching methods, not the technical content of the KU." ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "Lecture focuses on teaching methods, while KU covers technical platform/programming concepts." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns2:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns2:score "0.6385061"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "No overlap in subject matter; lecture focuses on teaching methods while KU is about formal methods in SE" ;
            ns3:ka "Software_Engineering_SE" ;
            ns3:ku "SE-Formal_Methods" ;
            ns1:wasGeneratedBy [ ns1:used "qwen-qwq-32b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the technical graphics and visualization topics outlined in the Knowledge Unit." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns2:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns2:score "0.62958026"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not cover the technical graphics and visualization topics outlined in the Knowledge Unit." ;
            ns3:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns3:ku "GIT-Fundamentals" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "1" ;
            ns3:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "llama3-8b-8192" ] ],
        [ ns2:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns2:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns2:score "0.6470485"^^xsd:float ;
            ns3:answer "0" ;
            ns3:explain "The lecture does not substantially cover the detailed technical content of the Knowledge Unit." ;
            ns3:ka "Specialized_Platform_Development_SPD" ;
            ns3:ku "SPD-Common_Aspects" ;
            ns1:wasGeneratedBy [ ns1:used "deepseek-r1-distill-llama-70b" ] ] ;
    ns2:uetext "Label: Stage libre Objectif: (résultats d'apprentissage) Course content: Méthodes d’enseignement Course name: http://example.org/course/UE_XLG6TU200" .

