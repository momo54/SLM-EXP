@prefix ns1: <http://example.org/course/> .
@prefix ns2: <http://provo.org/> .
@prefix ns3: <http://align.org/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

ns1:UE_XLG3AU010 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods and learning outcomes in English, not the technical content of the KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in subject matter; lecture focuses on teaching methods while KU is about formal methods in CS." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applying principles in practical scenarios, and analyzing the importance of this topic in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applying principles in practical scenarios, and analyzing the importance of this topic in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods and learning outcomes in English, not the technical content of the KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers NLP technical topics." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical NLP topics outlined in the KU." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers NLP technical topics." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applying principles in practical scenarios, and analyzing the importance of this topic in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in subject matter; lecture focuses on teaching methods while KU is about formal methods in CS." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not platform-specific programming constraints or languages." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including topics such as deterministic and stochastic grammars, parsing algorithms, and natural language processing." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods and learning outcomes in English, not the technical content of the KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers teaching methods in English, not formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including topics such as deterministic and stochastic grammars, parsing algorithms, and natural language processing." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods and learning outcomes in English, not the technical content of the KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical NLP topics outlined in the KU." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in subject matter; lecture focuses on teaching methods while KU is about formal methods in CS." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers teaching methods in English, not formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers NLP technical topics." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers teaching methods in English, not formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including topics such as deterministic and stochastic grammars, parsing algorithms, and natural language processing." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applying principles in practical scenarios, and analyzing the importance of this topic in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in subject matter; lecture focuses on teaching methods while KU is about formal methods in CS." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not platform-specific programming constraints or languages." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical NLP topics outlined in the KU." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including topics such as deterministic and stochastic grammars, parsing algorithms, and natural language processing." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.64398056"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers teaching methods in English, not formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not platform-specific programming constraints or languages." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6486398"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not platform-specific programming constraints or languages." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical NLP topics outlined in the KU." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.6364523"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers NLP technical topics." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ] ;
    ns3:uetext "Label: 2nd year English S3 Objectif: (résultats d'apprentissage) Course content: Méthodes d’enseignement Course name: http://example.org/course/UE_XLG3AU010" .

ns1:UE_XLG3IU010 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns3:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns3:score "0.6956569"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including topics such as algorithm implementation, data structures, and logic programming, with a focus on practical application and problem-solving." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Logic_Logic_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns3:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns3:score "0.6956569"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on algorithm analysis and data structures, while the KU covers logic programming concepts." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Logic_Logic_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt> ;
            ns3:ku_text """Pages:88-90 HOURS CS Core = 11 KA Core = 6 AL-Foundational: Foundational Data
Structures and Algorithms CS Core: (See also: SDF-Data-Structures, SDF-
Algorithms) 1\\. Abstract Data Type (ADT) and operations on an ADT (See also:
FPL-Types) a. Dictionary operations (insert, delete, find) 2\\. Arrays a.
Numeric vs non-numeric, character strings b. Single (vector) vs
multidimensional (matrix) 3\\. Records/Structs/Tuples and Objects (See also:
FPL-OOP) 4\\. Linked lists (for historical reasons) a. Single vs Double and
Linear vs Circular 5\\. Stacks 6\\. Queues and deques a. Heap-based priority
queue 7\\. Hash tables/maps a. Collision resolution and complexity (e.g.,
probing, chaining, rehash) 8\\. Graphs (e.g., [un]directed, [a]cyclic,
[un]connected, and [un]weighted) (See also: MSF-Discrete) a. Graph
representation: adjacency list vs matrix 9\\. Trees (See also: MSF-Discrete) a.
Binary, n-ary, and search trees b. Balanced (e.g., AVL, Red-Black, Heap) 10\\.
Sets (See also: MSF-Discrete) 11\\. Search algorithms a. O(n) complexity (e.g.,
linear/sequential array/list search) b. O(log2 n) complexity (e.g., binary
search) c. O(logb n) complexity (e.g., uninformed depth/breadth-first tree
search) 12\\. Sorting algorithms (e.g., stable, unstable) a. O(n2) complexity
(e.g., insertion, selection), b. O(n log n) complexity (e.g., quicksort,
merge, timsort) 13\\. Graph algorithms a. Shortest path (e.g., Dijkstra's,
Floyd's) b. Minimal spanning tree (e.g., Prim's, Kruskal's) KA Core: 14\\.
Sorting algorithms a. O(n log n) complexity heapsort b. Pseudo O(n) complexity
(e.g., bucket, counting, radix) 15\\. Graph algorithms a. Transitive closure
(e.g., Warshall's) b. Topological sort 16\\. Matching a. Efficient string
matching (e.g., Boyer-Moore, Knuth-Morris-Pratt) b. Longest common subsequence
matching c. Regular expression matching Non-core: 17\\. Cryptography algorithms
(e.g., SHA-256) (See also: SEC-Crypto) 18\\. Parallel algorithms (See also:
PDC-Algorithms, FPL-Parallel) 19\\. Consensus algorithms (e.g., Blockchain)
(See also: SEC-Crypto) a. Proof of work vs proof of stake (See also: SEP-
Sustainability) 20\\. Quantum computing algorithms (See also: AL-Models, AR-
Quantum) a. Oracle-based (e.g., Deutsch-Jozsa, Bernstein-Vazirani, Simon) b.
Superpolynomial speed-up via QFT (e.g., Shor's) c. Polynomial speed-up via
amplitude amplification (e.g., Grover's) 21\\. Fast-Fourier Transform (FFT)
algorithm 22\\. Differential evolution algorithm Illustrative Learning
Outcomes: CS Core: 1\\. For each ADT/Data-Structure in this unit a. Explain its
definition, properties, representation(s), and associated ADT operations. b.
Explain step-by-step how the ADT operations associated with the data structure
transform it. 2\\. For each algorithm in this unit explain step-by-step how the
algorithm operates. 3\\. For each algorithmic approach (e.g., sorting) in this
unit apply a prototypical example of the approach (e.g., merge sort). 90 4\\.
Given requirements for a problem, develop multiple solutions using various
data structures and algorithms. Subsequently, evaluate the suitability,
strengths, and weaknesses selecting an approach that best satisfies the
requirements. 5\\. Explain how collision avoidance and collision resolution is
handled in hash tables. 6\\. Explain factors beyond computational efficiency
that influence the choice of algorithms, such as programming time,
maintainability, and the use of application-specific patterns in the input
data. 7\\. Explain the heap property and the use of heaps as an implementation
of a priority queue. KA Core: 8\\. For each of the algorithms and algorithmic
approaches in the KA Core topics: a. Explain a prototypical example of the
algorithm, and b. Explain step-by-step how the algorithm operates. Non-core:
9\\. An appreciation of quantum computation and its application to certain
problems."""^^xsd:string ;
            ns3:score "0.69644845"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including data structures, algorithms, and their applications, with a focus on computer science core topics." ;
            ns1:ka "Algorithmic_Foundations_AL" ;
            ns1:ku "AL-Foundational_Foundational_Data_Structures_and_Algorithms" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt> ;
            ns3:ku_text """Pages:88-90 HOURS CS Core = 11 KA Core = 6 AL-Foundational: Foundational Data
Structures and Algorithms CS Core: (See also: SDF-Data-Structures, SDF-
Algorithms) 1\\. Abstract Data Type (ADT) and operations on an ADT (See also:
FPL-Types) a. Dictionary operations (insert, delete, find) 2\\. Arrays a.
Numeric vs non-numeric, character strings b. Single (vector) vs
multidimensional (matrix) 3\\. Records/Structs/Tuples and Objects (See also:
FPL-OOP) 4\\. Linked lists (for historical reasons) a. Single vs Double and
Linear vs Circular 5\\. Stacks 6\\. Queues and deques a. Heap-based priority
queue 7\\. Hash tables/maps a. Collision resolution and complexity (e.g.,
probing, chaining, rehash) 8\\. Graphs (e.g., [un]directed, [a]cyclic,
[un]connected, and [un]weighted) (See also: MSF-Discrete) a. Graph
representation: adjacency list vs matrix 9\\. Trees (See also: MSF-Discrete) a.
Binary, n-ary, and search trees b. Balanced (e.g., AVL, Red-Black, Heap) 10\\.
Sets (See also: MSF-Discrete) 11\\. Search algorithms a. O(n) complexity (e.g.,
linear/sequential array/list search) b. O(log2 n) complexity (e.g., binary
search) c. O(logb n) complexity (e.g., uninformed depth/breadth-first tree
search) 12\\. Sorting algorithms (e.g., stable, unstable) a. O(n2) complexity
(e.g., insertion, selection), b. O(n log n) complexity (e.g., quicksort,
merge, timsort) 13\\. Graph algorithms a. Shortest path (e.g., Dijkstra's,
Floyd's) b. Minimal spanning tree (e.g., Prim's, Kruskal's) KA Core: 14\\.
Sorting algorithms a. O(n log n) complexity heapsort b. Pseudo O(n) complexity
(e.g., bucket, counting, radix) 15\\. Graph algorithms a. Transitive closure
(e.g., Warshall's) b. Topological sort 16\\. Matching a. Efficient string
matching (e.g., Boyer-Moore, Knuth-Morris-Pratt) b. Longest common subsequence
matching c. Regular expression matching Non-core: 17\\. Cryptography algorithms
(e.g., SHA-256) (See also: SEC-Crypto) 18\\. Parallel algorithms (See also:
PDC-Algorithms, FPL-Parallel) 19\\. Consensus algorithms (e.g., Blockchain)
(See also: SEC-Crypto) a. Proof of work vs proof of stake (See also: SEP-
Sustainability) 20\\. Quantum computing algorithms (See also: AL-Models, AR-
Quantum) a. Oracle-based (e.g., Deutsch-Jozsa, Bernstein-Vazirani, Simon) b.
Superpolynomial speed-up via QFT (e.g., Shor's) c. Polynomial speed-up via
amplitude amplification (e.g., Grover's) 21\\. Fast-Fourier Transform (FFT)
algorithm 22\\. Differential evolution algorithm Illustrative Learning
Outcomes: CS Core: 1\\. For each ADT/Data-Structure in this unit a. Explain its
definition, properties, representation(s), and associated ADT operations. b.
Explain step-by-step how the ADT operations associated with the data structure
transform it. 2\\. For each algorithm in this unit explain step-by-step how the
algorithm operates. 3\\. For each algorithmic approach (e.g., sorting) in this
unit apply a prototypical example of the approach (e.g., merge sort). 90 4\\.
Given requirements for a problem, develop multiple solutions using various
data structures and algorithms. Subsequently, evaluate the suitability,
strengths, and weaknesses selecting an approach that best satisfies the
requirements. 5\\. Explain how collision avoidance and collision resolution is
handled in hash tables. 6\\. Explain factors beyond computational efficiency
that influence the choice of algorithms, such as programming time,
maintainability, and the use of application-specific patterns in the input
data. 7\\. Explain the heap property and the use of heaps as an implementation
of a priority queue. KA Core: 8\\. For each of the algorithms and algorithmic
approaches in the KA Core topics: a. Explain a prototypical example of the
algorithm, and b. Explain step-by-step how the algorithm operates. Non-core:
9\\. An appreciation of quantum computation and its application to certain
problems."""^^xsd:string ;
            ns3:score "0.69644845"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on analysis and divide/conquer, but KU covers broader DS/Algos not fully addressed." ;
            ns1:ka "Algorithmic_Foundations_AL" ;
            ns1:ku "AL-Foundational_Foundational_Data_Structures_and_Algorithms" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt> ;
            ns3:ku_text """Pages:91-93 HOURS CS Core = 6 KA Core = 3 AL-Complexity: Complexity CS Core:
1\\. Complexity Analysis Framework a. Best, average, and worst-case performance
of an algorithm b. Empirical and relative (Order of Growth) measurements c.
Input size and primitive operations d. Time and space efficiency 2\\.
Asymptotic complexity analysis (average and worst-case bounds) a. Big-O, Big-
Omega, and Big-Theta formal notations b. Foundational Complexity Classes and
Representative Examples/Problems i. O(1) Constant (e.g., array access) ii.
O(log2 n) Logarithmic (e.g., binary search) iii. O(n) Linear (e.g., linear
search) iv. O(n log2 n) Log Linear (e.g., mergesort) v. O(n2) Quadratic (e.g.,
selection sort) vi. O(nc) Polynomial (e.g., O(n3) Gaussian elimination) vii.
O(2n) Exponential (e.g., Knapsack, Satisfiability (SAT), Traveling Sales-
Person (TSP), all subsets) viii. O(n!) Factorial (e.g., Hamiltonian circuit,
all permutations) 3\\. Empirical measurements of performance 4\\. Tractability
and intractability a. P, NP, and NP-Complete Complexity Classes b. NP-Complete
Problems (e.g., SAT, Knapsack, TSP) c. Reductions 5\\. Time and space tradeoffs
in algorithms 92 KA Core: 6\\. Little-o, Little-Omega, and Little Theta
notations 7\\. Formal recursive analysis 8\\. Amortized analysis 9\\. Turing
Machine-based models of complexity a. Time complexity i. P, NP, NP-C, and EXP
classes ii. Cook-Levin theorem b. Space Complexity i. NSpace and PSpace ii.
Savitch's theorem Illustrative Learning Outcomes: CS Core: 1\\. Prepare a
presentation that explains to first year students the basic concepts of
algorithmic complexity including best, average, and worst-case algorithm
behavior, Big- O, Omega, and Theta notations, complexity classes, time and
space tradeoffs, empirical measurement, and impact on practical problems. 2\\.
Using examples, explain each of the foundational complexity classes in this
unit. 3\\. For each foundational complexity class in this unit, explain an
algorithm that demonstrates the associated runtime complexity. 4\\. For each
algorithm in the AL-Foundational unit, explain its runtime complexity class
and why it belongs to this class. 5\\. Informally evaluate the foundational
complexity class of simple algorithms. 6\\. Given a problem to program for
which there may be several algorithmic approaches, evaluate them and determine
which are feasible, and select one that is optimal in implementation and run-
time behavior. 7\\. Develop empirical studies to determine and validate
hypotheses about the runtime complexity of various algorithms by running
algorithms on input of various sizes and comparing actual performance to the
theoretical analysis. 8\\. Explain examples that illustrate time-space
tradeoffs of algorithms. 9\\. Explain how tree balance affects the efficiency
of binary search tree operations. 10\\. Explain to a non-technical audience the
significance of tractable versus intractable algorithms using an intuitive
explanation of Big-O complexity. 11\\. Explain the significance of NP-
Completeness. 12\\. Explain how NP-Hard is a lower bound and NP is an upper
bound for NP-Completeness. 13\\. Explain examples of NP-complete problems. KA
Core: 14\\. Use recurrence relations to evaluate the time complexity of
recursively defined algorithms. 15\\. Apply elementary recurrence relations
using a form of the Master Theorem. 16\\. Apply Big-O notation to give upper
case bounds on time/space complexity of algorithms. 17\\. Explain the Cook-
Levin Theorem and the NP-Completeness of SAT. 93 18\\. Explain the classes P
and NP. 19\\. Prove that a problem is NP-Complete by reducing a classic known
NP-C problem to it (e.g., 3SAT and Clique). 20\\. Explain the P-space class and
its relation to the EXP class."""^^xsd:string ;
            ns3:score "0.6920693"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including algorithmic complexity, Big-O notation, and time-space tradeoffs, but does not exhaustively cover all topics." ;
            ns1:ka "Algorithmic_Foundations_AL" ;
            ns1:ku "AL-Complexity_Complexity" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt> ;
            ns3:ku_text """Pages:88-90 HOURS CS Core = 11 KA Core = 6 AL-Foundational: Foundational Data
Structures and Algorithms CS Core: (See also: SDF-Data-Structures, SDF-
Algorithms) 1\\. Abstract Data Type (ADT) and operations on an ADT (See also:
FPL-Types) a. Dictionary operations (insert, delete, find) 2\\. Arrays a.
Numeric vs non-numeric, character strings b. Single (vector) vs
multidimensional (matrix) 3\\. Records/Structs/Tuples and Objects (See also:
FPL-OOP) 4\\. Linked lists (for historical reasons) a. Single vs Double and
Linear vs Circular 5\\. Stacks 6\\. Queues and deques a. Heap-based priority
queue 7\\. Hash tables/maps a. Collision resolution and complexity (e.g.,
probing, chaining, rehash) 8\\. Graphs (e.g., [un]directed, [a]cyclic,
[un]connected, and [un]weighted) (See also: MSF-Discrete) a. Graph
representation: adjacency list vs matrix 9\\. Trees (See also: MSF-Discrete) a.
Binary, n-ary, and search trees b. Balanced (e.g., AVL, Red-Black, Heap) 10\\.
Sets (See also: MSF-Discrete) 11\\. Search algorithms a. O(n) complexity (e.g.,
linear/sequential array/list search) b. O(log2 n) complexity (e.g., binary
search) c. O(logb n) complexity (e.g., uninformed depth/breadth-first tree
search) 12\\. Sorting algorithms (e.g., stable, unstable) a. O(n2) complexity
(e.g., insertion, selection), b. O(n log n) complexity (e.g., quicksort,
merge, timsort) 13\\. Graph algorithms a. Shortest path (e.g., Dijkstra's,
Floyd's) b. Minimal spanning tree (e.g., Prim's, Kruskal's) KA Core: 14\\.
Sorting algorithms a. O(n log n) complexity heapsort b. Pseudo O(n) complexity
(e.g., bucket, counting, radix) 15\\. Graph algorithms a. Transitive closure
(e.g., Warshall's) b. Topological sort 16\\. Matching a. Efficient string
matching (e.g., Boyer-Moore, Knuth-Morris-Pratt) b. Longest common subsequence
matching c. Regular expression matching Non-core: 17\\. Cryptography algorithms
(e.g., SHA-256) (See also: SEC-Crypto) 18\\. Parallel algorithms (See also:
PDC-Algorithms, FPL-Parallel) 19\\. Consensus algorithms (e.g., Blockchain)
(See also: SEC-Crypto) a. Proof of work vs proof of stake (See also: SEP-
Sustainability) 20\\. Quantum computing algorithms (See also: AL-Models, AR-
Quantum) a. Oracle-based (e.g., Deutsch-Jozsa, Bernstein-Vazirani, Simon) b.
Superpolynomial speed-up via QFT (e.g., Shor's) c. Polynomial speed-up via
amplitude amplification (e.g., Grover's) 21\\. Fast-Fourier Transform (FFT)
algorithm 22\\. Differential evolution algorithm Illustrative Learning
Outcomes: CS Core: 1\\. For each ADT/Data-Structure in this unit a. Explain its
definition, properties, representation(s), and associated ADT operations. b.
Explain step-by-step how the ADT operations associated with the data structure
transform it. 2\\. For each algorithm in this unit explain step-by-step how the
algorithm operates. 3\\. For each algorithmic approach (e.g., sorting) in this
unit apply a prototypical example of the approach (e.g., merge sort). 90 4\\.
Given requirements for a problem, develop multiple solutions using various
data structures and algorithms. Subsequently, evaluate the suitability,
strengths, and weaknesses selecting an approach that best satisfies the
requirements. 5\\. Explain how collision avoidance and collision resolution is
handled in hash tables. 6\\. Explain factors beyond computational efficiency
that influence the choice of algorithms, such as programming time,
maintainability, and the use of application-specific patterns in the input
data. 7\\. Explain the heap property and the use of heaps as an implementation
of a priority queue. KA Core: 8\\. For each of the algorithms and algorithmic
approaches in the KA Core topics: a. Explain a prototypical example of the
algorithm, and b. Explain step-by-step how the algorithm operates. Non-core:
9\\. An appreciation of quantum computation and its application to certain
problems."""^^xsd:string ;
            ns3:score "0.69644845"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on a subset of the KU, primarily evaluation of data structures and the divide and conquer approach, without covering the broader range of topics outlined in the KU." ;
            ns1:ka "Algorithmic_Foundations_AL" ;
            ns1:ku "AL-Foundational_Foundational_Data_Structures_and_Algorithms" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns3:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns3:score "0.6956569"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on data structures and Divide and Conquer algorithms, while KU covers logic programming concepts like unification, Horn clauses, and FOPL which are unrelated." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Logic_Logic_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt> ;
            ns3:ku_text """Pages:91-93 HOURS CS Core = 6 KA Core = 3 AL-Complexity: Complexity CS Core:
1\\. Complexity Analysis Framework a. Best, average, and worst-case performance
of an algorithm b. Empirical and relative (Order of Growth) measurements c.
Input size and primitive operations d. Time and space efficiency 2\\.
Asymptotic complexity analysis (average and worst-case bounds) a. Big-O, Big-
Omega, and Big-Theta formal notations b. Foundational Complexity Classes and
Representative Examples/Problems i. O(1) Constant (e.g., array access) ii.
O(log2 n) Logarithmic (e.g., binary search) iii. O(n) Linear (e.g., linear
search) iv. O(n log2 n) Log Linear (e.g., mergesort) v. O(n2) Quadratic (e.g.,
selection sort) vi. O(nc) Polynomial (e.g., O(n3) Gaussian elimination) vii.
O(2n) Exponential (e.g., Knapsack, Satisfiability (SAT), Traveling Sales-
Person (TSP), all subsets) viii. O(n!) Factorial (e.g., Hamiltonian circuit,
all permutations) 3\\. Empirical measurements of performance 4\\. Tractability
and intractability a. P, NP, and NP-Complete Complexity Classes b. NP-Complete
Problems (e.g., SAT, Knapsack, TSP) c. Reductions 5\\. Time and space tradeoffs
in algorithms 92 KA Core: 6\\. Little-o, Little-Omega, and Little Theta
notations 7\\. Formal recursive analysis 8\\. Amortized analysis 9\\. Turing
Machine-based models of complexity a. Time complexity i. P, NP, NP-C, and EXP
classes ii. Cook-Levin theorem b. Space Complexity i. NSpace and PSpace ii.
Savitch's theorem Illustrative Learning Outcomes: CS Core: 1\\. Prepare a
presentation that explains to first year students the basic concepts of
algorithmic complexity including best, average, and worst-case algorithm
behavior, Big- O, Omega, and Theta notations, complexity classes, time and
space tradeoffs, empirical measurement, and impact on practical problems. 2\\.
Using examples, explain each of the foundational complexity classes in this
unit. 3\\. For each foundational complexity class in this unit, explain an
algorithm that demonstrates the associated runtime complexity. 4\\. For each
algorithm in the AL-Foundational unit, explain its runtime complexity class
and why it belongs to this class. 5\\. Informally evaluate the foundational
complexity class of simple algorithms. 6\\. Given a problem to program for
which there may be several algorithmic approaches, evaluate them and determine
which are feasible, and select one that is optimal in implementation and run-
time behavior. 7\\. Develop empirical studies to determine and validate
hypotheses about the runtime complexity of various algorithms by running
algorithms on input of various sizes and comparing actual performance to the
theoretical analysis. 8\\. Explain examples that illustrate time-space
tradeoffs of algorithms. 9\\. Explain how tree balance affects the efficiency
of binary search tree operations. 10\\. Explain to a non-technical audience the
significance of tractable versus intractable algorithms using an intuitive
explanation of Big-O complexity. 11\\. Explain the significance of NP-
Completeness. 12\\. Explain how NP-Hard is a lower bound and NP is an upper
bound for NP-Completeness. 13\\. Explain examples of NP-complete problems. KA
Core: 14\\. Use recurrence relations to evaluate the time complexity of
recursively defined algorithms. 15\\. Apply elementary recurrence relations
using a form of the Master Theorem. 16\\. Apply Big-O notation to give upper
case bounds on time/space complexity of algorithms. 17\\. Explain the Cook-
Levin Theorem and the NP-Completeness of SAT. 93 18\\. Explain the classes P
and NP. 19\\. Prove that a problem is NP-Complete by reducing a classic known
NP-C problem to it (e.g., 3SAT and Clique). 20\\. Explain the P-space class and
its relation to the EXP class."""^^xsd:string ;
            ns3:score "0.6920693"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on evaluation of data structures and Divide and Conquer, but KU requires broader coverage of complexity theory, asymptotic notations, P/NP, and formal proofs which are not explicitly addressed." ;
            ns1:ka "Algorithmic_Foundations_AL" ;
            ns1:ku "AL-Complexity_Complexity" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt> ;
            ns3:ku_text """Pages:91-93 HOURS CS Core = 6 KA Core = 3 AL-Complexity: Complexity CS Core:
1\\. Complexity Analysis Framework a. Best, average, and worst-case performance
of an algorithm b. Empirical and relative (Order of Growth) measurements c.
Input size and primitive operations d. Time and space efficiency 2\\.
Asymptotic complexity analysis (average and worst-case bounds) a. Big-O, Big-
Omega, and Big-Theta formal notations b. Foundational Complexity Classes and
Representative Examples/Problems i. O(1) Constant (e.g., array access) ii.
O(log2 n) Logarithmic (e.g., binary search) iii. O(n) Linear (e.g., linear
search) iv. O(n log2 n) Log Linear (e.g., mergesort) v. O(n2) Quadratic (e.g.,
selection sort) vi. O(nc) Polynomial (e.g., O(n3) Gaussian elimination) vii.
O(2n) Exponential (e.g., Knapsack, Satisfiability (SAT), Traveling Sales-
Person (TSP), all subsets) viii. O(n!) Factorial (e.g., Hamiltonian circuit,
all permutations) 3\\. Empirical measurements of performance 4\\. Tractability
and intractability a. P, NP, and NP-Complete Complexity Classes b. NP-Complete
Problems (e.g., SAT, Knapsack, TSP) c. Reductions 5\\. Time and space tradeoffs
in algorithms 92 KA Core: 6\\. Little-o, Little-Omega, and Little Theta
notations 7\\. Formal recursive analysis 8\\. Amortized analysis 9\\. Turing
Machine-based models of complexity a. Time complexity i. P, NP, NP-C, and EXP
classes ii. Cook-Levin theorem b. Space Complexity i. NSpace and PSpace ii.
Savitch's theorem Illustrative Learning Outcomes: CS Core: 1\\. Prepare a
presentation that explains to first year students the basic concepts of
algorithmic complexity including best, average, and worst-case algorithm
behavior, Big- O, Omega, and Theta notations, complexity classes, time and
space tradeoffs, empirical measurement, and impact on practical problems. 2\\.
Using examples, explain each of the foundational complexity classes in this
unit. 3\\. For each foundational complexity class in this unit, explain an
algorithm that demonstrates the associated runtime complexity. 4\\. For each
algorithm in the AL-Foundational unit, explain its runtime complexity class
and why it belongs to this class. 5\\. Informally evaluate the foundational
complexity class of simple algorithms. 6\\. Given a problem to program for
which there may be several algorithmic approaches, evaluate them and determine
which are feasible, and select one that is optimal in implementation and run-
time behavior. 7\\. Develop empirical studies to determine and validate
hypotheses about the runtime complexity of various algorithms by running
algorithms on input of various sizes and comparing actual performance to the
theoretical analysis. 8\\. Explain examples that illustrate time-space
tradeoffs of algorithms. 9\\. Explain how tree balance affects the efficiency
of binary search tree operations. 10\\. Explain to a non-technical audience the
significance of tractable versus intractable algorithms using an intuitive
explanation of Big-O complexity. 11\\. Explain the significance of NP-
Completeness. 12\\. Explain how NP-Hard is a lower bound and NP is an upper
bound for NP-Completeness. 13\\. Explain examples of NP-complete problems. KA
Core: 14\\. Use recurrence relations to evaluate the time complexity of
recursively defined algorithms. 15\\. Apply elementary recurrence relations
using a form of the Master Theorem. 16\\. Apply Big-O notation to give upper
case bounds on time/space complexity of algorithms. 17\\. Explain the Cook-
Levin Theorem and the NP-Completeness of SAT. 93 18\\. Explain the classes P
and NP. 19\\. Prove that a problem is NP-Complete by reducing a classic known
NP-C problem to it (e.g., 3SAT and Clique). 20\\. Explain the P-space class and
its relation to the EXP class."""^^xsd:string ;
            ns3:score "0.6920693"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers basic concepts but lacks depth on advanced topics like NP-completeness and asymptotic notations." ;
            ns1:ka "Algorithmic_Foundations_AL" ;
            ns1:ku "AL-Complexity_Complexity" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ] ;
    ns3:uetext """Label: Algorithmique et Structures de données 1 Objectif: (résultats d'apprentissage)
•
Évaluer une implémentation de structure de données en temps et en place mémoire (coûts minimal,
maximal, amorti)
• Course content: et mise en pratique dans l’approche de résolution de problèmes « Diviser pour régner ». Course name: http://example.org/course/UE_XLG3IU010""" .

ns1:UE_XLG3IU020 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns3:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns3:score "0.6991599"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a large subset of the KU, particularly focusing on logic and proof systems." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns3:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns3:score "0.6991599"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including topics such as logic, sets, relations, functions, and graph theory, with some overlap in the course content." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns3:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns3:score "0.6991599"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including topics such as logic, sets, relations, functions, and graph theory, with some overlap in the course content." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns3:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns3:score "0.69964516"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on logic and proof systems, while the KU covers formal semantics and type systems, with minimal overlap." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Formalism_Formal_Semantics" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns3:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns3:score "0.69964516"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture covers logic systems and proofs but lacks focus on axiomatic/operational/denotational semantics and type systems central to the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Formalism_Formal_Semantics" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns3:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns3:score "0.69964516"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as logical deduction, proof systems, and formal semantics, which are all relevant to the Knowledge Unit's content." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Formalism_Formal_Semantics" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns3:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns3:score "0.69964516"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture covers logic systems and proofs but lacks focus on axiomatic/operational/denotational semantics and type systems central to the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Formalism_Formal_Semantics" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns3:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns3:score "0.6991599"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a large subset of the KU, particularly focusing on logic and proof systems." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt> ;
            ns3:ku_text """Pages:70-70 HOURS CS Core = 2 KA Core = 2 AI-KRR: Fundamental Knowledge
Representation and Reasoning CS Core: 1\\. Types of representations a.
Symbolic, logical i. Creating a representation from a natural language problem
statement b. Learned subsymbolic representations c. Graphical models (e.g.,
naive Bayes, Bayesian network) 2\\. Review of probabilistic reasoning, Bayes
theorem (See also: MSF-Probability) 3\\. Bayesian reasoning a. Bayesian
inference KA Core: 4\\. Random variables and probability distributions a.
Axioms of probability b. Probabilistic inference c. Bayes' Rule (derivation)
d. Bayesian inference (more complex examples) 5\\. Independence 6\\. Conditional
Independence 7\\. Markov chains and Markov models 8\\. Utility and decision
making Illustrative Learning Outcomes: 1\\. Given a natural language problem
statement, encode it as a symbolic or logical representation. 2\\. Explain how
we can make decisions under uncertainty, using concepts such as Bayes theorem
and utility. 3\\. Compute a probabilistic inference in a real-world problem
using Bayes' theorem to determine the probability of a hypothesis given
evidence. 4\\. Apply Bayes' rule to determine the probability of a hypothesis
given evidence. 5\\. Compute the probability of outcomes and test whether
outcomes are independent. 71 AI-ML: Machine Learning CS Core: 1\\. Definition
and examples of a broad variety of machine learning tasks a. Supervised
learning i. Classification ii. Regression b. Reinforcement learning c.
Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability"""^^xsd:string ;
            ns3:score "0.7135371"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on logic systems and proof methods, while KU includes probabilistic reasoning, Bayesian methods, and machine learning not covered." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns3:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns3:score "0.69964516"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on logic and proof systems, while the KU covers formal semantics and type systems, with minimal overlap." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Formalism_Formal_Semantics" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt> ;
            ns3:ku_text """Pages:70-70 HOURS CS Core = 2 KA Core = 2 AI-KRR: Fundamental Knowledge
Representation and Reasoning CS Core: 1\\. Types of representations a.
Symbolic, logical i. Creating a representation from a natural language problem
statement b. Learned subsymbolic representations c. Graphical models (e.g.,
naive Bayes, Bayesian network) 2\\. Review of probabilistic reasoning, Bayes
theorem (See also: MSF-Probability) 3\\. Bayesian reasoning a. Bayesian
inference KA Core: 4\\. Random variables and probability distributions a.
Axioms of probability b. Probabilistic inference c. Bayes' Rule (derivation)
d. Bayesian inference (more complex examples) 5\\. Independence 6\\. Conditional
Independence 7\\. Markov chains and Markov models 8\\. Utility and decision
making Illustrative Learning Outcomes: 1\\. Given a natural language problem
statement, encode it as a symbolic or logical representation. 2\\. Explain how
we can make decisions under uncertainty, using concepts such as Bayes theorem
and utility. 3\\. Compute a probabilistic inference in a real-world problem
using Bayes' theorem to determine the probability of a hypothesis given
evidence. 4\\. Apply Bayes' rule to determine the probability of a hypothesis
given evidence. 5\\. Compute the probability of outcomes and test whether
outcomes are independent. 71 AI-ML: Machine Learning CS Core: 1\\. Definition
and examples of a broad variety of machine learning tasks a. Supervised
learning i. Classification ii. Regression b. Reinforcement learning c.
Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability"""^^xsd:string ;
            ns3:score "0.7135371"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on formal logic and proof systems, while the KU covers broader topics including probability, Bayesian reasoning, and machine learning, which are not addressed in the lecture." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns3:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns3:score "0.6991599"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "Covers logic, proof systems, normal forms, unification, resolution, and inference rules aligning with KU's logic objectives." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt> ;
            ns3:ku_text """Pages:70-70 HOURS CS Core = 2 KA Core = 2 AI-KRR: Fundamental Knowledge
Representation and Reasoning CS Core: 1\\. Types of representations a.
Symbolic, logical i. Creating a representation from a natural language problem
statement b. Learned subsymbolic representations c. Graphical models (e.g.,
naive Bayes, Bayesian network) 2\\. Review of probabilistic reasoning, Bayes
theorem (See also: MSF-Probability) 3\\. Bayesian reasoning a. Bayesian
inference KA Core: 4\\. Random variables and probability distributions a.
Axioms of probability b. Probabilistic inference c. Bayes' Rule (derivation)
d. Bayesian inference (more complex examples) 5\\. Independence 6\\. Conditional
Independence 7\\. Markov chains and Markov models 8\\. Utility and decision
making Illustrative Learning Outcomes: 1\\. Given a natural language problem
statement, encode it as a symbolic or logical representation. 2\\. Explain how
we can make decisions under uncertainty, using concepts such as Bayes theorem
and utility. 3\\. Compute a probabilistic inference in a real-world problem
using Bayes' theorem to determine the probability of a hypothesis given
evidence. 4\\. Apply Bayes' rule to determine the probability of a hypothesis
given evidence. 5\\. Compute the probability of outcomes and test whether
outcomes are independent. 71 AI-ML: Machine Learning CS Core: 1\\. Definition
and examples of a broad variety of machine learning tasks a. Supervised
learning i. Classification ii. Regression b. Reinforcement learning c.
Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability"""^^xsd:string ;
            ns3:score "0.7135371"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on logic systems and proof methods, while KU includes probabilistic reasoning, Bayesian methods, and machine learning not covered." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns3:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns3:score "0.69964516"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as logical deduction, proof systems, and formal semantics, which are all relevant to the Knowledge Unit's content." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Formalism_Formal_Semantics" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt> ;
            ns3:ku_text """Pages:70-70 HOURS CS Core = 2 KA Core = 2 AI-KRR: Fundamental Knowledge
Representation and Reasoning CS Core: 1\\. Types of representations a.
Symbolic, logical i. Creating a representation from a natural language problem
statement b. Learned subsymbolic representations c. Graphical models (e.g.,
naive Bayes, Bayesian network) 2\\. Review of probabilistic reasoning, Bayes
theorem (See also: MSF-Probability) 3\\. Bayesian reasoning a. Bayesian
inference KA Core: 4\\. Random variables and probability distributions a.
Axioms of probability b. Probabilistic inference c. Bayes' Rule (derivation)
d. Bayesian inference (more complex examples) 5\\. Independence 6\\. Conditional
Independence 7\\. Markov chains and Markov models 8\\. Utility and decision
making Illustrative Learning Outcomes: 1\\. Given a natural language problem
statement, encode it as a symbolic or logical representation. 2\\. Explain how
we can make decisions under uncertainty, using concepts such as Bayes theorem
and utility. 3\\. Compute a probabilistic inference in a real-world problem
using Bayes' theorem to determine the probability of a hypothesis given
evidence. 4\\. Apply Bayes' rule to determine the probability of a hypothesis
given evidence. 5\\. Compute the probability of outcomes and test whether
outcomes are independent. 71 AI-ML: Machine Learning CS Core: 1\\. Definition
and examples of a broad variety of machine learning tasks a. Supervised
learning i. Classification ii. Regression b. Reinforcement learning c.
Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability"""^^xsd:string ;
            ns3:score "0.7135371"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on formal logic and proof systems, while the KU covers broader topics including probability, Bayesian reasoning, and machine learning, which are not addressed in the lecture." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt> ;
            ns3:ku_text """Pages:70-70 HOURS CS Core = 2 KA Core = 2 AI-KRR: Fundamental Knowledge
Representation and Reasoning CS Core: 1\\. Types of representations a.
Symbolic, logical i. Creating a representation from a natural language problem
statement b. Learned subsymbolic representations c. Graphical models (e.g.,
naive Bayes, Bayesian network) 2\\. Review of probabilistic reasoning, Bayes
theorem (See also: MSF-Probability) 3\\. Bayesian reasoning a. Bayesian
inference KA Core: 4\\. Random variables and probability distributions a.
Axioms of probability b. Probabilistic inference c. Bayes' Rule (derivation)
d. Bayesian inference (more complex examples) 5\\. Independence 6\\. Conditional
Independence 7\\. Markov chains and Markov models 8\\. Utility and decision
making Illustrative Learning Outcomes: 1\\. Given a natural language problem
statement, encode it as a symbolic or logical representation. 2\\. Explain how
we can make decisions under uncertainty, using concepts such as Bayes theorem
and utility. 3\\. Compute a probabilistic inference in a real-world problem
using Bayes' theorem to determine the probability of a hypothesis given
evidence. 4\\. Apply Bayes' rule to determine the probability of a hypothesis
given evidence. 5\\. Compute the probability of outcomes and test whether
outcomes are independent. 71 AI-ML: Machine Learning CS Core: 1\\. Definition
and examples of a broad variety of machine learning tasks a. Supervised
learning i. Classification ii. Regression b. Reinforcement learning c.
Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability"""^^xsd:string ;
            ns3:score "0.7135371"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics in logic, proof systems, and reasoning, which align with the KU's focus on fundamental knowledge representation and reasoning in AI-KRR and CS Core." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns3:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns3:score "0.6991599"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "Covers logic, proof systems, normal forms, unification, resolution, and inference rules aligning with KU's logic objectives." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt> ;
            ns3:ku_text """Pages:70-70 HOURS CS Core = 2 KA Core = 2 AI-KRR: Fundamental Knowledge
Representation and Reasoning CS Core: 1\\. Types of representations a.
Symbolic, logical i. Creating a representation from a natural language problem
statement b. Learned subsymbolic representations c. Graphical models (e.g.,
naive Bayes, Bayesian network) 2\\. Review of probabilistic reasoning, Bayes
theorem (See also: MSF-Probability) 3\\. Bayesian reasoning a. Bayesian
inference KA Core: 4\\. Random variables and probability distributions a.
Axioms of probability b. Probabilistic inference c. Bayes' Rule (derivation)
d. Bayesian inference (more complex examples) 5\\. Independence 6\\. Conditional
Independence 7\\. Markov chains and Markov models 8\\. Utility and decision
making Illustrative Learning Outcomes: 1\\. Given a natural language problem
statement, encode it as a symbolic or logical representation. 2\\. Explain how
we can make decisions under uncertainty, using concepts such as Bayes theorem
and utility. 3\\. Compute a probabilistic inference in a real-world problem
using Bayes' theorem to determine the probability of a hypothesis given
evidence. 4\\. Apply Bayes' rule to determine the probability of a hypothesis
given evidence. 5\\. Compute the probability of outcomes and test whether
outcomes are independent. 71 AI-ML: Machine Learning CS Core: 1\\. Definition
and examples of a broad variety of machine learning tasks a. Supervised
learning i. Classification ii. Regression b. Reinforcement learning c.
Unsupervised learning i. Clustering 2\\. Fundamental ideas: a. No free lunch
theorem: no one learner can solve all problems; representational design
decisions have consequences. b. Sources of error and undecidability"""^^xsd:string ;
            ns3:score "0.7135371"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics in logic, proof systems, and reasoning, which align with the KU's focus on fundamental knowledge representation and reasoning in AI-KRR and CS Core." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ] ;
    ns3:uetext """Label: Logique pour l'informatique Objectif: (résultats d'apprentissage)
consistance et complétude d'un système de preuves.
4. Représenter une preuve de la déduction naturelle sous forme d'arbre d'inférence.
5. Utiliser les algorithmes d'unification et de résolution pour le raisonnement automatique sur les
formules logiques.
1) Raisonnement algébrique booléen
• Dualités des connecteurs logiques
• Formes normales conjonctive et disjonctive
2) Systèmes de preuves
• Système d'inférence associé à une définition inductive
• Preuve d'appartenance à un ensemble inductif par un arbre de preuves
• Règles d'inférences de la déduction naturelle pour la logique propositionnelle
• Distinguer logique classique et logique intuitionniste
3) Donner du sens aux langages logique Course content: • Interprétation, modèle, satisfiabilité, validité
• Correspondance avec le système de preuve: correction et complétude
4) Calcul des prédicats
• Manipulation des quantificateurs
• Skolémisation, forme clausale
• Théorie logique
5) Raisonner automatiquement sur les formules logique
• Algorithme d'unification
• Algorithme de résolution Course name: http://example.org/course/UE_XLG3IU020""" .

ns1:UE_XLG3IU030 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.6746223"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on OOP (inheritance/polymorphism/abstract classes), while KU centers on functional programming concepts (lambda, immutability, closures) which are not covered." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt> ;
            ns3:ku_text """Pages: 130-131 HOURS CS Core = 4 + 1 (SDF) KA Core = 1 FPL-OOP: Object-
Oriented Programming CS Core: 1\\. Imperative programming as a subset of
object-oriented programming. 2\\. Object-oriented design: a. Decomposition into
objects carrying state and having behavior. b. Class-hierarchy design for
modeling. 3\\. Definition of classes: fields, methods, and constructors. (See
also: SDF-Fundamentals) 4\\. Subclasses, inheritance (including multiple
inheritance), and method overriding. 5\\. Dynamic dispatch: definition of
method-call. 6\\. Exception handling. (See also: SDF-Fundamentals, PDC-
Coordination, SE-Construction) 7\\. Object-oriented idioms for encapsulation:
a. Privacy, data hiding, and visibility of class members. b. Interfaces
revealing only method signatures. c. Abstract base classes, traits and mixins.
8\\. Dynamic vs static properties. 9\\. Composition vs inheritance. 10\\.
Subtyping: a. Subtype polymorphism; implicit upcasts in typed languages. b.
Notion of behavioral replacement: subtypes acting like supertype. c.
Relationship between subtyping and inheritance. KA Core: 11\\. Collection
classes, iterators, and other common library components. 12\\. Metaprogramming
and reflection. Illustrative Learning Outcomes: CS Core: 1\\. Enumerate the
differences between imperative and object-oriented programming paradigms. 2\\.
Compose a class through design, implementation, and testing to meet behavioral
requirements. 3\\. Build a simple class hierarchy utilizing subclassing that
allows code to be reused for distinct subclasses. 4\\. Predict and validate
control flow in a program using dynamic dispatch. 5\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 6\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. 7\\. Compare and contrast the benefits and costs/impact of using
inheritance (subclasses) and composition (specifically, how to base
composition on higher order functions). 8\\. Explain the relationship between
object-oriented inheritance (code-sharing and overriding) and subtyping (the
idea of a subtype being usable in a context that expects the supertype). 9\\.
Use object-oriented encapsulation mechanisms such as interfaces and private
members. 10\\. Define and use iterators and other operations on aggregates,
including operations that take functions as arguments, in multiple programming
languages, selecting the most natural idioms for each language. (See also:
FPL-Functional) KA Core: 11\\. Use collection classes and iterators effectively
to solve a problem."""^^xsd:string ;
            ns3:score "0.6819768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture covers inheritance/polymorphism basics but lacks broader KU topics like dynamic dispatch, encapsulation details, composition vs inheritance, and subtyping relationships." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-OOP_Object-Oriented_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.6746223"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on object-oriented programming concepts, while the KU covers functional programming topics." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns3:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns3:score "0.6790555"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on object-oriented programming, while the KU covers logic programming." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Logic_Logic_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns3:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns3:score "0.6790555"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including topics such as classes, abstract classes, inheritance, polymorphism, and logic programming." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Logic_Logic_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt> ;
            ns3:ku_text """Pages: 130-131 HOURS CS Core = 4 + 1 (SDF) KA Core = 1 FPL-OOP: Object-
Oriented Programming CS Core: 1\\. Imperative programming as a subset of
object-oriented programming. 2\\. Object-oriented design: a. Decomposition into
objects carrying state and having behavior. b. Class-hierarchy design for
modeling. 3\\. Definition of classes: fields, methods, and constructors. (See
also: SDF-Fundamentals) 4\\. Subclasses, inheritance (including multiple
inheritance), and method overriding. 5\\. Dynamic dispatch: definition of
method-call. 6\\. Exception handling. (See also: SDF-Fundamentals, PDC-
Coordination, SE-Construction) 7\\. Object-oriented idioms for encapsulation:
a. Privacy, data hiding, and visibility of class members. b. Interfaces
revealing only method signatures. c. Abstract base classes, traits and mixins.
8\\. Dynamic vs static properties. 9\\. Composition vs inheritance. 10\\.
Subtyping: a. Subtype polymorphism; implicit upcasts in typed languages. b.
Notion of behavioral replacement: subtypes acting like supertype. c.
Relationship between subtyping and inheritance. KA Core: 11\\. Collection
classes, iterators, and other common library components. 12\\. Metaprogramming
and reflection. Illustrative Learning Outcomes: CS Core: 1\\. Enumerate the
differences between imperative and object-oriented programming paradigms. 2\\.
Compose a class through design, implementation, and testing to meet behavioral
requirements. 3\\. Build a simple class hierarchy utilizing subclassing that
allows code to be reused for distinct subclasses. 4\\. Predict and validate
control flow in a program using dynamic dispatch. 5\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 6\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. 7\\. Compare and contrast the benefits and costs/impact of using
inheritance (subclasses) and composition (specifically, how to base
composition on higher order functions). 8\\. Explain the relationship between
object-oriented inheritance (code-sharing and overriding) and subtyping (the
idea of a subtype being usable in a context that expects the supertype). 9\\.
Use object-oriented encapsulation mechanisms such as interfaces and private
members. 10\\. Define and use iterators and other operations on aggregates,
including operations that take functions as arguments, in multiple programming
languages, selecting the most natural idioms for each language. (See also:
FPL-Functional) KA Core: 11\\. Use collection classes and iterators effectively
to solve a problem."""^^xsd:string ;
            ns3:score "0.6819768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some aspects of OOP like inheritance and polymorphism but lacks coverage of other key topics in the KU such as exception handling, metaprogramming, and collection classes." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-OOP_Object-Oriented_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt> ;
            ns3:ku_text """Pages: 130-131 HOURS CS Core = 4 + 1 (SDF) KA Core = 1 FPL-OOP: Object-
Oriented Programming CS Core: 1\\. Imperative programming as a subset of
object-oriented programming. 2\\. Object-oriented design: a. Decomposition into
objects carrying state and having behavior. b. Class-hierarchy design for
modeling. 3\\. Definition of classes: fields, methods, and constructors. (See
also: SDF-Fundamentals) 4\\. Subclasses, inheritance (including multiple
inheritance), and method overriding. 5\\. Dynamic dispatch: definition of
method-call. 6\\. Exception handling. (See also: SDF-Fundamentals, PDC-
Coordination, SE-Construction) 7\\. Object-oriented idioms for encapsulation:
a. Privacy, data hiding, and visibility of class members. b. Interfaces
revealing only method signatures. c. Abstract base classes, traits and mixins.
8\\. Dynamic vs static properties. 9\\. Composition vs inheritance. 10\\.
Subtyping: a. Subtype polymorphism; implicit upcasts in typed languages. b.
Notion of behavioral replacement: subtypes acting like supertype. c.
Relationship between subtyping and inheritance. KA Core: 11\\. Collection
classes, iterators, and other common library components. 12\\. Metaprogramming
and reflection. Illustrative Learning Outcomes: CS Core: 1\\. Enumerate the
differences between imperative and object-oriented programming paradigms. 2\\.
Compose a class through design, implementation, and testing to meet behavioral
requirements. 3\\. Build a simple class hierarchy utilizing subclassing that
allows code to be reused for distinct subclasses. 4\\. Predict and validate
control flow in a program using dynamic dispatch. 5\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 6\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. 7\\. Compare and contrast the benefits and costs/impact of using
inheritance (subclasses) and composition (specifically, how to base
composition on higher order functions). 8\\. Explain the relationship between
object-oriented inheritance (code-sharing and overriding) and subtyping (the
idea of a subtype being usable in a context that expects the supertype). 9\\.
Use object-oriented encapsulation mechanisms such as interfaces and private
members. 10\\. Define and use iterators and other operations on aggregates,
including operations that take functions as arguments, in multiple programming
languages, selecting the most natural idioms for each language. (See also:
FPL-Functional) KA Core: 11\\. Use collection classes and iterators effectively
to solve a problem."""^^xsd:string ;
            ns3:score "0.6819768"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers most of the topics mentioned in the KU, including classes, inheritance, polymorphism, and object-oriented design." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-OOP_Object-Oriented_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns3:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns3:score "0.6790555"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture covers OOP inheritance/poly, KU focuses on logic programming core (unification, Horn clauses). No substantial overlap." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Logic_Logic_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.6746223"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including topics such as lambda expressions, effect-free programming, and higher-order functions, which are all core components of the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ] ;
    ns3:uetext "Label: Programmation à Objets Objectif: (résultats d'apprentissage) Connaître les mécanismes d’héritage et de polymorphisme Course content: Classes abstraites Course name: http://example.org/course/UE_XLG3IU030" .

ns1:UE_XLG3MU030 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on linear algebra, not data modeling." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on mathematics (analysis/linear algebra), while KU covers HCI evaluation methods and ethics—no substantive overlap." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on linear algebra, not data modeling." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on linear algebra, which is foundational but not directly covering the specific graphics and visualization topics outlined in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on linear algebra, which is foundational but not directly covering the specific graphics and visualization topics outlined in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on mathematics (analysis/linear algebra), while KU covers HCI evaluation methods and ethics—no substantive overlap." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 topics mentioned in the KU, including graphics pipeline architecture, transformations, and rendering techniques." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on mathematics (analysis/linear algebra), while KU covers HCI evaluation methods and ethics—no substantive overlap." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture content does not substantially cover the knowledge unit described." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on analysis/linear algebra, not graphics/visualization topics in KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on linear algebra, not data modeling." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the relational data model, data modeling, and conceptual models, which are a significant subset of the Knowledge Unit's content." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 topics mentioned in the KU, including graphics pipeline architecture, transformations, and rendering techniques." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on mathematics (analysis/linear algebra), while KU covers data modeling concepts unrelated to math topics." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on linear algebra, which is foundational but not directly covering the specific graphics and visualization topics outlined in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on linear algebra, not data modeling." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 topics mentioned in the KU, including graphics pipeline architecture, transformations, and rendering techniques." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the relational data model, data modeling, and conceptual models, which are a significant subset of the Knowledge Unit's content." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on mathematics (analysis/linear algebra), while KU covers data modeling concepts unrelated to math topics." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the relational data model, data modeling, and conceptual models, which are a significant subset of the Knowledge Unit's content." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the majority of the KU's topics, including evaluation methods, study planning, and implications of design, but does not delve into specific statistical tests and data management." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on mathematics (analysis/linear algebra), while KU covers HCI evaluation methods and ethics—no substantive overlap." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on linear algebra, which is foundational but not directly covering the specific graphics and visualization topics outlined in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on analysis/linear algebra, not graphics/visualization topics in KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the majority of the KU's topics, including evaluation methods, study planning, and implications of design, but does not delve into specific statistical tests and data management." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture content does not substantially cover the knowledge unit described." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on linear algebra, which is foundational but not directly covering the specific graphics and visualization topics outlined in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture content does not substantially cover the knowledge unit described." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the majority of the KU's topics, including evaluation methods, study planning, and implications of design, but does not delve into specific statistical tests and data management." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on mathematics (analysis/linear algebra), while KU covers data modeling concepts unrelated to math topics." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on linear algebra, not data modeling." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the relational data model, data modeling, and conceptual models, which are a significant subset of the Knowledge Unit's content." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the majority of the KU's topics, including evaluation methods, study planning, and implications of design, but does not delve into specific statistical tests and data management." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on mathematics (analysis/linear algebra), while KU covers data modeling concepts unrelated to math topics." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on analysis/linear algebra, not graphics/visualization topics in KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 topics mentioned in the KU, including graphics pipeline architecture, transformations, and rendering techniques." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture content does not substantially cover the knowledge unit described." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the majority of the KU's topics, including evaluation methods, study planning, and implications of design, but does not delve into specific statistical tests and data management." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 topics mentioned in the KU, including graphics pipeline architecture, transformations, and rendering techniques." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the relational data model, data modeling, and conceptual models, which are a significant subset of the Knowledge Unit's content." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on analysis/linear algebra, not graphics/visualization topics in KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.62657344"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on analysis/linear algebra, not graphics/visualization topics in KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture content does not substantially cover the knowledge unit described." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6361048"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on mathematics (analysis/linear algebra), while KU covers data modeling concepts unrelated to math topics." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt> ;
            ns3:ku_text """Pages: 178-179 HOURS CS Core = 1 KA Core = 2 HCI-Evaluation: Evaluating the
Design CS Core: 1\\. Methods for evaluation with users a. Formative (e.g.,
needs-finding, exploratory analysis) and summative assessment (e.g.,
functionality and usability testing) b. Elements to evaluate (e.g., utility,
efficiency, learnability, user satisfaction, affective elements such as
pleasure and engagement) c. Understanding ethical approval requirements before
engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-
Security, SEP-Privacy, SEP-Professional-Ethics) KA Core: 2\\. Methods for
evaluation with users (See also: SE-Validation) a. Qualitative methods
(qualitative coding and thematic analysis) b. Quantitative methods
(statistical tests) c. Mixed methods (e.g., observation, think-aloud,
interview, survey, experiment) d. Presentation requirements (e.g., reports,
personas) e. User-centered testing f. Heuristic evaluation g. Challenges and
shortcomings to effective evaluation (e.g., sampling, generalization) 3\\.
Study planning a. How to set study goals b. Hypothesis design c. Approvals
from Institutional Research Boards and ethics committees (See also: SEP-
EthicalAnalysis, SEP-Security, SEP-Privacy) d. How to pre-register a study e.
Within-subjects vs between-subjects design 4\\. Implications and impacts of
design with respect to the environment, material, society, security, privacy,
ethics, and broader impacts. (See also: SEC-Foundations) a. The environment b.
Material c. Society d. Security e. Privacy f. Ethics g. Broader impacts Non-
core: 5\\. Techniques and tools for quantitative analysis a. Statistical
packages b. Visualization tools c. Statistical tests (e.g., ANOVA, t-tests,
post-hoc analysis, parametric vs non-parametric tests) d. Data exploration and
visual analytics; how to calculate effect size. 6\\. Data management a. Data
storage and data sharing (open science) b. Sensitivity and identifiability.
Illustrative Learning Outcomes: CS Core: 1\\. Discuss the differences between
formative and summative assessment and their role in evaluating design KA
Core: 2\\. Select appropriate formative or summative evaluation methods at
different points throughout the development of a design. 3\\. Discuss the
benefits of using both qualitative and quantitative methods for evaluation.
4\\. Evaluate the implications and broader impacts of a given design. 5\\. Plan
a usability evaluation for a given user interface, and justify its study
goals, hypothesis design, and study design. 6\\. Conduct a usability evaluation
of a given user interface and draw defensible conclusions given the study
design. Non-core: 7\\. Select and run appropriate statistical tests on provided
study data to test for significance in the results. 8\\. Pre-register a study
design, with planned statistical tests"""^^xsd:string ;
            ns3:score "0.6248374"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on mathematics (analysis/linear algebra), while KU covers HCI evaluation methods and ethics—no substantive overlap." ;
            ns1:ka "Human_Computer_Interaction_HCI" ;
            ns1:ku "HCI-Evaluation_Evaluating_the_Design" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ] ;
    ns3:uetext "Label: Analyse et Algebre lineaire 2 Objectif: (résultats d'apprentissage) • Course content: • Course name: http://example.org/course/UE_XLG3MU030" .

ns1:UE_XLG3MU040 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some discrete probability topics but lacks coverage of continuous variables, expectation, variance, and applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7497195"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on discrete variables and specific distributions but lacks coverage of continuous variables, expectation/CLT, and core applications." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7301263"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt> ;
            ns3:ku_text """Pages: 188-189 HOURS CS Core = 11 KA Core = 29 MSF-Probability: Probability CS
Core: 1\\. Basic notions: sample spaces, events, probability, conditional
probability, Bayes' rule 2\\. Discrete random variables and distributions 3\\.
Continuous random variables and distributions 4\\. Expectation, variance, law
of large numbers, central limit theorem 5\\. Conditional distributions and
expectation 6\\. Applications to computing, the difference between probability
and statistics (as subjects) KA Core: The recommended topics are the same
between CS core and KA-core, but with far more hours, the KA-core can cover
these topics in depth and might include more computing-related applications.
Illustrative Learning Outcomes: CS Core: 1\\. Basic notions: sample spaces,
events, probability, conditional probability, Bayes' rule a. Translate a prose
description of a probabilistic process into a formal setting of sample spaces,
outcome probabilities, and events. b. Calculate the probability of simple
events. c. Determine whether two events are independent. d. Compute
conditional probabilities, including through applying (and explaining) Bayes'
Rule. 2\\. Discrete random variables and distributions a. Define the concept of
a random variable and indicator random variable. b. Determine whether two
random variables are independent. c. Identify common discrete distributions
(e.g., uniform, Bernoulli, binomial, geometric). 3\\. Continuous random
variables and distributions a. Identify common continuous distributions (e.g.,
uniform, normal, exponential). b. Calculate probabilities using cumulative
density functions. 4\\. Expectation, variance, law of large numbers, central
limit theorem a. Define the concept of expectation and variance of a random
variable. b. Compute the expected value and variance of simple or common
discrete/continuous random variables. c. Explain the relevance of the law of
large numbers and central limit theorem to probability calculations. 5\\.
Conditional distributions and expectation a. Explain the distinction between
joint, marginal, and conditional distributions. b. Compute marginal and
conditional distributions from a full distribution, for both discrete and
continuous random variables. c. Compute conditional expectations for both
discrete and continuous random variables. 6\\. Applications to computing a.
Describe how probability can be used to model real-life situations or
applications, such as predictive text, hash tables, and quantum computation.
b. Apply probabilistic processes to solving computational problems, such as
through randomized algorithms or in security contexts."""^^xsd:string ;
            ns3:score "0.7405294"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basic notions, discrete and continuous random variables, and conditional distributions, which are the core topics of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Probability_Probability" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ] ;
    ns3:uetext """Label: Probabilites discretes Objectif: (résultats d'apprentissage) • Course content: - Couple de variables aléatoires discrètes (conditionnement, indépendance, corrélation).
- Lois uniforme, Bernoulli, binomiale et hypergéométrique.
• Course name: http://example.org/course/UE_XLG3MU040""" .

ns1:UE_XLG3TU010 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional insertion, not programming platforms or languages." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional integration, while KU covers formal methods in software engineering. No substantial overlap." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional integration, while KU covers formal methods in software engineering. No substantial overlap." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional insertion, not programming platforms or languages." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional integration, while KU covers formal methods in software engineering. No substantial overlap." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not GIT-3D Modeling." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, which does not align with the technical content of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional insertion, not programming platforms or languages." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Topics unrelated: teaching methods vs 3D modeling/GIT concepts" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Topics unrelated: teaching methods vs 3D modeling/GIT concepts" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of GIT-3D Modeling, which aligns with the key concepts and principles mentioned in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, which does not align with the technical content of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the course content of SE-Formal Methods, including key concepts, practical applications, and importance in computing, which aligns with the Knowledge Unit's objectives." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Topics unrelated: teaching methods vs 3D modeling/GIT concepts" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional insertion, not programming platforms or languages." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not the specific technical content of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Topics unrelated: teaching methods vs 3D modeling/GIT concepts" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Topics unrelated: teaching methods vs 3D modeling/GIT concepts" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the course content of SE-Formal Methods, including key concepts, practical applications, and importance in computing, which aligns with the Knowledge Unit's objectives." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the course content of SE-Formal Methods, including key concepts, practical applications, and importance in computing, which aligns with the Knowledge Unit's objectives." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the course content of SE-Formal Methods, including key concepts, practical applications, and importance in computing, which aligns with the Knowledge Unit's objectives." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional insertion, not programming platforms or languages." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of GIT-3D Modeling, which aligns with the key concepts and principles mentioned in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of GIT-3D Modeling, which aligns with the key concepts and principles mentioned in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional integration, while KU covers formal methods in software engineering. No substantial overlap." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not the specific technical content of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional insertion, not programming platforms or languages." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not GIT-3D Modeling." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not the specific technical content of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not GIT-3D Modeling." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not GIT-3D Modeling." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not the specific technical content of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of GIT-3D Modeling, which aligns with the key concepts and principles mentioned in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, which does not align with the technical content of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the course content of SE-Formal Methods, including key concepts, practical applications, and importance in computing, which aligns with the Knowledge Unit's objectives." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not the specific technical content of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, which does not align with the technical content of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not GIT-3D Modeling." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of GIT-3D Modeling, which aligns with the key concepts and principles mentioned in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not GIT-3D Modeling." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, which does not align with the technical content of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Topics unrelated: teaching methods vs 3D modeling/GIT concepts" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional integration, while KU covers formal methods in software engineering. No substantial overlap." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the course content of SE-Formal Methods, including key concepts, practical applications, and importance in computing, which aligns with the Knowledge Unit's objectives." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6349528"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of GIT-3D Modeling, which aligns with the key concepts and principles mentioned in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods and professional integration, while KU covers formal methods in software engineering. No substantial overlap." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, which does not align with the technical content of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6541157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methodologies and professional integration, not the specific technical content of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6525782"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ] ;
    ns3:uetext "Label: Methodologie et insertion professionnelle S3 Objectif: (résultats d'apprentissage) Course content: Méthodes d’enseignement Course name: http://example.org/course/UE_XLG3TU010" .

ns1:UE_XLG3TU020 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the transition to an ecological approach, which aligns with the core concepts of SE-Maintenance and Evolution, and the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the transition to an ecological approach, which aligns with the core concepts of SE-Maintenance and Evolution, and the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, while the KU covers software engineering topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics related to language design principles, such as simplicity, security, and readability, which align with the KU's objectives." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; ecological transition vs formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not address the technical aspects of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; ecological transition vs formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on ecological transition, while KU covers programming language design principles with minimal overlap (only green computing)." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, not programming language design." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not address the technical aspects of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on ecological transition, while KU covers programming language design principles with minimal overlap (only green computing)." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not address the technical aspects of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, while the KU covers software engineering topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics (ecological transition vs. SE-Maintenance concepts)" ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not address the technical aspects of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of SE-Formal Methods, including placeholder topics 1, 2, and 3, which align with the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics related to language design principles, such as simplicity, security, and readability, which align with the KU's objectives." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of SE-Formal Methods, including placeholder topics 1, 2, and 3, which align with the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics (ecological transition vs. SE-Maintenance concepts)" ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on ecological transition, while KU covers programming language design principles with minimal overlap (only green computing)." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, while the KU covers software engineering topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of SE-Formal Methods, including placeholder topics 1, 2, and 3, which align with the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics (ecological transition vs. SE-Maintenance concepts)" ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics (ecological transition vs. SE-Maintenance concepts)" ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics (ecological transition vs. SE-Maintenance concepts)" ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, not programming language design." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics related to language design principles, such as simplicity, security, and readability, which align with the KU's objectives." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, not programming language design." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics related to language design principles, such as simplicity, security, and readability, which align with the KU's objectives." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on ecological transition, while KU covers programming language design principles with minimal overlap (only green computing)." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics related to language design principles, such as simplicity, security, and readability, which align with the KU's objectives." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of SE-Formal Methods, including placeholder topics 1, 2, and 3, which align with the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; ecological transition vs formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on ecological transition, while KU covers programming language design principles with minimal overlap (only green computing)." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, not programming language design." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; ecological transition vs formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics related to language design principles, such as simplicity, security, and readability, which align with the KU's objectives." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not address the technical aspects of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the transition to an ecological approach, which aligns with the core concepts of SE-Maintenance and Evolution, and the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics (ecological transition vs. SE-Maintenance concepts)" ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the transition to an ecological approach, which aligns with the core concepts of SE-Maintenance and Evolution, and the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on ecological transition, while KU covers programming language design principles with minimal overlap (only green computing)." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, while the KU covers software engineering topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, not programming language design." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, while the KU covers software engineering topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of SE-Formal Methods, including placeholder topics 1, 2, and 3, which align with the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; ecological transition vs formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, while the KU covers software engineering topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the transition to an ecological approach, which aligns with the core concepts of SE-Maintenance and Evolution, and the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Maintenance and Evolution:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Maintenance and Evolution. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6266768"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the transition to an ecological approach, which aligns with the core concepts of SE-Maintenance and Evolution, and the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Maintenance_and_Evolution" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt> ;
            ns3:ku_text """Pages: 146-147 HOURS CS Core = 0 KA Core = 0 FPL-Design: Design Principles of
Programming Languages Non-core: 1\\. Language design principles a. Simplicity
b. Security (See also: SEC-Coding) c. Fast translation d. Efficient object
code e. Orthogonality f. Readability g. Completeness h. Implementation
strategies 2\\. Designing a language to fit a specific domain or problem 3\\.
Interoperability between programming languages 4\\. Language portability 5\\.
Formal description of a programming language 6\\. Green computing principles
(See also: SEP-Sustainability) Illustrative Learning Outcomes: Non-core: 1\\.
Understand what constitutes good language design and apply that knowledge to
evaluate a real programming language."""^^xsd:string ;
            ns3:score "0.63058054"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on ecological transition, not programming language design." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Design_Design_Principles_of_Programming_Languages" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not address the technical aspects of formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; ecological transition vs formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.62797207"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the core concepts of SE-Formal Methods, including placeholder topics 1, 2, and 3, which align with the illustrative learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ] ;
    ns3:uetext "Label: Enjeux de la transition écologique Objectif: (résultats d'apprentissage) Course content: Programme des 9 séances en ligne (d’environ 1h30 de travail chacune) : Course name: http://example.org/course/UE_XLG3TU020" .

ns1:UE_XLG3TU030 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU covers graphics fundamentals." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the KU's topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of SE-Formal Methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of SE-Formal Methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the specific technical topics outlined in the Knowledge Unit." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the specific technical topics outlined in the Knowledge Unit." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU covers graphics fundamentals." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the KU's topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the KU's topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of SE-Formal Methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the KU's topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the specific technical topics outlined in the Knowledge Unit." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU covers graphics fundamentals." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the specific technical topics outlined in the Knowledge Unit." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU covers graphics fundamentals." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the KU's topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not provide sufficient detail to confirm substantial coverage of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not provide sufficient detail to confirm substantial coverage of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the KU's topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU covers graphics fundamentals." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not provide sufficient detail to confirm substantial coverage of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not provide sufficient detail to confirm substantial coverage of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the specific technical topics outlined in the Knowledge Unit." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU covers graphics fundamentals." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of SE-Formal Methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not provide sufficient detail to confirm substantial coverage of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the KU's topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not provide sufficient detail to confirm substantial coverage of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of SE-Formal Methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU covers graphics fundamentals." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the KU's topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the specific technical topics outlined in the Knowledge Unit." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU covers graphics fundamentals." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not provide sufficient detail to confirm substantial coverage of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the specific technical topics outlined in the Knowledge Unit." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the specific technical topics outlined in the Knowledge Unit." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of SE-Formal Methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU covers graphics fundamentals." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of SE-Formal Methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not provide sufficient detail to confirm substantial coverage of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the specific technical topics outlined in the Knowledge Unit." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the KU's topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of SE-Formal Methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6372254"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of SE-Formal Methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.6342715"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not provide sufficient detail to confirm substantial coverage of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6454415"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ] ;
    ns3:uetext "Label: Stage libre Objectif: (résultats d'apprentissage) Course content: Méthodes d’enseignement Course name: http://example.org/course/UE_XLG3TU030" .

ns1:UE_XLG4AU010 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers software architecture concepts." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Software Architecture, applying principles in practical scenarios, and analyzing its importance in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers programming platforms/technical constraints." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applying principles in practical scenarios, and analyzing the importance of this topic in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of the KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of the KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Software Architecture, applying principles in practical scenarios, and analyzing its importance in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers software architecture concepts." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of the KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Software Architecture, applying principles in practical scenarios, and analyzing its importance in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applying principles in practical scenarios, and analyzing the importance of this topic in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods in English, not software architecture." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods in English, not software architecture." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers software architecture concepts." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers programming platforms/technical constraints." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers programming platforms/technical constraints." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture and KU cover unrelated subjects." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers programming platforms/technical constraints." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture and KU cover unrelated subjects." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the technical content of the KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers formal methods in CS; topics unrelated." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers software architecture concepts." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers formal methods in CS; topics unrelated." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture and KU cover unrelated subjects." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Software Architecture, applying principles in practical scenarios, and analyzing its importance in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers formal methods in CS; topics unrelated." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods in English, not software architecture." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applying principles in practical scenarios, and analyzing the importance of this topic in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture and KU cover unrelated subjects." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applying principles in practical scenarios, and analyzing the importance of this topic in computing, which aligns with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65662575"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, while KU covers formal methods in CS; topics unrelated." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6588453"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Software Architecture: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Software Architecture. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6397157"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods in English, not software architecture." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Software_Architecture" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ] ;
    ns3:uetext "Label: 2nd year English S4 Objectif: (résultats d'apprentissage) Course content: Méthodes d’enseignement Course name: http://example.org/course/UE_XLG4AU010" .

ns1:UE_XLG4IU010 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns3:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns3:score "0.68250453"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on data structures, while the KU covers a broader range of discrete mathematics topics." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt> ;
            ns3:ku_text """Pages:88-90 HOURS CS Core = 11 KA Core = 6 AL-Foundational: Foundational Data
Structures and Algorithms CS Core: (See also: SDF-Data-Structures, SDF-
Algorithms) 1\\. Abstract Data Type (ADT) and operations on an ADT (See also:
FPL-Types) a. Dictionary operations (insert, delete, find) 2\\. Arrays a.
Numeric vs non-numeric, character strings b. Single (vector) vs
multidimensional (matrix) 3\\. Records/Structs/Tuples and Objects (See also:
FPL-OOP) 4\\. Linked lists (for historical reasons) a. Single vs Double and
Linear vs Circular 5\\. Stacks 6\\. Queues and deques a. Heap-based priority
queue 7\\. Hash tables/maps a. Collision resolution and complexity (e.g.,
probing, chaining, rehash) 8\\. Graphs (e.g., [un]directed, [a]cyclic,
[un]connected, and [un]weighted) (See also: MSF-Discrete) a. Graph
representation: adjacency list vs matrix 9\\. Trees (See also: MSF-Discrete) a.
Binary, n-ary, and search trees b. Balanced (e.g., AVL, Red-Black, Heap) 10\\.
Sets (See also: MSF-Discrete) 11\\. Search algorithms a. O(n) complexity (e.g.,
linear/sequential array/list search) b. O(log2 n) complexity (e.g., binary
search) c. O(logb n) complexity (e.g., uninformed depth/breadth-first tree
search) 12\\. Sorting algorithms (e.g., stable, unstable) a. O(n2) complexity
(e.g., insertion, selection), b. O(n log n) complexity (e.g., quicksort,
merge, timsort) 13\\. Graph algorithms a. Shortest path (e.g., Dijkstra's,
Floyd's) b. Minimal spanning tree (e.g., Prim's, Kruskal's) KA Core: 14\\.
Sorting algorithms a. O(n log n) complexity heapsort b. Pseudo O(n) complexity
(e.g., bucket, counting, radix) 15\\. Graph algorithms a. Transitive closure
(e.g., Warshall's) b. Topological sort 16\\. Matching a. Efficient string
matching (e.g., Boyer-Moore, Knuth-Morris-Pratt) b. Longest common subsequence
matching c. Regular expression matching Non-core: 17\\. Cryptography algorithms
(e.g., SHA-256) (See also: SEC-Crypto) 18\\. Parallel algorithms (See also:
PDC-Algorithms, FPL-Parallel) 19\\. Consensus algorithms (e.g., Blockchain)
(See also: SEC-Crypto) a. Proof of work vs proof of stake (See also: SEP-
Sustainability) 20\\. Quantum computing algorithms (See also: AL-Models, AR-
Quantum) a. Oracle-based (e.g., Deutsch-Jozsa, Bernstein-Vazirani, Simon) b.
Superpolynomial speed-up via QFT (e.g., Shor's) c. Polynomial speed-up via
amplitude amplification (e.g., Grover's) 21\\. Fast-Fourier Transform (FFT)
algorithm 22\\. Differential evolution algorithm Illustrative Learning
Outcomes: CS Core: 1\\. For each ADT/Data-Structure in this unit a. Explain its
definition, properties, representation(s), and associated ADT operations. b.
Explain step-by-step how the ADT operations associated with the data structure
transform it. 2\\. For each algorithm in this unit explain step-by-step how the
algorithm operates. 3\\. For each algorithmic approach (e.g., sorting) in this
unit apply a prototypical example of the approach (e.g., merge sort). 90 4\\.
Given requirements for a problem, develop multiple solutions using various
data structures and algorithms. Subsequently, evaluate the suitability,
strengths, and weaknesses selecting an approach that best satisfies the
requirements. 5\\. Explain how collision avoidance and collision resolution is
handled in hash tables. 6\\. Explain factors beyond computational efficiency
that influence the choice of algorithms, such as programming time,
maintainability, and the use of application-specific patterns in the input
data. 7\\. Explain the heap property and the use of heaps as an implementation
of a priority queue. KA Core: 8\\. For each of the algorithms and algorithmic
approaches in the KA Core topics: a. Explain a prototypical example of the
algorithm, and b. Explain step-by-step how the algorithm operates. Non-core:
9\\. An appreciation of quantum computation and its application to certain
problems."""^^xsd:string ;
            ns3:score "0.68500286"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers only a subset of the KU, focusing on data structures without addressing algorithms and advanced topics." ;
            ns1:ka "Algorithmic_Foundations_AL" ;
            ns1:ku "AL-Foundational_Foundational_Data_Structures_and_Algorithms" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns3:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns3:score "0.67598915"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on associative data structures, while KU covers logic programming concepts (unification, Horn clauses, Prolog). Topics diverge significantly." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Logic_Logic_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns3:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns3:score "0.68250453"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on data structures, while KU requires broader math/proof coverage" ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns3:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns3:score "0.67598915"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including topics such as universal and existential quantifiers, logical connectives, and unification, which are core components of the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Logic_Logic_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt> ;
            ns3:ku_text """Pages: 133 HOURS CS Core = 0 KA Core = 2 + 1 (MSF) FPL-Logic: Logic
Programming KA Core: 1\\. Universal vs existential quantifiers. (See also: AI-
LRR, MSF-Discrete) 2\\. First order predicate logic vs higher order logic. (See
also: AI-LRR, MSF-Discrete) 3\\. Expressing complex relations using logical
connectives and simpler relations. 4\\. Definitions of Horn clause, facts,
goals and subgoals. 5\\. Unification and unification algorithm; unification vs
assertion vs expression evaluation. 6\\. Mixing relations with functions. (See
also: MSF-Discrete) 7\\. Cuts, backtracking, and non-determinism. 8\\. Closed-
world vs open-world assumptions. Non-core: 9\\. Memory overhead of variable
copying in handling iterative programs. 10\\. Programming constructs to store
partial computation and pruning search trees. 11\\. Mixing functional
programming and logic programming using concepts such as equational logic,
narrowing, residuation, and semantic unification. (See also: FPL-Functional)
12\\. Higher-order, constraint, and inductive logic programming. (See also: AI-
LRR) 13\\. Integration with other programming paradigms such as object-oriented
programming. 14\\. Advance programming constructs such as difference-lists,
creating user defined data structures, set of, etc. Illustrative learning
outcomes: KA Core: 1\\. Use a logic language to implement a conventional
algorithm. 2\\. Use a logic language to implement an algorithm employing
implicit search using clauses, relations, and cuts. 3\\. Use a simple
illustrative example to show correspondence between First Order Predicate
Logic (FOPL) and logic programs using Horn clauses. 4\\. Use examples to
illustrate the unification algorithm and its role of parameter-passing in
query reduction. 5\\. Use simple logic programs interleaving relations,
functions, and recursive programming such as factorial and Fibonacci numbers
and simple complex relationships between entities and illustrate execution and
parameter-passing using unification and backtracking. Non-core: 6\\. Illustrate
computation of simple programs such as Fibonacci and show overhead of
recomputation, and then show how to improve execution overhead."""^^xsd:string ;
            ns3:score "0.67598915"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on data structures, while the KU covers logic programming." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Logic_Logic_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt> ;
            ns3:ku_text """Pages:88-90 HOURS CS Core = 11 KA Core = 6 AL-Foundational: Foundational Data
Structures and Algorithms CS Core: (See also: SDF-Data-Structures, SDF-
Algorithms) 1\\. Abstract Data Type (ADT) and operations on an ADT (See also:
FPL-Types) a. Dictionary operations (insert, delete, find) 2\\. Arrays a.
Numeric vs non-numeric, character strings b. Single (vector) vs
multidimensional (matrix) 3\\. Records/Structs/Tuples and Objects (See also:
FPL-OOP) 4\\. Linked lists (for historical reasons) a. Single vs Double and
Linear vs Circular 5\\. Stacks 6\\. Queues and deques a. Heap-based priority
queue 7\\. Hash tables/maps a. Collision resolution and complexity (e.g.,
probing, chaining, rehash) 8\\. Graphs (e.g., [un]directed, [a]cyclic,
[un]connected, and [un]weighted) (See also: MSF-Discrete) a. Graph
representation: adjacency list vs matrix 9\\. Trees (See also: MSF-Discrete) a.
Binary, n-ary, and search trees b. Balanced (e.g., AVL, Red-Black, Heap) 10\\.
Sets (See also: MSF-Discrete) 11\\. Search algorithms a. O(n) complexity (e.g.,
linear/sequential array/list search) b. O(log2 n) complexity (e.g., binary
search) c. O(logb n) complexity (e.g., uninformed depth/breadth-first tree
search) 12\\. Sorting algorithms (e.g., stable, unstable) a. O(n2) complexity
(e.g., insertion, selection), b. O(n log n) complexity (e.g., quicksort,
merge, timsort) 13\\. Graph algorithms a. Shortest path (e.g., Dijkstra's,
Floyd's) b. Minimal spanning tree (e.g., Prim's, Kruskal's) KA Core: 14\\.
Sorting algorithms a. O(n log n) complexity heapsort b. Pseudo O(n) complexity
(e.g., bucket, counting, radix) 15\\. Graph algorithms a. Transitive closure
(e.g., Warshall's) b. Topological sort 16\\. Matching a. Efficient string
matching (e.g., Boyer-Moore, Knuth-Morris-Pratt) b. Longest common subsequence
matching c. Regular expression matching Non-core: 17\\. Cryptography algorithms
(e.g., SHA-256) (See also: SEC-Crypto) 18\\. Parallel algorithms (See also:
PDC-Algorithms, FPL-Parallel) 19\\. Consensus algorithms (e.g., Blockchain)
(See also: SEC-Crypto) a. Proof of work vs proof of stake (See also: SEP-
Sustainability) 20\\. Quantum computing algorithms (See also: AL-Models, AR-
Quantum) a. Oracle-based (e.g., Deutsch-Jozsa, Bernstein-Vazirani, Simon) b.
Superpolynomial speed-up via QFT (e.g., Shor's) c. Polynomial speed-up via
amplitude amplification (e.g., Grover's) 21\\. Fast-Fourier Transform (FFT)
algorithm 22\\. Differential evolution algorithm Illustrative Learning
Outcomes: CS Core: 1\\. For each ADT/Data-Structure in this unit a. Explain its
definition, properties, representation(s), and associated ADT operations. b.
Explain step-by-step how the ADT operations associated with the data structure
transform it. 2\\. For each algorithm in this unit explain step-by-step how the
algorithm operates. 3\\. For each algorithmic approach (e.g., sorting) in this
unit apply a prototypical example of the approach (e.g., merge sort). 90 4\\.
Given requirements for a problem, develop multiple solutions using various
data structures and algorithms. Subsequently, evaluate the suitability,
strengths, and weaknesses selecting an approach that best satisfies the
requirements. 5\\. Explain how collision avoidance and collision resolution is
handled in hash tables. 6\\. Explain factors beyond computational efficiency
that influence the choice of algorithms, such as programming time,
maintainability, and the use of application-specific patterns in the input
data. 7\\. Explain the heap property and the use of heaps as an implementation
of a priority queue. KA Core: 8\\. For each of the algorithms and algorithmic
approaches in the KA Core topics: a. Explain a prototypical example of the
algorithm, and b. Explain step-by-step how the algorithm operates. Non-core:
9\\. An appreciation of quantum computation and its application to certain
problems."""^^xsd:string ;
            ns3:score "0.68500286"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "Lecture covers core data structures (arrays, trees, hash tables) and algorithms (search, sort, graph basics) matching KU's CS Core requirements." ;
            ns1:ka "Algorithmic_Foundations_AL" ;
            ns1:ku "AL-Foundational_Foundational_Data_Structures_and_Algorithms" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt> ;
            ns3:ku_text """Pages: 187-188 HOURS CS Core = 29 KA Core = 11 MSF-Discrete: Discrete
Mathematics CS Core: 1\\. Sets, relations, functions, cardinality 2\\. Recursive
mathematical definitions 3\\. Proof techniques (induction, proof by
contradiction) 4\\. Permutations, combinations, counting, pigeonhole principle
5\\. Modular arithmetic 6\\. Logic: truth tables, connectives (operators),
inference rules, formulas, normal forms, simple predicate logic 7\\. Graphs:
basic definitions 8\\. Order notation Illustrative Learning Outcomes: CS Core:
1\\. Sets, Relations, and Functions, Cardinality a. Explain with examples the
basic terminology of functions, relations, and sets. b. Perform the operations
associated with sets, functions, and relations. c. Relate practical examples
to the appropriate set, function, or relation model, and interpret the
associated operations and terminology in context. d. Calculate the size of a
finite set, including making use of the sum and product rules and inclusion-
exclusion principle. e. Explain the difference between finite, countable, and
uncountable sets. 2\\. Recursive mathematical definitions a. Apply recursive
definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,
parse trees, fractals). b. Formulate inductive proofs of statements about
recursive definitions. c. Solve a variety of basic recurrence relations. d.
Analyze a problem to determine underlying recurrence relations. e. Given a
recursive/iterative code snippet, describe its underlying recurrence relation,
hypothesize a closed form for the recurrence relation, and prove the
hypothesis correct (usually, using induction). 3\\. Proof Techniques a.
Identify the proof technique used in a given proof. b. Outline the basic
structure of each proof technique (direct proof, proof by contradiction, and
induction) described in this unit. c. Apply each of the proof techniques
(direct proof, proof by contradiction, and induction) correctly in the
construction of a sound argument. d. Determine which type of proof is best for
a given problem. e. Explain the parallels between ideas of mathematical and/or
structural induction to recursion and recursively defined structures. f.
Explain the relationship between weak and strong induction and give examples
of the appropriate use of each. 4\\. Permutations, combinations, and counting
a. Apply counting arguments, including sum and product rules, inclusion-
exclusion principle, and arithmetic/geometric progressions. b. Apply the
pigeonhole principle in the context of a formal proof. c. Compute permutations
and combinations of a set, and interpret the meaning in the context of the
specific application. d. Map real-world applications to appropriate counting
formalisms, such as determining the number of ways to arrange people around a
table, subject to constraints on the seating arrangement, or the number of
ways to determine certain hands in cards (e.g., a full house). 5\\. Modular
arithmetic a. Perform computations involving modular arithmetic. b. Explain
the notion of the greatest common divisor and apply Euclid's algorithm to
compute it. 6\\. Logic a. Convert logical statements from informal language to
propositional and predicate logic expressions. b. Apply formal methods of
symbolic propositional and predicate logic, such as calculating validity of
formulae, computing normal forms, or negating a logical statement. c. Use the
rules of inference to construct proofs in propositional and predicate logic.
d. Describe how symbolic logic can be used to model real-life situations or
applications, including those arising in computing contexts such as software
analysis (e.g., program correctness), database queries, and algorithms. e.
Apply formal logic proofs and/or informal, but rigorous, logical reasoning to
real problems, such as predicting the behavior of software or solving problems
such as puzzles. f. Describe the strengths and limitations of propositional
and predicate logic. g. Explain what it means for a proof in propositional (or
predicate) logic to be valid. 7\\. Graphs a. Illustrate by example the basic
terminology of graph theory, and some of the properties and special cases of
types of graphs, including trees. b. Demonstrate different traversal methods
for trees and graphs, including pre-, post-, and in-order traversal of trees,
along with breadth-first and depth-first search for graphs. c. Model a variety
of real-world problems in computer science using appropriate forms of graphs
and trees, such as representing a network topology, the organization of a
hierarchical file system, or a social network. d. Show how concepts from
graphs and trees appear in data structures, algorithms, proof techniques
(structural induction), and counting. KA Core: The recommended topics are the
same between CS core and KA-core, but with far more hours, the KA-core can
cover these topics in depth and might include more computing-related
applications."""^^xsd:string ;
            ns3:score "0.68250453"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including topics such as sets, relations, functions, recursive definitions, proof techniques, permutations, combinations, counting, modular arithmetic, logic, and graphs." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Discrete_Discrete_Mathematics" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt> ;
            ns3:ku_text """Pages:88-90 HOURS CS Core = 11 KA Core = 6 AL-Foundational: Foundational Data
Structures and Algorithms CS Core: (See also: SDF-Data-Structures, SDF-
Algorithms) 1\\. Abstract Data Type (ADT) and operations on an ADT (See also:
FPL-Types) a. Dictionary operations (insert, delete, find) 2\\. Arrays a.
Numeric vs non-numeric, character strings b. Single (vector) vs
multidimensional (matrix) 3\\. Records/Structs/Tuples and Objects (See also:
FPL-OOP) 4\\. Linked lists (for historical reasons) a. Single vs Double and
Linear vs Circular 5\\. Stacks 6\\. Queues and deques a. Heap-based priority
queue 7\\. Hash tables/maps a. Collision resolution and complexity (e.g.,
probing, chaining, rehash) 8\\. Graphs (e.g., [un]directed, [a]cyclic,
[un]connected, and [un]weighted) (See also: MSF-Discrete) a. Graph
representation: adjacency list vs matrix 9\\. Trees (See also: MSF-Discrete) a.
Binary, n-ary, and search trees b. Balanced (e.g., AVL, Red-Black, Heap) 10\\.
Sets (See also: MSF-Discrete) 11\\. Search algorithms a. O(n) complexity (e.g.,
linear/sequential array/list search) b. O(log2 n) complexity (e.g., binary
search) c. O(logb n) complexity (e.g., uninformed depth/breadth-first tree
search) 12\\. Sorting algorithms (e.g., stable, unstable) a. O(n2) complexity
(e.g., insertion, selection), b. O(n log n) complexity (e.g., quicksort,
merge, timsort) 13\\. Graph algorithms a. Shortest path (e.g., Dijkstra's,
Floyd's) b. Minimal spanning tree (e.g., Prim's, Kruskal's) KA Core: 14\\.
Sorting algorithms a. O(n log n) complexity heapsort b. Pseudo O(n) complexity
(e.g., bucket, counting, radix) 15\\. Graph algorithms a. Transitive closure
(e.g., Warshall's) b. Topological sort 16\\. Matching a. Efficient string
matching (e.g., Boyer-Moore, Knuth-Morris-Pratt) b. Longest common subsequence
matching c. Regular expression matching Non-core: 17\\. Cryptography algorithms
(e.g., SHA-256) (See also: SEC-Crypto) 18\\. Parallel algorithms (See also:
PDC-Algorithms, FPL-Parallel) 19\\. Consensus algorithms (e.g., Blockchain)
(See also: SEC-Crypto) a. Proof of work vs proof of stake (See also: SEP-
Sustainability) 20\\. Quantum computing algorithms (See also: AL-Models, AR-
Quantum) a. Oracle-based (e.g., Deutsch-Jozsa, Bernstein-Vazirani, Simon) b.
Superpolynomial speed-up via QFT (e.g., Shor's) c. Polynomial speed-up via
amplitude amplification (e.g., Grover's) 21\\. Fast-Fourier Transform (FFT)
algorithm 22\\. Differential evolution algorithm Illustrative Learning
Outcomes: CS Core: 1\\. For each ADT/Data-Structure in this unit a. Explain its
definition, properties, representation(s), and associated ADT operations. b.
Explain step-by-step how the ADT operations associated with the data structure
transform it. 2\\. For each algorithm in this unit explain step-by-step how the
algorithm operates. 3\\. For each algorithmic approach (e.g., sorting) in this
unit apply a prototypical example of the approach (e.g., merge sort). 90 4\\.
Given requirements for a problem, develop multiple solutions using various
data structures and algorithms. Subsequently, evaluate the suitability,
strengths, and weaknesses selecting an approach that best satisfies the
requirements. 5\\. Explain how collision avoidance and collision resolution is
handled in hash tables. 6\\. Explain factors beyond computational efficiency
that influence the choice of algorithms, such as programming time,
maintainability, and the use of application-specific patterns in the input
data. 7\\. Explain the heap property and the use of heaps as an implementation
of a priority queue. KA Core: 8\\. For each of the algorithms and algorithmic
approaches in the KA Core topics: a. Explain a prototypical example of the
algorithm, and b. Explain step-by-step how the algorithm operates. Non-core:
9\\. An appreciation of quantum computation and its application to certain
problems."""^^xsd:string ;
            ns3:score "0.68500286"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU, including data structures and algorithms, with a focus on abstract data types, arrays, linked lists, stacks, queues, hash tables, graphs, trees, and sets." ;
            ns1:ka "Algorithmic_Foundations_AL" ;
            ns1:ku "AL-Foundational_Foundational_Data_Structures_and_Algorithms" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ] ;
    ns3:uetext """Label: Algorithmique et Structures de données 2 Objectif: (résultats d'apprentissage)
données (itératifs et récursifs) Course content: Structures de données non-linéaires associatives (table associative, ensemble, classe-union) Course name: http://example.org/course/UE_XLG4IU010""" .

ns1:UE_XLG4IU020 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Syntax_Syntax_Analysis.txt> ;
            ns3:ku_text """Pages: 141 HOURS CS Core = 0 KA Core = 0 FPL-Syntax: Syntax Analysis Non-core:
1\\. Regular grammars vs context-free grammars (See also: AL-Models) 2\\.
Scanning and parsing based on language specifications 3\\. Lexical analysis
using regular expressions 4\\. Tokens and their use 5\\. Parsing strategies
including top-down (e.g., recursive descent, or LL) and bottom-up (e.g., LR or
GLR) techniques a. Lookahead tables and their application to parsing 6\\.
Language theory: a. Chomsky hierarchy (See also: AL-Models) b. Left-
most/right-most derivation and ambiguity c. Grammar transformation 7\\. Parser
error recovery mechanisms 8\\. Generating scanners and parsers from declarative
specifications Illustrative learning outcomes: Non-core: 1\\. Use formal
grammars to specify the syntax of languages. 2\\. Illustrate the role of
lookahead tables in parsing. 3\\. Use declarative tools to generate parsers and
scanners. 4\\. Recognize key issues in syntax definitions: ambiguity,
associativity, precedence."""^^xsd:string ;
            ns3:score "0.7373393"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as grammatical hierarchy, parsing strategies, and language theory, which are substantially covered in the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Syntax_Syntax_Analysis" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.69355947"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers foundational topics like formal languages and parsing, but the KU includes broader and more advanced NLP topics not addressed in the lecture." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Syntax_Syntax_Analysis.txt> ;
            ns3:ku_text """Pages: 141 HOURS CS Core = 0 KA Core = 0 FPL-Syntax: Syntax Analysis Non-core:
1\\. Regular grammars vs context-free grammars (See also: AL-Models) 2\\.
Scanning and parsing based on language specifications 3\\. Lexical analysis
using regular expressions 4\\. Tokens and their use 5\\. Parsing strategies
including top-down (e.g., recursive descent, or LL) and bottom-up (e.g., LR or
GLR) techniques a. Lookahead tables and their application to parsing 6\\.
Language theory: a. Chomsky hierarchy (See also: AL-Models) b. Left-
most/right-most derivation and ambiguity c. Grammar transformation 7\\. Parser
error recovery mechanisms 8\\. Generating scanners and parsers from declarative
specifications Illustrative learning outcomes: Non-core: 1\\. Use formal
grammars to specify the syntax of languages. 2\\. Illustrate the role of
lookahead tables in parsing. 3\\. Use declarative tools to generate parsers and
scanners. 4\\. Recognize key issues in syntax definitions: ambiguity,
associativity, precedence."""^^xsd:string ;
            ns3:score "0.7373393"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some related topics but lacks detailed coverage of parsing strategies and error recovery." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Syntax_Syntax_Analysis" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns3:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns3:score "0.6879257"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on formal grammars/automata, while KU covers semantics/type systems. No overlap on core KU topics." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Formalism_Formal_Semantics" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns3:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns3:score "0.6879257"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on formal languages and automata, while the KU covers formal semantics and type systems, which are distinct areas." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Formalism_Formal_Semantics" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Syntax_Syntax_Analysis.txt> ;
            ns3:ku_text """Pages: 141 HOURS CS Core = 0 KA Core = 0 FPL-Syntax: Syntax Analysis Non-core:
1\\. Regular grammars vs context-free grammars (See also: AL-Models) 2\\.
Scanning and parsing based on language specifications 3\\. Lexical analysis
using regular expressions 4\\. Tokens and their use 5\\. Parsing strategies
including top-down (e.g., recursive descent, or LL) and bottom-up (e.g., LR or
GLR) techniques a. Lookahead tables and their application to parsing 6\\.
Language theory: a. Chomsky hierarchy (See also: AL-Models) b. Left-
most/right-most derivation and ambiguity c. Grammar transformation 7\\. Parser
error recovery mechanisms 8\\. Generating scanners and parsers from declarative
specifications Illustrative learning outcomes: Non-core: 1\\. Use formal
grammars to specify the syntax of languages. 2\\. Illustrate the role of
lookahead tables in parsing. 3\\. Use declarative tools to generate parsers and
scanners. 4\\. Recognize key issues in syntax definitions: ambiguity,
associativity, precedence."""^^xsd:string ;
            ns3:score "0.7373393"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "Covers grammars, Chomsky hierarchy, parsing/lexical tools (flex/bison), and core syntax analysis topics." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Syntax_Syntax_Analysis" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt> ;
            ns3:ku_text """Pages: 145-146 HOURS CS Core = 0 KA Core = 0 FPL-Formalism: Formal Semantics
Non-core: 1\\. Syntax vs semantics 2\\. Approaches to semantics: axiomatic,
operational, denotational, type-based 3\\. Axiomatic semantics of abstract
constructs such as assignment, selection, iteration using precondition, post-
conditions, and loop invariant 4\\. Operational semantics analysis of abstract
constructs and sequence of such as assignment, expression evaluation,
selection, iteration using environment and store a. Symbolic execution b.
Constraint checkers 5\\. Denotational semantics a. Lambda Calculus. (See also:
AL-Models, FPL-Functional) 6\\. Proofs by induction over language semantics 7\\.
Formal definitions and proofs for type systems (See also: FPL-Types) a.
Propositions as types (implication as a function, conjunction as a product,
disjunction as a sum) b. Dependent types (universal quantification as
dependent function, existential quantification as dependent product) c.
Parametricity Illustrative learning outcomes: Non-core: 1\\. Construct formal
semantics for a small language. 2\\. Write a lambda-calculus program and show
its evaluation to a normal form. 3\\. Discuss the different approaches of
operational, denotational, and axiomatic semantics. 4\\. Use induction to prove
properties of all programs in a language. 5\\. Use induction to prove
properties of all programs in a language that is well-typed according to a
formally defined type system. 6\\. Use parametricity to establish the behavior
of code given only its type."""^^xsd:string ;
            ns3:score "0.6879257"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as formal semantics, axiomatic, operational, and denotational semantics, which are all mentioned in the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Formalism_Formal_Semantics" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.69355947"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as grammatical formalisms, parsing algorithms, and language processing, which are all relevant to the Knowledge Unit." ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt> ;
            ns3:ku_text """Pages:79-80 HOURS CS Core = 0 KA Core = 0 AI-NLP: Natural Language Processing
Non-core: 1\\. Deterministic and stochastic grammars 2\\. Parsing algorithms a.
CFGs and chart parsers (e.g., CYK) b. Probabilistic CFGs and weighted CYK 3\\.
Representing meaning/Semantics a. Logic-based knowledge representations b.
Semantic roles c. Temporal representations d. Beliefs, desires, and intentions
4\\. Corpus-based methods 5\\. N-grams and HMMs 6\\. Smoothing and backoff 7\\.
Examples of use: POS tagging and morphology 8\\. Information retrieval (See
also: DM-Unstructured) a. Vector space model i. TF & IDF b. Precision and
recall 9\\. Information extraction 10\\. Language translation 11\\. Text
classification, categorization a. Bag of words model 12\\. Deep learning for
NLP (See also: AI-ML) a. RNNs b. Transformers c. Multi-modal embeddings (e.g.,
images + text) d. Generative language models Illustrative Learning Outcomes:
1\\. Define and contrast deterministic and stochastic grammars, providing
examples to show the adequacy of each. 2\\. Simulate, apply, or implement
classic and stochastic algorithms for parsing natural language. 3\\. Identify
the challenges of representing meaning. 4\\. List the advantages of using
standard corpora. Identify examples of current corpora for a variety of NLP
tasks. 5\\. Identify techniques for information retrieval, language
translation, and text classification. 6\\. Implement a TF/IDF transform, use it
to extract features from a corpus, and train an off-the-shelf machine learning
algorithm using those features to do text classification."""^^xsd:string ;
            ns3:score "0.69355947"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture covers grammars and parsing basics but lacks NLP-specific topics like stochastic algorithms, semantics, and modern techniques" ;
            ns1:ka "Artificial_Intelligence_AI" ;
            ns1:ku "AI-NLP_Natural_Language_Processing" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ] ;
    ns3:uetext """Label: Langages et automates Objectif: (résultats d'apprentissage)
5. Course content: • Langages algébriques
- Grammaire algébrique
- Arbre de dérivation
- Automates à pile
• Hiérarchie de Chomsky
- Classification des grammaires;
- Algorithmes de reconnaissance pour les grammaires de type 1 et 2
• Analyse lexicale et syntaxique
- TP de flex et bison Course name: http://example.org/course/UE_XLG4IU020""" .

ns1:UE_XLG4IU030 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns3:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns3:score "0.6421694"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as process synchronization, memory management, and file abstraction, which are also mentioned in the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Scripting_Shell_Scripting" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Synchronization_and_Concurrency.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD PDC-Synchronization and
Concurrency: Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder
topic 2 3\\. Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\.
Placeholder advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key
concepts of PDC-Synchronization and Concurrency. 2\\. Apply principles in
practical scenarios. 3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6419754"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers synchronization mechanisms and memory management, which are key parts of the KU." ;
            ns1:ka "Parallel_and_Distributed_Computing_PDC" ;
            ns1:ku "PDC-Synchronization_and_Concurrency" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Synchronization_and_Concurrency.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD PDC-Synchronization and
Concurrency: Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder
topic 2 3\\. Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\.
Placeholder advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key
concepts of PDC-Synchronization and Concurrency. 2\\. Apply principles in
practical scenarios. 3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6419754"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of PDC-Synchronization and Concurrency, such as synchronization mechanisms, memory management, and I/O management, which align with the KU's core concepts." ;
            ns1:ka "Parallel_and_Distributed_Computing_PDC" ;
            ns1:ku "PDC-Synchronization_and_Concurrency" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Translation_Language_Translation_and_Execution.txt> ;
            ns3:ku_text """Pages: 139-140 HOURS CS Core = 2 KA Core = 3 FPL-Translation: Language
Translation and Execution CS Core: 1\\. Execution models for JIT (Just-In-
Time), compiler, interpreter 2\\. Use of intermediate code, e.g., bytecode 3\\.
Limitations and benefits of JIT, compiler, and interpreter 4\\. Cross
compilers/transpilers 5\\. BNF and extended BNF representation of context-free
grammar 6\\. Parse tree using a simple sentence such as arithmetic expression
or if-then-else statement 7\\. Execution as native code or within a virtual
machine 8\\. Language translation pipeline: syntax analysis, parsing, optional
type-checking, translation/code generation and optimization, linking, loading,
execution KA Core: 9\\. Run-time representation of core language constructs
such as objects (method tables) and functions that can be passed as parameters
to and returned from functions (closures) 10\\. Secure compiler development
(See also: SEC-Foundations, SEC-Coding) Illustrative learning outcomes: CS
Core: 1\\. Explain and understand the differences between compiled, JIT, and
interpreted language implementations, including the benefits and limitations
of each. 2\\. Differentiate syntax and parsing from semantics and evaluation.
3\\. Use BNF and extended BNF to specify the syntax of simple constructs such
as if-then-else, type declaration and iterative constructs for known languages
such as C++ or Python. 4\\. Illustrate the parse tree using a simple
sentence/arithmetic expression. 5\\. Illustrate translation of syntax diagrams
to BNF/extended BNF for simple constructs such as if-thenelse, type
declaration, iterative constructs, etc. 6\\. Illustrate ambiguity in parsing
using nested if-then-else/arithmetic expression and show resolution using
precedence order. KA-Core: 7\\. Discuss the benefits and limitations of garbage
collection, including the notion of reachability."""^^xsd:string ;
            ns3:score "0.6486707"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers operating systems topics, while the KU focuses on language translation and execution, which are distinct areas." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Translation_Language_Translation_and_Execution" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Translation_Language_Translation_and_Execution.txt> ;
            ns3:ku_text """Pages: 139-140 HOURS CS Core = 2 KA Core = 3 FPL-Translation: Language
Translation and Execution CS Core: 1\\. Execution models for JIT (Just-In-
Time), compiler, interpreter 2\\. Use of intermediate code, e.g., bytecode 3\\.
Limitations and benefits of JIT, compiler, and interpreter 4\\. Cross
compilers/transpilers 5\\. BNF and extended BNF representation of context-free
grammar 6\\. Parse tree using a simple sentence such as arithmetic expression
or if-then-else statement 7\\. Execution as native code or within a virtual
machine 8\\. Language translation pipeline: syntax analysis, parsing, optional
type-checking, translation/code generation and optimization, linking, loading,
execution KA Core: 9\\. Run-time representation of core language constructs
such as objects (method tables) and functions that can be passed as parameters
to and returned from functions (closures) 10\\. Secure compiler development
(See also: SEC-Foundations, SEC-Coding) Illustrative learning outcomes: CS
Core: 1\\. Explain and understand the differences between compiled, JIT, and
interpreted language implementations, including the benefits and limitations
of each. 2\\. Differentiate syntax and parsing from semantics and evaluation.
3\\. Use BNF and extended BNF to specify the syntax of simple constructs such
as if-then-else, type declaration and iterative constructs for known languages
such as C++ or Python. 4\\. Illustrate the parse tree using a simple
sentence/arithmetic expression. 5\\. Illustrate translation of syntax diagrams
to BNF/extended BNF for simple constructs such as if-thenelse, type
declaration, iterative constructs, etc. 6\\. Illustrate ambiguity in parsing
using nested if-then-else/arithmetic expression and show resolution using
precedence order. KA-Core: 7\\. Discuss the benefits and limitations of garbage
collection, including the notion of reachability."""^^xsd:string ;
            ns3:score "0.6486707"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; KU focuses on language translation, lecture on OS concepts" ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Translation_Language_Translation_and_Execution" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns3:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns3:score "0.6421694"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on OS mechanisms (synchronization, memory, I/O), while the KU covers scripting skills (piping, system commands, regex), with minimal overlap." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Scripting_Shell_Scripting" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Translation_Language_Translation_and_Execution.txt> ;
            ns3:ku_text """Pages: 139-140 HOURS CS Core = 2 KA Core = 3 FPL-Translation: Language
Translation and Execution CS Core: 1\\. Execution models for JIT (Just-In-
Time), compiler, interpreter 2\\. Use of intermediate code, e.g., bytecode 3\\.
Limitations and benefits of JIT, compiler, and interpreter 4\\. Cross
compilers/transpilers 5\\. BNF and extended BNF representation of context-free
grammar 6\\. Parse tree using a simple sentence such as arithmetic expression
or if-then-else statement 7\\. Execution as native code or within a virtual
machine 8\\. Language translation pipeline: syntax analysis, parsing, optional
type-checking, translation/code generation and optimization, linking, loading,
execution KA Core: 9\\. Run-time representation of core language constructs
such as objects (method tables) and functions that can be passed as parameters
to and returned from functions (closures) 10\\. Secure compiler development
(See also: SEC-Foundations, SEC-Coding) Illustrative learning outcomes: CS
Core: 1\\. Explain and understand the differences between compiled, JIT, and
interpreted language implementations, including the benefits and limitations
of each. 2\\. Differentiate syntax and parsing from semantics and evaluation.
3\\. Use BNF and extended BNF to specify the syntax of simple constructs such
as if-then-else, type declaration and iterative constructs for known languages
such as C++ or Python. 4\\. Illustrate the parse tree using a simple
sentence/arithmetic expression. 5\\. Illustrate translation of syntax diagrams
to BNF/extended BNF for simple constructs such as if-thenelse, type
declaration, iterative constructs, etc. 6\\. Illustrate ambiguity in parsing
using nested if-then-else/arithmetic expression and show resolution using
precedence order. KA-Core: 7\\. Discuss the benefits and limitations of garbage
collection, including the notion of reachability."""^^xsd:string ;
            ns3:score "0.6486707"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as process synchronization, memory management, and I/O management, which are also covered in the KU, indicating a substantial overlap." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Translation_Language_Translation_and_Execution" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt> ;
            ns3:ku_text """Pages: 133-134 HOURS CS Core = 2 KA Core = 0 FPL-Scripting: Shell Scripting CS
Core: 1\\. Error/exception handling 2\\. Piping (See also: AR-Organization, SF-
Overview, OS-Process) 3\\. System commands (See also: SF-Overview) a. Interface
with operating systems (See also: SF-Overview, OS-Principles) 4\\. Environment
variables (See also: SF-Overview) 5\\. File abstraction and operators (See
also: SDF-Fundamentals, OS-Files, SF-Resource) 6\\. Data structures, such as
arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-
Structures) 7\\. Regular expressions (See also: AL-Models) 8\\. Programs and
processes (See also: OS-Process) 9\\. Workflow Illustrative learning outcomes:
CS Core: 1\\. Create and execute automated scripts to manage various system
tasks. 2\\. Solve various text processing problems through scripting."""^^xsd:string ;
            ns3:score "0.6421694"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on OS mechanisms, while the KU covers shell scripting." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Scripting_Shell_Scripting" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Synchronization_and_Concurrency.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD PDC-Synchronization and
Concurrency: Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder
topic 2 3\\. Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\.
Placeholder advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key
concepts of PDC-Synchronization and Concurrency. 2\\. Apply principles in
practical scenarios. 3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.6419754"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "Covers synchronization mechanisms (semaphores, mutexes) and virtual memory, aligning with PDC-Synchronization/Concurrency core concepts." ;
            ns1:ka "Parallel_and_Distributed_Computing_PDC" ;
            ns1:ku "PDC-Synchronization_and_Concurrency" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ] ;
    ns3:uetext """Label: Systèmes d'exploitation Objectif: (résultats d'apprentissage)
synchronisation/communication (Application)
• Etre capable d'utiliser les mécanismes de synchronisation usuels sous Linux (sémaphores,
mutexes, signaux) (Application)
• Comprendre le principe de mémoire virtuelle (Initiation)
• Savoir gérer les entrées/sorties sous Linux (Initiation) Course content: par le système d'exploitation y sont exposées : comment les processus se partagent-ils l'accès au
processeur ? Comment se synchronisent-ils et quels mécanismes leur permettent d'échanger des
données ? Comment sont gérés la mémoire et les entrées/sorties ? Course name: http://example.org/course/UE_XLG4IU030""" .

ns1:UE_XLG4IU040 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6757257"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some aspects of the KU but misses key components like conceptual models and semi-structured data." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns3:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns3:score "0.7032179"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basics of relational databases, including Merise modeling, relational models, and SQL, which aligns with the KU's focus on query construction, relational algebra, and SQL." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Querying_Query_Construction" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt> ;
            ns3:ku_text """Pages: 117-118 HOURS CS Core = 1 KA Core = 3 DM-Relational: Relational
Databases CS Core: 1\\. Entity and referential integrity: Candidate key,
superkeys 2\\. Relational database design KA Core: 3\\. Mapping conceptual
schema to a relational schema 4\\. Physical database design: file and storage
structures (See also: OS-Files) 5\\. Introduction to Functional dependency
theory 6\\. Normalization Theory a. Decomposition of a schema; lossless-join,
and dependency-preservation properties of a decomposition b. Normal forms
(BCNF) c. Denormalization (for efficiency) Non-core: 7\\. Functional dependency
theory a. Closure of a set of attributes b. Canonical Cover 8\\. Normalization
theory a. Multi-valued dependency (4NF) b. Join dependency (PJNF, 5NF) c.
Representation theory Illustrative Learning Outcomes: CS Core: 1\\. Describe
the defining characteristics behind the relational data model. 2\\. Comment on
the difference between a foreign key and a superkey. 3\\. Enumerate the
different types of integrity constraints. KA Core: 4\\. Compose a relational
schema from a conceptual schema which contains 1:1, 1:n, and n:m
relationships. 5\\. Map appropriate file structure to relations and indices.
6\\. Describe how functional dependency theory generalizes the notion of key.
7\\. Defend a given decomposition as lossless and or dependency preserving. 8\\.
Detect which normal form a given decomposition yields. 9\\. Comment on reasons
for denormalizing a relation."""^^xsd:string ;
            ns3:score "0.6675879"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the basics of relational databases, including entity and referential integrity, relational database design, and normalization theory, which aligns with the Knowledge Unit's content." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Relational_Relational_Databases" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt> ;
            ns3:ku_text """Pages: 117-118 HOURS CS Core = 1 KA Core = 3 DM-Relational: Relational
Databases CS Core: 1\\. Entity and referential integrity: Candidate key,
superkeys 2\\. Relational database design KA Core: 3\\. Mapping conceptual
schema to a relational schema 4\\. Physical database design: file and storage
structures (See also: OS-Files) 5\\. Introduction to Functional dependency
theory 6\\. Normalization Theory a. Decomposition of a schema; lossless-join,
and dependency-preservation properties of a decomposition b. Normal forms
(BCNF) c. Denormalization (for efficiency) Non-core: 7\\. Functional dependency
theory a. Closure of a set of attributes b. Canonical Cover 8\\. Normalization
theory a. Multi-valued dependency (4NF) b. Join dependency (PJNF, 5NF) c.
Representation theory Illustrative Learning Outcomes: CS Core: 1\\. Describe
the defining characteristics behind the relational data model. 2\\. Comment on
the difference between a foreign key and a superkey. 3\\. Enumerate the
different types of integrity constraints. KA Core: 4\\. Compose a relational
schema from a conceptual schema which contains 1:1, 1:n, and n:m
relationships. 5\\. Map appropriate file structure to relations and indices.
6\\. Describe how functional dependency theory generalizes the notion of key.
7\\. Defend a given decomposition as lossless and or dependency preserving. 8\\.
Detect which normal form a given decomposition yields. 9\\. Comment on reasons
for denormalizing a relation."""^^xsd:string ;
            ns3:score "0.6675879"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some introductory aspects but lacks depth in key areas like normalization and functional dependencies." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Relational_Relational_Databases" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6757257"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "Covers relational model, SQL, and Merise (conceptual modeling), but lacks semi-structured/data models (XML/JSON)" ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns3:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns3:score "0.7032179"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "Covers SQL, relational model, and relational algebra, aligning with core KU requirements." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Querying_Query_Construction" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt> ;
            ns3:ku_text """Pages: 116-117 HOURS CS Core = 2 KA Core = 3 DM-Modeling: Data Modeling CS
Core: 1\\. Data modeling (See also: SE-Requirements) 2\\. Relational data model
(See also: MSF-Discrete) KA Core: 3\\. Conceptual models (e.g., entity-
relationship, UML diagrams) 4\\. Semi-structured data models (expressed using
DTD, XML, or JSON Schema, for example) Non-core: 5\\. Spreadsheet models 6\\.
Object-oriented models (See also: FPL-OOP) a. GraphQL 7\\. New features in SQL
8\\. Specialized Data Modeling topics a. Time series data (aggregation, join)
b. Graph data (link traversal) c. Techniques for avoiding inefficient raw data
access (e.g., "avg daily price"): materialized views and special data
structures (e.g., Hyperloglog, bitmap) d. Geo-Spatial data (e.g., GIS
databases) (See also: SPD-Interactive) Illustrative Learning Outcomes: CS
Core: 1\\. Describe the components of the relational data model. 2\\. Model 1:1,
1:n, and n:m relationships using the relational data model. KA Core: 3\\.
Describe the components of the E-R (or some other non-relational) data model.
4\\. Model a given environment using a conceptual data model. 5\\. Model a given
environment using the document-based or key-value store-based data model."""^^xsd:string ;
            ns3:score "0.6757257"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the introduction to relational data model, SQL, and OLAP, which aligns with the KU's CS Core and KA Core topics." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Modeling_Data_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt> ;
            ns3:ku_text """Pages: 118 HOURS CS Core = 2 KA Core = 4 DM-Querying: Query Construction CS
Core: 1\\. SQL Query Formation a. Interactive SQL execution b. Programmatic
execution of an SQL query KA Core: 2\\. Relational Algebra 3\\. SQL a. Data
definition including integrity and other constraint specifications b. Update
sublanguage Non-core: 4\\. Relational Calculus 5\\. QBE and 4th-generation
environments 6\\. Different ways to invoke non-procedural queries in
conventional languages 7\\. Introduction to other major query languages (e.g.,
XPATH, SPARQL) 8\\. Stored procedures Illustrative Learning Outcomes: CS Core:
1\\. Compose SQL queries that incorporate select, project, join, union,
intersection, set difference, and set division. 2\\. Determine when a nested
SQL query is correlated or not. 3\\. Iterate over data retrieved
programmatically from a database via an SQL query. KA Core: 4\\. Define, in
SQL, a relation schema, including all integrity constraints and delete/update
triggers. 5\\. Compose an SQL query to update a tuple in a relation."""^^xsd:string ;
            ns3:score "0.7032179"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers some basic elements like SQL and relational algebra but lacks depth in query construction and advanced topics." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Querying_Query_Construction" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt> ;
            ns3:ku_text """Pages: 117-118 HOURS CS Core = 1 KA Core = 3 DM-Relational: Relational
Databases CS Core: 1\\. Entity and referential integrity: Candidate key,
superkeys 2\\. Relational database design KA Core: 3\\. Mapping conceptual
schema to a relational schema 4\\. Physical database design: file and storage
structures (See also: OS-Files) 5\\. Introduction to Functional dependency
theory 6\\. Normalization Theory a. Decomposition of a schema; lossless-join,
and dependency-preservation properties of a decomposition b. Normal forms
(BCNF) c. Denormalization (for efficiency) Non-core: 7\\. Functional dependency
theory a. Closure of a set of attributes b. Canonical Cover 8\\. Normalization
theory a. Multi-valued dependency (4NF) b. Join dependency (PJNF, 5NF) c.
Representation theory Illustrative Learning Outcomes: CS Core: 1\\. Describe
the defining characteristics behind the relational data model. 2\\. Comment on
the difference between a foreign key and a superkey. 3\\. Enumerate the
different types of integrity constraints. KA Core: 4\\. Compose a relational
schema from a conceptual schema which contains 1:1, 1:n, and n:m
relationships. 5\\. Map appropriate file structure to relations and indices.
6\\. Describe how functional dependency theory generalizes the notion of key.
7\\. Defend a given decomposition as lossless and or dependency preserving. 8\\.
Detect which normal form a given decomposition yields. 9\\. Comment on reasons
for denormalizing a relation."""^^xsd:string ;
            ns3:score "0.6675879"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture covers basics (relational model, SQL) but lacks depth on normalization theory, decomposition properties, and physical design details required by KU." ;
            ns1:ka "Date_Management_DM" ;
            ns1:ku "DM-Relational_Relational_Databases" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ] ;
    ns3:uetext """Label: Bases de données Objectif: (résultats d'apprentissage)
- Introduction à la modélisation Merise
- Modèle relationnel
- Algèbre relationnelle et SQL Course content: - Passage au relationnel
- Définition et interrogation d'une base en sql
- Introduction au modèle olap Course name: http://example.org/course/UE_XLG4IU040""" .

ns1:UE_XLG4MU050 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's objectives." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses narrowly on optimization and integral calculus, while KU requires broader calculus topics (sequences, derivatives, ODEs, etc.) not explicitly covered." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover a large subset of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover a large subset of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on optimization and calculus, while KU covers functional programming concepts." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on optimization and integral calculus, which does not align with the KU's content on development platforms and programming constraints." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers mathematical topics, while the KU focuses on functional programming in Computer Science, with no overlapping content." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses narrowly on optimization and integral calculus, while KU requires broader calculus topics (sequences, derivatives, ODEs, etc.) not explicitly covered." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers most of the topics listed in the KU, including sequences, series, limits, derivatives, integration, parametric and polar representations, Taylor series, multivariate calculus, and ordinary differential equations." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses narrowly on optimization and integral calculus, while KU requires broader calculus topics (sequences, derivatives, ODEs, etc.) not explicitly covered." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers mathematical topics, while the KU focuses on functional programming in Computer Science, with no overlapping content." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers most of the topics listed in the KU, including sequences, series, limits, derivatives, integration, parametric and polar representations, Taylor series, multivariate calculus, and ordinary differential equations." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on mathematics while KU covers programming platforms and constraints" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on optimization and integral calculus, which does not align with the KU's content on development platforms and programming constraints." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on optimization and calculus, while KU covers functional programming concepts." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers most of the topics listed in the KU, including sequences, series, limits, derivatives, integration, parametric and polar representations, Taylor series, multivariate calculus, and ordinary differential equations." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on optimization and integral calculus, which does not align with the KU's content on development platforms and programming constraints." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the Knowledge Unit, including topics such as lambda expressions, effect-free programming, and higher-order functions, which are all core components of the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on mathematics while KU covers programming platforms and constraints" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers mathematical topics, while the KU focuses on functional programming in Computer Science, with no overlapping content." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the Knowledge Unit, including topics such as lambda expressions, effect-free programming, and higher-order functions, which are all core components of the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's objectives." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on mathematics while KU covers programming platforms and constraints" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers most of the topics listed in the KU, including sequences, series, limits, derivatives, integration, parametric and polar representations, Taylor series, multivariate calculus, and ordinary differential equations." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses narrowly on optimization and integral calculus, while KU requires broader calculus topics (sequences, derivatives, ODEs, etc.) not explicitly covered." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on mathematics while KU covers programming platforms and constraints" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's objectives." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on mathematics while KU covers programming platforms and constraints" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover a large subset of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers mathematical topics, while the KU focuses on functional programming in Computer Science, with no overlapping content." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the Knowledge Unit, including topics such as lambda expressions, effect-free programming, and higher-order functions, which are all core components of the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on optimization and calculus, while KU covers functional programming concepts." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on optimization and calculus, while KU covers functional programming concepts." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's objectives." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers mathematical topics, while the KU focuses on functional programming in Computer Science, with no overlapping content." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the Knowledge Unit, including topics such as lambda expressions, effect-free programming, and higher-order functions, which are all core components of the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the Knowledge Unit, including topics such as lambda expressions, effect-free programming, and higher-order functions, which are all core components of the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's objectives." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses narrowly on optimization and integral calculus, while KU requires broader calculus topics (sequences, derivatives, ODEs, etc.) not explicitly covered." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers most of the topics listed in the KU, including sequences, series, limits, derivatives, integration, parametric and polar representations, Taylor series, multivariate calculus, and ordinary differential equations." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on optimization and calculus, while KU covers functional programming concepts." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers most of the topics listed in the KU, including sequences, series, limits, derivatives, integration, parametric and polar representations, Taylor series, multivariate calculus, and ordinary differential equations." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover a large subset of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on optimization and calculus, while KU covers functional programming concepts." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers topics such as development platforms, programming languages, and platform constraints, which align with the Knowledge Unit's objectives." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on mathematics while KU covers programming platforms and constraints" ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture covers mathematical topics, while the KU focuses on functional programming in Computer Science, with no overlapping content." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses narrowly on optimization and integral calculus, while KU requires broader calculus topics (sequences, derivatives, ODEs, etc.) not explicitly covered." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover a large subset of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on optimization and integral calculus, which does not align with the KU's content on development platforms and programming constraints." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on optimization and integral calculus, which does not align with the KU's content on development platforms and programming constraints." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.6495097"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on optimization and integral calculus, which does not align with the KU's content on development platforms and programming constraints." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt> ;
            ns3:ku_text """Pages: 131-132-133 HOURS CS Core = 4 KA Core = 3 FPL-Functional: Functional
Programming CS Core: 1\\. Lambda expressions and evaluation: (See also: AL-
Models, FPL-Formalism) a. Variable binding and scope rules. (See also: SDF-
Fundamentals) b. Parameter-passing. (See also: SDF-Fundamentals) c. Nested
lambda expressions and reduction order. 2\\. Effect-free programming: a.
Function calls have no side effects, facilitating compositional reasoning. b.
Immutable variables and data copying vs reduction. c. Use of recursion vs
loops vs pipelining (map/reduce). 3\\. Processing structured data (e.g., trees)
via functions with cases for each data variant: a. Functions defined over
compound data in terms of functions applied to the constituent pieces. b.
Persistent data structures. 4\\. Using higher-order functions (taking,
returning, and storing functions). KA Core: 5\\. Metaprogramming and
reflection. 6\\. Function closures (functions using variables in the enclosing
lexical environment). a. Basic meaning and definition - creating closures at
run-time by capturing the environment. b. Canonical idioms: call-backs,
arguments to iterators, reusable code via function arguments. c. Using a
closure to encapsulate data in its environment. d. Delayed versus eager
evaluation. Non-core: 7\\. Graph reduction machine and call-by-need. 8\\.
Implementing delayed evaluation. 9\\. Integration with logic programming
paradigm using concepts such as equational logic, narrowing, residuation and
semantic unification. (See also: FPL-Logic) 10\\. Integration with other
programming paradigms such as imperative and object-oriented. Illustrative
learning outcomes: CS Core: 1\\. Develop basic algorithms that avoid assigning
to mutable states or considering reference equality. 2\\. Develop useful
functions that take and return other functions. 3\\. Compare and contrast how
computational solutions to a problem differ in procedural, functional, and
object-oriented approaches. 4\\. Compare and contrast mechanisms to define and
protect data elements within procedural, functional, and object-oriented
approaches. KA Core: 5\\. Explain a simple example of lambda expression being
implemented using a virtual machine, such as a SECD machine, showing storage
and reclaim of the environment. 6\\. Correctly interpret variables and lexical
scope in a program using function closures. 7\\. Use functional encapsulation
mechanisms such as closures and modular interfaces. 8\\. Compare and contrast
stateful vs stateless execution. 9\\. Define and use iterators and other
operations on aggregates, including operations that take functions as
arguments, in multiple programming languages, selecting the most natural
idioms for each language. (See also: FPL-OOP) Non-core: 10\\. Illustrate graph
reduction using a l-expression using a shared subexpression. 11\\. Illustrate
the execution of a simple nested l-expression using an abstract machine, such
as an ABC machine. 12\\. Illustrate narrowing, residuation, and semantic
unification using simple illustrative examples. 13\\. Illustrate the
concurrency constructs using simple programming examples of known concepts
such as a buffer being read and written concurrently or sequentially. (See
also: FPL-OOP)"""^^xsd:string ;
            ns3:score "0.66148436"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the Knowledge Unit, including topics such as lambda expressions, effect-free programming, and higher-order functions, which are all core components of the KU." ;
            ns1:ka "Foundations_of_Programming_Languages_FPL" ;
            ns1:ku "FPL-Functional_Functional_Programming" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt> ;
            ns3:ku_text """Pages: 192-194 HOURS CS Core = 0 KA Core = 40 MSF-Calculus KA Core: 1\\.
Sequences, series, limits 2\\. Single-variable derivatives: definition,
computation rules (chain rule etc.), derivatives of important functions,
applications 3\\. Single-variable integration: definition, computation rules,
integrals of important functions, fundamental theorem of calculus, definite vs
indefinite, applications (including in probability) 4\\. Parametric and polar
representations 5\\. Taylor series 6\\. Multivariate calculus: partial
derivatives, gradient, chain-rule, vector valued functions, 7\\. Optimization:
convexity, global vs local minima, gradient descent, constrained optimization,
and Lagrange multipliers. 8\\. Ordinary Differential Equations (ODEs):
definition, Euler method, applications to simulation, Monte Carlo integration
9\\. CS applications: gradient descent for machine learning, forward and
inverse kinematics, applications of calculus to probability Note: the calculus
topics listed above are aligned with computer science goals rather than with
traditional calculus courses. For example, multivariate calculus is often a
course by itself, but computer science undergraduates only need parts of it
for machine learning. Illustrative Learning Outcomes: KA Core: 1\\. Sequences,
series, limits a. Explain the difference between infinite sets and sequences.
b. Explain the formal definition of a limit. c. Derive the limit for examples
of sequences and series. d. Explain convergence and divergence. e. Apply
L'Hospital's rule and other approaches to resolving limits. 2\\. Single-
variable derivatives: definition, computation rules (chain rule etc.),
derivatives of important functions, applications a. Explain a derivative in
terms of limits. b. Explain derivatives as functions. c. Perform elementary
derivative calculations from limits. d. Apply sum, product, and quotient
rules. e. Work through examples with important functions. 3\\. Single-variable
integration: definition, computation rules, integrals of important functions,
fundamental theorem of calculus, definite vs indefinite, applications
(including in probability) a. Explain the definitions of definite and
indefinite integrals. b. Apply integration rules to examples with important
functions. c. Explore the use of the fundamental theorem of calculus. d. Apply
integration to problems. 4\\. Parametric and polar representations a. Apply
parametric representations of important curves. b. Apply polar
representations. 5\\. Taylor series a. Derive Taylor series for some important
functions. b. Apply the Taylor series to approximations. 6\\. Multivariate
calculus: partial derivatives, gradient, chain-rule, vector valued functions,
applications to optimization, convexity, global vs local minima. a. Compute
partial derivatives and gradients. b. Work through examples with vector-valued
functions with gradient notation. c. Explain applications to optimization. 7\\.
ODEs: definition, Euler method, applications to simulation a. Apply the Euler
method to integration. b. Apply the Euler method to a single-variable
differential equation. c. Apply the Euler method to multiple variables in an
ODE."""^^xsd:string ;
            ns3:score "0.6604698"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover a large subset of the KU." ;
            ns1:ka "Mathematical_and_Statistical_Foundations_MSF" ;
            ns1:ku "MSF-Calculus" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ] ;
    ns3:uetext """Label: Optimisation 1 et Calcul integral Objectif: (résultats d'apprentissage)
• Course content: • Course name: http://example.org/course/UE_XLG4MU050""" .

ns1:UE_XLG4TU010 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, while the KU covers SE-Project Management concepts, which are not substantially related." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional development and networking without covering project management concepts." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional methodology and career development, while the KU covers technical software engineering topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional development and networking without covering project management concepts." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on professional skills, KU on formal methods theory." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on professional skills, KU on formal methods theory." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, whereas the KU covers SE-Testing and Quality Assurance, which are unrelated topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap between professional insertion skills (networking, career projects) and SE-Project Management concepts" ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap between professional insertion skills (networking, career projects) and SE-Project Management concepts" ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap between professional insertion skills (networking, career projects) and SE-Project Management concepts" ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, whereas the KU covers SE-Formal Methods, with no apparent connection between the two topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional methodology and career development, while the KU covers technical software engineering topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on professional skills, KU on formal methods theory." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional development and networking, not software testing or quality assurance." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, while the KU covers SE-Project Management concepts, which are not substantially related." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, whereas the KU covers SE-Formal Methods, with no apparent connection between the two topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on professional skills, KU covers SE testing/quality assurance." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, whereas the KU covers SE-Testing and Quality Assurance, which are unrelated topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional methodology and career development, while the KU covers technical software engineering topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on professional skills, KU covers SE testing/quality assurance." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on professional skills, KU on formal methods theory." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, whereas the KU covers SE-Testing and Quality Assurance, which are unrelated topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on professional skills, KU covers SE testing/quality assurance." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, whereas the KU covers SE-Formal Methods, with no apparent connection between the two topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on professional skills, KU covers SE testing/quality assurance." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional development and networking, not software testing or quality assurance." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap between professional insertion skills (networking, career projects) and SE-Project Management concepts" ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional development and networking, not software testing or quality assurance." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional development and networking, not software testing or quality assurance." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, while the KU covers SE-Project Management concepts, which are not substantially related." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, whereas the KU covers SE-Formal Methods, with no apparent connection between the two topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional development and networking without covering project management concepts." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6704163"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional methodology and career development, while the KU covers technical software engineering topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, while the KU covers SE-Project Management concepts, which are not substantially related." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Project Management: Core
Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Project Management. 2\\. Apply principles in practical scenarios. 3\\.
Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.65625584"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on professional development and networking without covering project management concepts." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Project_Management" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Testing and Quality Assurance:
Core Concepts CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\.
Placeholder topic 3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder
advanced topic 2 Illustrative Learning Outcomes: 1\\. Explain key concepts of
SE-Testing and Quality Assurance. 2\\. Apply principles in practical scenarios.
3\\. Analyze the importance of this topic in computing."""^^xsd:string ;
            ns3:score "0.651711"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on methodology and professional insertion, whereas the KU covers SE-Testing and Quality Assurance, which are unrelated topics." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Testing_and_Quality_Assurance" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ] ;
    ns3:uetext """Label: Methodologie et insertion professionnelle S4 Objectif: (résultats d'apprentissage)
faire et savoir-être) et d'un plan d'actions sur les prochaines années : à l'écrit et à l'oral
- d'identitier et d'animer son réseau (professionnel et élargi)
- de créer et de faire vivre ses profils numériques professionnels
- de mener une enquête métier auprès d'un professionnel et de la restituer Course content: - présentation orale de la restitution de l'enquête et des recherches sur le métier
- équivalent de 8 TD + présentation orale des enquêtes:
- identication de ses valeurs
- indentification de ses compétences
- consrtruction de son projet professionnel et personnel
- présentation de son projet Course name: http://example.org/course/UE_XLG4TU010""" .

ns1:UE_XLG4TU020 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers GIT-3D Modeling concepts." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the formal methods content of the KU." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of this topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers technical formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers GIT-3D Modeling concepts." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the formal methods content of the KU." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers technical formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical aspects of the knowledge unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers technical formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers GIT-3D Modeling concepts." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not platform-specific programming details." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not platform-specific programming details." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers technical formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU's core concepts and advanced topics, with a focus on practical applications and analysis." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical aspects of the knowledge unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical aspects of the knowledge unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers GIT-3D Modeling concepts." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of this topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers technical formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU's core concepts and advanced topics, with a focus on practical applications and analysis." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the formal methods content of the KU." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers technical formal methods in software engineering." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of this topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the formal methods content of the KU." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not platform-specific programming details." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of this topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers GIT-3D Modeling concepts." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not GIT-3D Modeling content" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical aspects of the knowledge unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical aspects of the knowledge unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not GIT-3D Modeling content" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of this topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not GIT-3D Modeling content" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU's core concepts and advanced topics, with a focus on practical applications and analysis." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not GIT-3D Modeling content" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU's core concepts and advanced topics, with a focus on practical applications and analysis." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not platform-specific programming details." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the formal methods content of the KU." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical aspects of the knowledge unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU's core concepts and advanced topics, with a focus on practical applications and analysis." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not platform-specific programming details." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, while the KU covers GIT-3D Modeling concepts." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not the formal methods content of the KU." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not GIT-3D Modeling content" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not GIT-3D Modeling content" ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD GIT-3D Modeling: Core Concepts CS
Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic 3
KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of GIT-3D Modeling.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.6374098"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers a significant portion of the KU's core concepts and advanced topics, with a focus on practical applications and analysis." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-3D_Modeling" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not platform-specific programming details." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.65218985"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.65845335"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of this topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ] ;
    ns3:uetext "Label: Unité Enseignement de Découverte Objectif: (résultats d'apprentissage) Course content: Méthodes d’enseignement Course name: http://example.org/course/UE_XLG4TU020" .

ns1:UE_XLG4TU030 ns3:to [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical content of the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on teaching methods, KU on formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU is technical graphics." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the detailed technical content of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on teaching methods, KU on formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU is technical graphics." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on teaching methods, KU on formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the detailed technical content of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical content of the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on teaching methods, KU on formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical content of the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU is technical graphics." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the detailed technical content of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU is technical graphics." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the detailed technical content of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "Lecture focuses on teaching methods, not technical platform/programming details in KU." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in topics; lecture focuses on teaching methods, KU on formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "No overlap in content; lecture focuses on teaching methods while KU is technical graphics." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "qwen-qwq-32b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical content of the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the technical content of the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture focuses on teaching methods, not formal methods." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt> ;
            ns3:ku_text """Pages: TBD HOURS CS Core = TBD KA Core = TBD SE-Formal Methods: Core Concepts
CS Core: 1\\. Placeholder topic 1 2\\. Placeholder topic 2 3\\. Placeholder topic
3 KA Core: 4\\. Placeholder advanced topic 1 5\\. Placeholder advanced topic 2
Illustrative Learning Outcomes: 1\\. Explain key concepts of SE-Formal Methods.
2\\. Apply principles in practical scenarios. 3\\. Analyze the importance of
this topic in computing."""^^xsd:string ;
            ns3:score "0.639867"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers key concepts of SE-Formal Methods, applies principles in practical scenarios, and analyzes the importance of the topic in computing, aligning with the KU's learning outcomes." ;
            ns1:ka "Software_Engineering_SE" ;
            ns1:ku "SE-Formal_Methods" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "0" ;
            ns1:explain "The lecture does not cover the detailed technical content of the Knowledge Unit." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "deepseek-r1-distill-llama-70b" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt> ;
            ns3:ku_text """Pages : 240-241 CS Core : 4, KA Core : 2 CS Core: 1\\. Overview of development
platforms (i.e., web, mobile, game, robotics, embedded, and interactive). a.
Input/sensors/control devices/haptic devices b. Resource constraints i.
Computational ii. Data storage iii. Memory iv. Communication c. Requirements -
security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-
Engineering) d. Output/actuators/haptic devices 2\\. Programming via platform-
specific Application Programming Interface (API) vs traditional application
construction 3\\. Overview of platform Languages (e.g., Python, Swift, Lua,
Kotlin) 4\\. Programming under platform constraints and requirements (e.g.,
available development tools, development, security considerations) (See also:
SEC-Foundations) 5\\. Techniques for learning and mastering a platform-specific
programming language Illustrative Learning Outcomes: CS Core: 1\\. List the
constraints of mobile programming. 2\\. List the characteristics of scripting
languages. 3\\. Describe the three-tier model of web programming. 4\\. Describe
how the state is maintained in web programming."""^^xsd:string ;
            ns3:score "0.64871335"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers the overview of development platforms, programming via platform-specific API, platform languages, and programming under platform constraints, which aligns with the KU's content." ;
            ns1:ka "Specialized_Platform_Development_SPD" ;
            ns1:ku "SPD-Common_Aspects" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ],
        [ ns3:ku_source <file:///Users/rekiknour/Desktop/STAGE/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt> ;
            ns3:ku_text """Pages: 150-151 HOURS CS Core = 3 KA Core = 2 GIT-Fundamentals: Fundamental
Concepts CS Core: 1\\. Overview of graphics and visualization. 2\\. Basic
graphics pipeline architecture. 3\\. 2D and 3D transformations. 4\\.
Rasterization and rendering techniques. 5\\. Fundamental shading models. KA
Core: 6\\. Advanced rendering techniques. 7\\. Applications of visualization in
different fields. 8\\. Interaction methods for graphical environments.
Illustrative Learning Outcomes: 1\\. Explain the graphics rendering pipeline.
2\\. Differentiate between rasterization and ray tracing. 3\\. Apply
transformations to 2D and 3D models."""^^xsd:string ;
            ns3:score "0.63397145"^^xsd:float ;
            ns1:answer "1" ;
            ns1:explain "The lecture covers 7 out of 8 learning outcomes and 4 out of 5 fundamental concepts, substantially covering the knowledge described in the KU." ;
            ns1:ka "Graphics_and_Interactive_Techniques_GIT" ;
            ns1:ku "GIT-Fundamentals" ;
            ns2:wasGeneratedBy [ ns2:used "llama3-8b-8192" ] ] ;
    ns3:uetext "Label: Stage libre Objectif: (résultats d'apprentissage) Course content: Méthodes d’enseignement Course name: http://example.org/course/UE_XLG4TU030" .

