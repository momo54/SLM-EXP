[["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Synchronization_and_Concurrency.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nPDC-Synchronization and Concurrency: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of PDC-Synchronization and Concurrency.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Cloud_and_HPC.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nPDC-Cloud and HPC: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of PDC-Cloud and HPC.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Grid_Computing.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nPDC-Grid Computing: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of PDC-Grid Computing.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Fault_Tolerance.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nPDC-Fault Tolerance: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of PDC-Fault Tolerance.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Distributed_Systems.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nPDC-Distributed Systems: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of PDC-Distributed Systems.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Concepts.txt", "Pages: 217-218\nHOURS\n    CS Core = 3\n    KA Core = 2\n\nPDC-Concepts: Parallel and Distributed Computing Fundamentals\nCS Core:\n1. Introduction to parallel and distributed computing.\n2. Concepts of concurrency and parallelism.\n3. Multithreading and shared memory models.\n4. Message passing and synchronization mechanisms.\n5. Fault tolerance in distributed systems."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Concepts.txt", "KA Core:\n6. Advanced scheduling techniques.\n7. Performance evaluation and scalability analysis.\n8. Real-world applications in cloud computing and HPC.\n\nIllustrative Learning Outcomes:\n1. Describe key differences between parallel and distributed systems.\n2. Apply synchronization techniques to prevent race conditions.\n3. Evaluate the performance of parallel algorithms."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Performance_Evaluation.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nPDC-Performance Evaluation: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of PDC-Performance Evaluation.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Parallel_and_Distributed_Computing_PDC/PDC-Parallel_Algorithms.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nPDC-Parallel Algorithms: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of PDC-Parallel Algorithms.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Emerging_Emerging_Topics.txt", "Pages: 201\n\nHOURS\n\tCS Core = .\n\tKA Core = 4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Emerging_Emerging_Topics.txt", "NC-Emerging: Emerging Topics\nKA Core:\n1. Middleboxes (e.g., advances in usage of AI, intent-based networking, filtering, deep packet\ninspection, load balancing, NAT, CDN)\n2. Network Virtualization (e.g., SDN, Data Center Networks)\n3. Quantum Networking (e.g., Intro to the domain, teleportation, security, Quantum Internet)\n4. Satellite, mmWave, Visible Light\nIllustrative Learning Outcomes:\nKA Core:\n1. Describe the value of advances in middleboxes in networks.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Emerging_Emerging_Topics.txt", ".\n2. Describe the importance of Software Defined Networks.\n3. Describe some of the added value achieved by using Quantum Networking."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-SingleHop_Single_Hop_Communication.txt", "Pages: 200\n\nHOURS\n\tCS Core = .\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-SingleHop_Single_Hop_Communication.txt", "NC-SingleHop: Single Hop Communication\nKA Core:\n1. Introduction to modulation, bandwidth, and communication media\n2. Encoding and Framing\n3. Medium Access Control (MAC) (e.g., random access and scheduled access)\n4. Ethernet and WiFi\n5. Switching (e.g., spanning trees, VLANS).\n6. Local Area Network Topologies (e.g., data center, campus networks).\nIllustrative Learning Outcomes:\nKA Core:\n1. Describe some basic aspects of modulation, bandwidth, and communication media.\n2. Describe in detail a MAC protocol.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-SingleHop_Single_Hop_Communication.txt", ".\n2. Describe in detail a MAC protocol.\n3. Demonstrate understanding of encoding and framing solution tradeoffs.\n4. Describe details of the implementation of Ethernet.\n5. Describe how switching works.\n6. Describe one kind of a LAN topology."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Security_Network_Security.txt", "Pages: 200-201\n\nHOURS\n\tCS Core = .\n\tKA Core = 2.25 + 0.5 (SEC) + 0.25 (SEP)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Security_Network_Security.txt", "NC-Security: Network Security\nKA Core:\n1. General intro about security (Threats, vulnerabilities, and countermeasures) (See also: SEPSecurity, SEC-Foundations, SEC-Engineering)\n2. Network specific threats and attack types (e.g., denial of service, spoofing, sniffing and traffic\nredirection, attacker-in-the-middle, message integrity attacks, routing attacks, ransomware, and\ntraffic analysis) (See also: SEC-Foundations, SEC-Engineering)\n3. Countermeasures (: SEC-Foundations, SEC-Crypto, SEC-Engineering)\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Security_Network_Security.txt", ". Cryptography (e.g. SSL, TLS, symmetric/asymmetric)\nb. Architectures for secure networks (e.g., secure channels, secure routing protocols, secure\nDNS, VPNs, DMZ, Zero Trust Network Access, hyper network security, anonymous\ncommunication protocols, isolation)\nc. Network monitoring, intrusion detection, firewalls, spoofing and DoS protection, honeypots,\ntracebacks, BGP Sec, RPKI\nIllustrative Learning Outcomes:\nKA Core:\n1. Describe some of the threat models of network security. \n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Security_Network_Security.txt", ". \n2. Describe specific network-based countermeasures.\n3. Analyze various aspects of network security from a case study."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Mobility_Mobility.txt", "Pages: 201\n\nHOURS\n\tCS Core = .\n\tKA Core = 4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Mobility_Mobility.txt", "NC-Mobility: Mobility\nKA Core:\n1. Principles of cellular communication (e.g., 4G, 5G)\n2. Principles of Wireless LANs (mainly 802.11)\n3. Device to device communication (e.g., IoT communication)\n4. Multi-hop wireless networks (e.g., ad hoc networks, opportunistic, delay tolerant)\nIllustrative Learning Outcomes:\nKA Core:\n1. Describe some aspects of cellular communication such as registration\n2. Describe how 802.11 supports mobile users\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Mobility_Mobility.txt", ". Describe how 802.11 supports mobile users\n3. Describe practical uses of device-to-device communication, as well as multihop\n4. Describe one type of mobile network such as ad hoc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Applications_Networked_Applications.txt", "Pages: 199\n\nHOURS\n\tCS Core = 3.5 + 0.25 (SEP) + 0.25 (PDC)\n\tKA Core = ."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Applications_Networked_Applications.txt", "NC-Applications: Networked Applications\nCS Core:\n1. Naming and address schemes (e.g., DNS, and Uniform Resource Identifiers)\n2. Distributed application paradigms (e.g., client/server, peer-to-peer, cloud, edge, and fog) (See also:\nPDC-Communication, PDC-Coordination)\n3. Diversity of networked application demands (e.g., latency, bandwidth, and loss tolerance) (See\nalso: PDC-Communication, SEP-Sustainability, SEP-Context)\n4. Coverage of application-layer protocols (e.g., HTTP)\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Applications_Networked_Applications.txt", ".g., HTTP)\n5. Interactions with TCP, UDP, and Socket APIs (See also: PDC-Programs)\nIllustrative Learning Outcomes:\nCS Core:\n1. Define the principles of naming, addressing, resource location.\n2. Analyze the needs of specific networked application demands.\n3. Describe the details of one application layer protocol.\n4. Implement a simple client-server socket-based application."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Routing_Routing_and_Forwarding.txt", "Pages: 199-200\n\nHOURS\n\tCS Core = .\n\tKA Core = 4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Routing_Routing_and_Forwarding.txt", "NC-Routing: Routing and Forwarding\nKA Core:\n1. Routing paradigms and hierarchy (e.g., intra/inter domain, centralized and decentralized, source\nrouting, virtual circuits, QoS)\n2. Forwarding methods (e.g., forwarding tables and matching algorithms)\n3. IP and Scalability issues (e.g., NAT, CIDR, BGP, different versions of IP)\nIllustrative Learning Outcomes:\nKA Core:\n1. Describe various routing paradigms and hierarchies.\n2. Describe how packets are forwarded in an IP network.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Routing_Routing_and_Forwarding.txt", ".\n3. Describe how the Internet tackles scalability challenges. ."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt", "Pages: 198-199\n\nHOURS\n\tCS Core = 2.5 + 0.25 (SEP) + 0.25 (SF)\n\tKA Core = ."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt", "NC-Fundamentals: Fundamentals\nCS Core:\n1. Importance of networking in contemporary computing, and associated challenges. (See also: SEPContext, SEP-Privacy)\n2. Organization of the internet (e.g., users, Internet Service Providers, autonomous systems, content\nproviders, content delivery networks)\n3. Switching techniques (e.g., circuit and packet)\n4. Layers and their roles (application, transport, network, datalink, and physical)\n5. Layering principles (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt", ". Layering principles (e.g., encapsulation and hourglass model) (See also: SF-Foundations)\n6. Network elements (e.g., routers, switches, hubs, access points, and hosts)\n7. Basic queueing concepts (e.g., relationship with latency, congestion, service levels, etc.)\nIllustrative Learning Outcomes:\nCS Core:\n1. Articulate the organization of the internet.\n2. List and define the appropriate network terminology\n3. Describe the layered structure of a typical networked architecture.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Fundamentals_Fundamentals.txt", ".\n4. Identify the different types of complexity in a network (edges, core, etc.)."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Reliability_Reliability_Support.txt", "Pages: 199\n\nHOURS\n\tCS Core = .\n\tKA Core = 5.75 + 0.25 (SF)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Reliability_Reliability_Support.txt", "NC-Reliability: Reliability Support\nKA Core:\n1. Unreliable delivery (e.g., UDP)\n2. Principles of reliability (e.g., delivery without loss, duplication, or out of order) (See also: SFReliability)\n3. Error control (e.g., retransmission, error correction)\n4. Flow control (e.g., stop and wait, window based)\n5. Congestion control (e.g., implicit and explicit congestion notification)\n6. TCP and performance issues (e.g., Tahoe, Reno, Vegas, Cubic)\nIllustrative Learning Outcomes:\nKA Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Networking_and_Communication_NC/NC-Reliability_Reliability_Support.txt", ". Describe the operation of reliable delivery protocols.\n2. List the factors that affect the performance of reliable delivery protocols.\n3. Describe some TCP reliability design issues.\n4. Design and implement a simple reliable protocol."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt", "Pages: 192-194\n\nHOURS\n\tCS Core = 0\n\tKA Core = 40"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt", "MSF-Calculus\nKA Core:\n1. Sequences, series, limits\n2. Single-variable derivatives: definition, computation rules (chain rule etc.), derivatives of important\nfunctions, applications\n3. Single-variable integration: definition, computation rules, integrals of important functions,\nfundamental theorem of calculus, definite vs indefinite, applications (including in probability)\n4. Parametric and polar representations\n5. Taylor series\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt", ". Taylor series\n6. Multivariate calculus: partial derivatives, gradient, chain-rule, vector valued functions,\n7. Optimization: convexity, global vs local minima, gradient descent, constrained optimization, and\nLagrange multipliers.\n8. Ordinary Differential Equations (ODEs): definition, Euler method, applications to simulation, Monte\nCarlo integration\n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt", ". CS applications: gradient descent for machine learning, forward and inverse kinematics,\napplications of calculus to probability\nNote: the calculus topics listed above are aligned with computer science goals rather than with\ntraditional calculus courses. For example, multivariate calculus is often a course by itself, but computer\nscience undergraduates only need parts of it for machine learning.\nIllustrative Learning Outcomes:\nKA Core:\n1. Sequences, series, limits\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt", ". Sequences, series, limits\na. Explain the difference between infinite sets and sequences.\nb. Explain the formal definition of a limit.\nc. Derive the limit for examples of sequences and series.\nd. Explain convergence and divergence.\ne. Apply L\u2019Hospital\u2019s rule and other approaches to resolving limits.\n2. Single-variable derivatives: definition, computation rules (chain rule etc.), derivatives of important\nfunctions, applications\na. Explain a derivative in terms of limits.\nb. Explain derivatives as functions"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt", ".\nb. Explain derivatives as functions.\nc. Perform elementary derivative calculations from limits.\nd. Apply sum, product, and quotient rules.\ne. Work through examples with important functions.\n3. Single-variable integration: definition, computation rules, integrals of important functions,\nfundamental theorem of calculus, definite vs indefinite, applications (including in probability)\na. Explain the definitions of definite and indefinite integrals.\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt", ".\nb. Apply integration rules to examples with important functions.\nc. Explore the use of the fundamental theorem of calculus.\nd. Apply integration to problems.\n4. Parametric and polar representations\na. Apply parametric representations of important curves.\nb. Apply polar representations.\n5. Taylor series\na. Derive Taylor series for some important functions.\nb. Apply the Taylor series to approximations.\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt", ".\nb. Apply the Taylor series to approximations.\n6. Multivariate calculus: partial derivatives, gradient, chain-rule, vector valued functions, applications\nto optimization, convexity, global vs local minima.\na. Compute partial derivatives and gradients.\nb. Work through examples with vector-valued functions with gradient notation.\nc. Explain applications to optimization.\n7. ODEs: definition, Euler method, applications to simulation\na. Apply the Euler method to integration.\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Calculus.txt", ". Apply the Euler method to integration.\nb. Apply the Euler method to a single-variable differential equation.\nc. Apply the Euler method to multiple variables in an ODE."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt", "Pages: 188-189\n\nHOURS\n\tCS Core = 11\n\tKA Core = 29"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt", "MSF-Probability: Probability\nCS Core:\n1. Basic notions: sample spaces, events, probability, conditional probability, Bayes\u2019 rule\n2. Discrete random variables and distributions\n3. Continuous random variables and distributions\n4. Expectation, variance, law of large numbers, central limit theorem\n5. Conditional distributions and expectation\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt", ". Conditional distributions and expectation\n6. Applications to computing, the difference between probability and statistics (as subjects)\nKA Core:\nThe recommended topics are the same between CS core and KA-core, but with far more hours, the\nKA-core can cover these topics in depth and might include more computing-related applications.\nIllustrative Learning Outcomes:\nCS Core:\n1. Basic notions: sample spaces, events, probability, conditional probability, Bayes\u2019 rule\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt", ". Translate a prose description of a probabilistic process into a formal setting of sample spaces,\noutcome probabilities, and events.\nb. Calculate the probability of simple events.\nc. Determine whether two events are independent.\nd. Compute conditional probabilities, including through applying (and explaining) Bayes' Rule.\n2. Discrete random variables and distributions\na. Define the concept of a random variable and indicator random variable.\nb. Determine whether two random variables are independent.\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt", ".\nc. Identify common discrete distributions (e.g., uniform, Bernoulli, binomial, geometric).\n3. Continuous random variables and distributions\na. Identify common continuous distributions (e.g., uniform, normal, exponential).\nb. Calculate probabilities using cumulative density functions.\n4. Expectation, variance, law of large numbers, central limit theorem\na. Define the concept of expectation and variance of a random variable.\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt", ".\nb. Compute the expected value and variance of simple or common discrete/continuous random\nvariables.\nc. Explain the relevance of the law of large numbers and central limit theorem to probability\ncalculations.\n5. Conditional distributions and expectation\na. Explain the distinction between joint, marginal, and conditional distributions.\nb. Compute marginal and conditional distributions from a full distribution, for both discrete and\ncontinuous random variables.\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Probability_Probability.txt", ".\nc. Compute conditional expectations for both discrete and continuous random variables.\n6. Applications to computing\na. Describe how probability can be used to model real-life situations or applications, such as\npredictive text, hash tables, and quantum computation.\nb. Apply probabilistic processes to solving computational problems, such as through randomized\nalgorithms or in security contexts."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", "Pages: 187-188\n\nHOURS\n\tCS Core = 29\n\tKA Core = 11"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", "MSF-Discrete: Discrete Mathematics\nCS Core:\n1. Sets, relations, functions, cardinality\n2. Recursive mathematical definitions\n3. Proof techniques (induction, proof by contradiction)\n4. Permutations, combinations, counting, pigeonhole principle\n5. Modular arithmetic\n6. Logic: truth tables, connectives (operators), inference rules, formulas, normal forms, simple\npredicate logic\n7. Graphs: basic definitions\n8. Order notation\nIllustrative Learning Outcomes:\nCS Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", ". Sets, Relations, and Functions, Cardinality\na. Explain with examples the basic terminology of functions, relations, and sets.\nb. Perform the operations associated with sets, functions, and relations.\nc. Relate practical examples to the appropriate set, function, or relation model, and interpret the\nassociated operations and terminology in context.\nd. Calculate the size of a finite set, including making use of the sum and product rules and\ninclusion-exclusion principle.\ne"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", ".\ne. Explain the difference between finite, countable, and uncountable sets.\n2. Recursive mathematical definitions\na. Apply recursive definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,\nparse trees, fractals).\nb. Formulate inductive proofs of statements about recursive definitions.\nc. Solve a variety of basic recurrence relations.\nd. Analyze a problem to determine underlying recurrence relations.\ne"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", ".\ne. Given a recursive/iterative code snippet, describe its underlying recurrence relation, hypothesize\na closed form for the recurrence relation, and prove the hypothesis correct (usually, using\ninduction).\n3. Proof Techniques\na. Identify the proof technique used in a given proof.\nb. Outline the basic structure of each proof technique (direct proof, proof by contradiction, and\ninduction) described in this unit.\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", ".\nc. Apply each of the proof techniques (direct proof, proof by contradiction, and induction) correctly\nin the construction of a sound argument.\nd. Determine which type of proof is best for a given problem.\ne. Explain the parallels between ideas of mathematical and/or structural induction to recursion and\nrecursively defined structures.\nf. Explain the relationship between weak and strong induction and give examples of the\nappropriate use of each.\n4. Permutations, combinations, and counting\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", ".\n4. Permutations, combinations, and counting\na. Apply counting arguments, including sum and product rules, inclusion-exclusion principle, and\narithmetic/geometric progressions.\nb. Apply the pigeonhole principle in the context of a formal proof.\nc. Compute permutations and combinations of a set, and interpret the meaning in the context of\nthe specific application.\nd"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", ".\nd. Map real-world applications to appropriate counting formalisms, such as determining the\nnumber of ways to arrange people around a table, subject to constraints on the seating\narrangement, or the number of ways to determine certain hands in cards (e.g., a full house).\n5. Modular arithmetic\na. Perform computations involving modular arithmetic.\nb. Explain the notion of the greatest common divisor and apply Euclid's algorithm to compute it.\n6. Logic\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", ".\n6. Logic\na. Convert logical statements from informal language to propositional and predicate logic\nexpressions.\nb. Apply formal methods of symbolic propositional and predicate logic, such as calculating validity\nof formulae, computing normal forms, or negating a logical statement.\nc. Use the rules of inference to construct proofs in propositional and predicate logic.\nd"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", ".\nd. Describe how symbolic logic can be used to model real-life situations or applications, including\nthose arising in computing contexts such as software analysis (e.g., program correctness),\ndatabase queries, and algorithms.\ne. Apply formal logic proofs and/or informal, but rigorous, logical reasoning to real problems, such\nas predicting the behavior of software or solving problems such as puzzles.\nf. Describe the strengths and limitations of propositional and predicate logic.\ng"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", ".\ng. Explain what it means for a proof in propositional (or predicate) logic to be valid.\n7. Graphs\na. Illustrate by example the basic terminology of graph theory, and some of the properties and\nspecial cases of types of graphs, including trees.\nb. Demonstrate different traversal methods for trees and graphs, including pre-, post-, and in-order\ntraversal of trees, along with breadth-first and depth-first search for graphs.\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", ".\nc. Model a variety of real-world problems in computer science using appropriate forms of graphs\nand trees, such as representing a network topology, the organization of a hierarchical file\nsystem, or a social network.\nd. Show how concepts from graphs and trees appear in data structures, algorithms, proof\ntechniques (structural induction), and counting"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Discrete_Discrete_Mathematics.txt", ".\nKA Core:\nThe recommended topics are the same between CS core and KA-core, but with far more hours, the\nKA-core can cover these topics in depth and might include more computing-related applications."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Linear_Linear_Algebra.txt", "Pages: 191-192\n\nHOURS\n\tCS Core = 5\n\tKA Core = 35"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Linear_Linear_Algebra.txt", "MSF-Linear: Linear Algebra\nCS Core:\n1. Vectors: definitions, vector operations, geometric interpretation, angles: Matrices: definition, matrix\noperations, meaning of Ax=b.\nKA Core:\n2. Matrices, matrix-vector equation, geometric interpretation, geometric transformations with matrices\n3. Solving equations, row-reduction\n4. Linear independence, span, basis\n5. Orthogonality, projection, least-squares, orthogonal bases\n6. Linear combinations of polynomials, Bezier curves\n7. Eigenvectors and eigenvalues\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Linear_Linear_Algebra.txt", ". Eigenvectors and eigenvalues\n8. Applications to computer science: Principal Components Analysis (PCA), Singular Value\nDecomposition (SVD), page-rank, graphics\nIllustrative Learning Outcomes:\nCS Core:\n1. Vectors: definitions, vector operations, geometric interpretation, angles\na. Describe algebraic and geometric representations of vectors in Rn and their operations,\nincluding addition, scalar multiplication, and dot product.\nb. List properties of vectors in Rn.\nc. Compute angles between vectors in Rn"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Linear_Linear_Algebra.txt", ".\nc. Compute angles between vectors in Rn.\nKA Core:\n2. Matrices, matrix-vector equation, geometric interpretation, geometric transformations with matrices\na. Perform common matrix operations, such as addition, scalar multiplication, multiplication, and\ntransposition.\nb. Relate a matrix to a homogeneous system of linear equations.\nc. Recognize when two matrices can be multiplied.\nd. Relate various matrix transformations to geometric illustrations.\n3. Solving equations, row-reduction\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Linear_Linear_Algebra.txt", ".\n3. Solving equations, row-reduction\na. Formulate, solve, apply, and interpret properties of linear systems.\nb. Perform row operations on a matrix.\nc. Relate an augmented matrix to a system of linear equations.\nd. Solve linear systems of equations using the language of matrices.\ne. Translate word problems into linear equations.\nf. Perform Gaussian elimination.\n4. Linear independence, span, basis\na. Define subspace of a vector space.\nb. List examples of subspaces of a vector space.\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Linear_Linear_Algebra.txt", ". List examples of subspaces of a vector space.\nc. Recognize and use basic properties of subspaces and vector spaces.\nd. Determine if specific subsets of a vector space are subspaces.\ne. Discuss the existence of a basis of an abstract vector space.\nf. Describe coordinates of a vector relative to a given basis.\ng. Determine a basis for and the dimension of a finite-dimensional space.\nh. Discuss spanning sets for vectors in Rn.\ni. Discuss linear independence for vectors in Rn.\nj"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Linear_Linear_Algebra.txt", ". Discuss linear independence for vectors in Rn.\nj. Define the dimension of a vector space.\n5. Orthogonality, projection, least-squares, orthogonal bases\na. Explain the Gram-Schmidt orthogonalization process.\nb. Define orthogonal projections.\nc. Define orthogonal complements.\nd. Compute the orthogonal projection of a vector onto a subspace, given a basis for the subspace.\ne. Explain how orthogonal projections relate to least square approximations.\n6. Linear combinations of polynomials, Bezier curves\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Linear_Linear_Algebra.txt", ". Identify polynomials as generalized vectors.\nb. Explain linear combinations of basic polynomials.\nc. Describe orthogonality for polynomials.\nd. Distinguish between basic polynomials and Bernstein polynomials.\ne. Apply Bernstein polynomials to Bezier curves.\n7. Eigenvectors and eigenvalues\na. Find the eigenvalues and eigenvectors of a matrix.\nb. Define eigenvalues and eigenvectors geometrically.\nc. Use characteristic polynomials to compute eigenvalues and eigenvectors.\nd"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Linear_Linear_Algebra.txt", ".\nd. Use eigenspaces of matrices, when possible, to diagonalize a matrix.\ne. Perform diagonalization of matrices.\nf. Explain the significance of eigenvectors and eigenvalues.\ng. Find the characteristic polynomial of a matrix.\nh. Use eigenvectors to represent a linear transformation with respect to a particularly nice basis.\n8. Applications to computer science: PCA, SVD, page-rank, graphics\na. Explain the geometric properties of PCA.\nb. Relate PCA to dimensionality reduction.\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Linear_Linear_Algebra.txt", ".\nb. Relate PCA to dimensionality reduction.\nc. Relate PCA to solving least-squares problems.\nd. Relate PCA to solving eigenvector problems.\ne. Apply PCA to reducing the dimensionality of a high-dimensional dataset (e.g., images).\nf. Explain the page-rank algorithm and understand how it relates to eigenvector problems.\ng. Explain the geometric differences between SVD and PCA.\nh. Apply SVD to a concrete example (e.g., movie rankings)."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Statistics_Statistics.txt", "Pages: 190-191\n\nHOURS\n\tCS Core = 10\n\tKA Core = 30"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Statistics_Statistics.txt", "MSF-Statistics: Statistics\nCS Core:\n1. Basic definitions and concepts: populations, samples, measures of central tendency, variance\n2. Univariate data: point estimation, confidence intervals\nKA Core:\n3. Multivariate data: estimation, correlation, regression\n4. Data transformation: dimension reduction, smoothing\n5. Statistical models and algorithms\n6. Hypothesis testing\nIllustrative Learning Outcomes:\nCS Core:\n1. Basic definitions and concepts: populations, samples, measures of central tendency, variance\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Statistics_Statistics.txt", ". Create and interpret frequency tables.\nb. Display data graphically and interpret graphs (e.g., histograms).\nc. Recognize, describe, and calculate means, medians, quantiles (location of data).\nd. Recognize, describe, and calculate variances, interquartile ranges (spread of data).\n2. Univariate data: point estimation, confidence intervals\na. Formulate maximum likelihood estimation (in linear-Gaussian settings) as a least-squares\nproblem.\nb. Calculate maximum likelihood estimates.\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Statistics_Statistics.txt", ".\nb. Calculate maximum likelihood estimates.\nc. Calculate maximum a posteriori estimates and make a connection with regularized least\nsquares.\nd. Compute confidence intervals as a measure of uncertainty.\nKA Core:\n3. Sampling, bias, adequacy of samples, Bayesian vs frequentist interpretations\n4. Multivariate data: estimation, correlation, regression\na. Formulate the multivariate maximum likelihood estimation problem as a least-squares problem.\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Statistics_Statistics.txt", ".\nb. Interpret the geometric properties of maximum likelihood estimates.\nc. Derive and calculate the maximum likelihood solution for linear regression.\nd. Derive and calculate the maximum a posteriori estimates for linear regression.\ne. Implement both maximum likelihood and maximum a posteriori estimates in the context of a\npolynomial regression problem.\nf. Formulate and understand the concept of data correlation (e.g., in 2D)\n5. Data transformation: dimension reduction, smoothing\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Statistics_Statistics.txt", ". Formulate and derive Principal Component Analysis (PCA) as a least-squares problem.\nb. Geometrically interpret PCA (when solved as a least-squares problem).\nc. Describe when PCA works well (one can relate back to correlated data).\nd. Geometrically interpret the linear regression solution (maximum likelihood).\n6. Statistical models and algorithms\na. Apply PCA to dimensionality reduction problems.\nb. Describe the tradeoff between compression and reconstruction power.\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Mathematical_and_Statistical_Foundations_MSF/MSF-Statistics_Statistics.txt", ".\nc. Apply linear regression to curve-fitting problems.\nd. Explain the concept of overfitting.\ne. Discuss and apply cross-validation in the context of overfitting and model selection (e.g., degree\nof polynomials in a regression context)."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Quantum_Quantum_Architectures.txt", "Pages:108-109\n\nHOURS\n\tCS Core = 0\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Quantum_Quantum_Architectures.txt", "AR-Quantum: Quantum Architectures\nKA Core:\n1. Principles (See also: AL-Models: 8)\na. The wave-particle duality principle\nb. The uncertainty principle in the double-slit experiment\nc. What is a Qubit? Superposition, interference, and measurement. Photons as qubits\nd. Systems of two qubits, Entanglement, Bell states, The No-Signaling theorem\n2. Axioms of QM: superposition principle, measurement axiom, unitary evolution\n3. Single qubit gates for the circuit model of quantum computation: X, Z, H\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Quantum_Quantum_Architectures.txt", ". Two qubit gates and tensor products, working with matrices\n5. The No-Cloning Theorem. The Quantum Teleportation protocol\n6. Algorithms (See also: AL-Foundational)\na. Simple quantum algorithms: Bernstein-Vazirani, Simon\u2019s algorithm\nb. Implementing Deutsch-Josza with Mach-Zehnder Interferometers\nc. Quantum factoring (Shor\u2019s Algorithm)\nd. Quantum search (Grover\u2019s Algorithm)\n7. Implementation aspects (See also: SPD-Interactive)\na. The physical implementation of qubits\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Quantum_Quantum_Architectures.txt", ". The physical implementation of qubits\nb. Classical control of a Quantum Processing Unit (QPU)\nc. Error mitigation and control, NISQ and beyond\n109\nd. Measurement approaches\n8. Emerging Applications\na. Post-quantum encryption\nb. The Quantum Internet\nc. Adiabatic quantum computation (AQC) and quantum annealing\nIllustrative Learning Outcomes:\nKA Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Quantum_Quantum_Architectures.txt", ". Discuss how a quantum object produced as a particle propagates like a wave and is detected as a\nparticle with a probability distribution corresponding to the wave.\n2. Discuss the quantum-level nature that is inherently probabilistic.\n3. Express your view on entanglement that can be used to create non-classical correlations, but there\nis no way to use quantum entanglement to send messages faster than the speed of light.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Quantum_Quantum_Architectures.txt", ".\n4. Describe quantum parallelism and the role of constructive vs destructive interference in quantum\nalgorithms given the probabilistic nature of measurement(s).\n5. Analyze a code snippet providing the role of quantum Fourier transform (QFT) in Shor\u2019s algorithm.\n6. Write a program to implement Shor\u2019s algorithm in a simulator, highlighting the classical components\nand aspects of Shor\u2019s algorithm.\n7. Enumerate the specifics of each qubit modality (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Quantum_Quantum_Architectures.txt", ".g., trapped ion, superconducting, silicon spin,\nphotonic, quantum dot, neutral atom, topological, color center, electron-on-helium).\n8. Contrast AQC with the gate model of quantum computation and the problems each is better suited\nto solve."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Representation_Machine-Level_Data_Representation.txt", "Pages:103-103\n\nHOURS\n\tCS Core = 1\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Representation_Machine-Level_Data_Representation.txt", "AR-Representation: Machine-Level Data Representation\nCS Core:\n1. Overview and history of computer architecture (See also: SPD-Game)\n2. Bits, bytes, and words\n3. Unsigned, signed and two\u2019s complement representations\n4. Numeric data representation and number bases\na. Fixed-point\nb. Floating-point\n5. Representation of non-numeric data\n6. Representation of records, arrays and UTF data types (See also: AL-Foundational)\nIllustrative Learning Outcomes:\nCS Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Representation_Machine-Level_Data_Representation.txt", ". Discuss why everything in computers are data, including instructions.\n2. Explain how fixed-length number representations can affect accuracy and precision.\n3. Describe how negative integers are stored in sign-magnitude and two\u2019s-complement\nrepresentations.\n4. Discuss how different formats can represent numerical data.\n5. Explain the bit-level representation of non-numeric data, such as characters, strings, records, and\narrays.\n6. Translate numerical data from one format to another.\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Representation_Machine-Level_Data_Representation.txt", ".\n7. Describe how a single adder (without overflow detection) can handle both signed (two\u2019s\ncomplement) and unsigned (binary) input without \u201cknowing\u201d which format a given input is using."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Organization_Functional_Organization.txt", "Pages:106-106\n\nHOURS\n\tCS Core = 0\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Organization_Functional_Organization.txt", "AR-Organization: Functional Organization\nKA Core:\n1. Implementation of simple datapaths, including instruction pipelining, hazard detection, and\nresolution (e.g., stalls, forwarding)\n2. Control unit\na. Hardwired implementation\nb. Microprogrammed realization\n3. Instruction pipelining (See also: SF-Overview)\n4. Introduction to instruction-level parallelism (ILP) (See also: PDC-Programs)\nIllustrative Learning Outcomes:\nKA Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Organization_Functional_Organization.txt", ". Compare alternative implementation of datapaths in modern computer architectures.\n2. Produce a set of control signals for adding two integers using hardwired and microprogrammed\nimplementations.\n3. Discuss instruction-level parallelism using pipelining and significant hazards that may occur.\n4. Design a complete processor, including datapath and control.\n5. Compute the average cycles per instruction for a given processor and memory system\nimplementation."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Memory_Memory_Hierarchy.txt", "Pages:104-105\n\nHOURS\n\tCS Core = 6\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Memory_Memory_Hierarchy.txt", "AR-Memory: Memory Hierarchy\nCS Core:\n1. Memory hierarchy: the importance of temporal and spatial locality (See also: SF-Performance, OS-\nMemory)\n2. Main memory organization and operations (See also: OS-Memory)\n3. Persistent memory (e.g., SSD, standard disks)\n4. Latency, cycle time, bandwidth, and interleaving (See also: SF-Performance)\n5. Cache memories (See also: SF-Performance)\na. Address mapping\nb. Block size\n105\nc. Replacement and store policy\nd. Prefetching\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Memory_Memory_Hierarchy.txt", ". Replacement and store policy\nd. Prefetching\n6. Multiprocessor cache coherence (See also: OS-Scheduling)\n7. Virtual memory (hardware support) (See also: OS-Memory)\n8. Fault handling and reliability (See also: SF-Reliability)\n9. Reliability (See also: SF-Reliability, OS-Faults)\na. Error coding\nb. Data compression\nc. Data integrity\nKA Core:\n10. Processing In-Memory (PIM)\nIllustrative Learning Outcomes:\nCS Core:\n1. Using a memory system diagram, identify the main types of memory technology (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Memory_Memory_Hierarchy.txt", ".g., SRAM,\nDRAM) and their relative cost and performance.\n2. Measure the effect of memory latency on running time.\n3. Enumerate the functions of a system with virtual memory management.\n4. Compute average memory access time under various cache and memory configurations and mixes\nof instruction and data references."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-SEP_Sustainability_Issues.txt", "Pages:109-109\n\nHOURS\n\tCS Core = ?\n\tKA Core = ?"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-SEP_Sustainability_Issues.txt", "AR-SEP: Sustainability Issues\nNon-core:\n1. Environmental impacts of implementation decisions\na. Sustainability goals, resource consumption, and economic viability\nb. Carbon footprint, hardware electronic waste\nc. The energy footprint of data centers at various workloads (e.g., AI model training and use)\nd. Guidelines for sustainable design standards\nIllustrative Learning Outcomes:\nNon-core:\n1. Assess the environmental impacts of a given project\u2019s deployment (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-SEP_Sustainability_Issues.txt", ".g., the energy consumption of\nCPUs and GPUs, contribution to e-waste, and effect of hardware virtualization in data centers)."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Logic_Digital_Logic_and_Digital_Systems.txt", "Pages:102-103\n\nHOURS\n\tCS Core = 0\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Logic_Digital_Logic_and_Digital_Systems.txt", "AR-Logic: Digital Logic and Digital Systems\nKA Core:\n1. Combinational vs sequential logic/field programmable gate arrays (FPGAs) (See also: SF-\nOverview, SF-Foundations, SPD-Embedded)\na. Fundamental combinational\nb. Sequential logic building block\n2. Computer-aided design tools that process hardware and architectural representations\n3. High-level synthesis\na. Register transfer notation\nb. Hardware description language (e.g., Verilog/VHDL/Chisel)\n4. System-on-chip (SoC) design flow\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Logic_Digital_Logic_and_Digital_Systems.txt", ". System-on-chip (SoC) design flow\n5. Physical constraints\na. Gate delays\nb. Fan-in and fan-out\nc. Energy/power\nd. Speed of light\nIllustrative Learning Outcomes:\n103\nKA Core:\n1. Discuss the progression of computer technology components from vacuum tubes to VLSI, from\nmainframe computer architectures to the organization of warehouse-scale computers.\n2. Describe parallelism and data dependencies between and within components in a modern\nheterogeneous computer architecture.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Logic_Digital_Logic_and_Digital_Systems.txt", ".\n3. Explain the relationship between parallelism and power consumption.\n4. Construct the design of basic building blocks for a computer: arithmetic-logic unit (gate-level),\nregisters (gate-level), central processing unit (register transfer-level), and memory (register transfer-\nlevel).\n5. Evaluate simple building blocks (e.g., arithmetic-logic unit, registers, movement between registers)\nof a simple computer design.\n6. Analyze the timing behavior of a pipelined processor, identifying data dependency issues"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Logic_Digital_Logic_and_Digital_Systems.txt", "."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-IO_Interfacing_and_Communication.txt", "Pages:105-105\n\nHOURS\n\tCS Core = 1\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-IO_Interfacing_and_Communication.txt", "AR-IO: Interfacing and Communication\nCS Core:\n1. I/O fundamentals (See also: OS-Devices, PDC-Communication)\na. Handshaking and buffering\nb. Programmed I/O\nc. Interrupt-driven I/O (See also: OS-Principles)\n2. Interrupt structures: vectored and prioritized, interrupt acknowledgment (See also: OS-Principles)\n3. I/O devices (e.g., mouse, keyboard, display, camera, sensors, actuators) (See also: GIT-\nFundamentals, GIT-Interaction, OS-Advanced-Files, PDC-Programs)\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-IO_Interfacing_and_Communication.txt", ". External storage, physical organization, and drives\n5. Buses fundamentals (See also: OS-Devices)\na. Bus protocols\nb. Arbitration\nc. Direct-memory access (DMA)\nIllustrative Learning Outcomes:\nCS Core:\n1. Analyze an interrupt control diagram to comment on how interrupts are used to implement I/O\ncontrol and data transfers.\n2. Enumerate various types of buses in a computer system.\n3. List the advantages of magnetic disks and contrast them with those of solid-state disks."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Security_Secure_Processor_Architectures.txt", "Pages:107-108\n\nHOURS\n\tCS Core = 0\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Security_Secure_Processor_Architectures.txt", "AR-Security: Secure Processor Architectures\nKA core:\n1. Principles of Secure Hardware\na. Security Risk Analysis, Asset Protection, and Threat Model\nb. Cryptographic Acceleration with Hardware (See also: SEC-Crypto)\n108\nc. Support for virtualization (e.g., OS isolation)\n2. Roots of trust in hardware, Physically Unclonable Functions (PUF)\n3. Hardware Random Number Generators\n4. Memory protection extensions\na. Runtime pointer bounds checking (e.g., buffer overflow)\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Security_Secure_Processor_Architectures.txt", ".g., buffer overflow)\nb. Protection at the microarchitectural level\nc. Protection at the ISA level\n5. Trusted Execution Environment (TEE)\na. Trusted Computer Base Protections\nb. Protecting virtual machines\nc. Protecting containers\nd. Trusted software modules (Enclaves)\n6. Homomorphic encryption for privacy-preserving data processing\nIllustrative Learning Outcomes\nKA Core:\n1. Discuss principles of secure hardware, exploring a framework for risk analysis and asset protection.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Security_Secure_Processor_Architectures.txt", ".\n2. Summarize how Physically Unclonable Functions (PUF) can be a unique device identifier in security\napplications.\n3. Distinguish a random number generator with dedicated hardware support from generators without\nhardware dedicated to generating entropy.\n4. List the advantages and disadvantages of memory protection at the ISA level.\n5. Describe key design issues of a trusted execution environment (TEE) to support virtual machines."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt", "Pages:103-104\n\nHOURS\n\tCS Core = 1\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt", "AR-Assembly: Assembly Level Machine Organization\nCS Core:\n1. von Neumann machine architecture\n2. Control unit: instruction fetch, decode, and execution (See also: OS-Principles)\n3. Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs, OS-Scheduling,\nOS-Process)\n104\n4. Shared memory multiprocessors/multicore organization (See also: PDC-Programs, OS-Scheduling)\nKA Core:\n5. Instruction set architecture (ISA) (e.g., x86, ARM and RISC-V)\na. Fixed vs variable-width instruction sets\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt", ". Fixed vs variable-width instruction sets\nb. Instruction formats\nc. Data manipulation, control, I/O\nd. Addressing modes\ne. Machine language programming\nf. Assembly language programming\n6. Subroutine call and return mechanisms (See also: FPL-Translation, OS-Principles)\n7. I/O and interrupts (See also: OS-Principles)\n8. Heap, static, stack, and code segments (See also: FPL-Translation, OS-Process)\nIllustrative Learning Outcomes:\nCS Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt", ". Discuss how the classical von Neumann functional units are implemented in embedded systems,\nparticularly on-chip and off-chip memory.\n2. Describe how instructions are executed in a classical von Neumann machine, with extensions for\nthreads, multiprocessor synchronization, and SIMD execution.\n3. Assess an example diagram with instruction-level parallelism and hazards to describe how they are\nmanaged in typical processor pipelines.\nKA Core:\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt", ".\nKA Core:\n4. Discuss how instructions are represented at the machine level and in the context of a symbolic\nassembler.\n5. Map an example of high-level language patterns into assembly/machine language notations.\n6. Contrast different instruction formats considering aspects such as addresses per instruction and\nvariable-length vs fixed-length formats.\n7. Analyze a subroutine diagram to comment on how subroutine calls are handled at the assembly\nlevel.\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Assembly_Assembly_Level_Machine_Organization.txt", ".\n8. Describe basic concepts of interrupts and I/O operations.\n9. Write a simple assembly language program for string/array processing and manipulation."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Heterogeneity_Heterogeneous_Architectures.txt", "Pages:107-107\n\nHOURS\n\tCS Core = 0\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Heterogeneity_Heterogeneous_Architectures.txt", "AR-Heterogeneity: Heterogeneous Architectures\nKA Core:\n1. SIMD and MIMD architectures (e.g., General-Purpose GPUs, TPUs, and NPUs) (See also: PDC-\nPrograms, SPD-Embedded, GIT-Shading, SPD-Game)\n2. Heterogeneous memory systems (See also: OS-Process, PDC-Communication)\na. Shared memory versus distributed memory\nb. Volatile vs non-volatile memory\nc. Coherence protocols\n3. Domain-Specific Architectures (DSAs) (See also: HCI-Accountability, GIT-Shading)\na. Machine Learning Accelerator\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Heterogeneity_Heterogeneous_Architectures.txt", ". Machine Learning Accelerator\nb. In-networking computing (See also: NC-Applications)\nc. Embedded systems for emerging applications\nd. Neuromorphic computing\ne. Edge computing devices\n4. Packaging and integration solutions such as 3DIC and chiplets\n5. Machine learning in architecture design\na. AI algorithms for workload analysis\nb. Optimization of architecture configurations for performance and power efficiency\nIllustrative Learning Outcomes:\nKA Core\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Heterogeneity_Heterogeneous_Architectures.txt", ". Analyze a system diagram with alternative parallel architectures, e.g., SIMD and MIMD, and identify\nthe key differences.\n2. Discuss what memory-management issues are found in multiprocessors that are not present in\nuniprocessors and how these issues might be resolved.\n3. Indicate the differences between memory backplane, processor memory interconnect, and remote\nmemory via networks, their implications for access latency, and their impact on program\nperformance.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Heterogeneity_Heterogeneous_Architectures.txt", ".\n4. Discuss how you would determine when to use a domain-specific accelerator instead of a general-\npurpose CPU.\n5. Enumerate key differences in architectural design principles between a vector and scalar-based\nprocessing unit.\n6. List the advantages and disadvantages of a PIM architecture."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Performance-Energy_Performance_and_Energy_Efficiency.txt", "Pages:106-107\n\nHOURS\n\tCS Core = 0\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Performance-Energy_Performance_and_Energy_Efficiency.txt", "AR-Performance-Energy: Performance and Energy Efficiency\nKA Core:\n1. Performance-energy evaluation (introduction): performance, power consumption, memory, and\ncommunication costs (See also: SF-Evaluation, OS-Scheduling, SPD-Game)\n2. Branch prediction, speculative execution, out-of-order execution, Tomasulo's algorithm\n3. Enhancements for vector processors and GPUs (See also: SPD-Game)\n4. Hardware support for multithreading (See also: OS-Concurrency, OS-Scheduling, PDC-Programs)\na. Race conditions\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Performance-Energy_Performance_and_Energy_Efficiency.txt", ". Race conditions\nb. Lock implementations\nc. Point-to-point synchronization\nd. Barrier implementation\n5. Scalability\n6. Alternative architectures including VLIW/EPIC, accelerators, and other special purpose processors\n7. Dynamic voltage and frequency scaling (DVFS)\n8. Dark Silicon\nIllustrative Learning Outcomes:\nKA Core:\n1. Discuss performance and energy efficiency evaluation metrics.\n2. Analyze a speculative execution diagram and write about the decisions that can be made.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Architecture_and_Organization_AR/AR-Performance-Energy_Performance_and_Energy_Efficiency.txt", ".\n3. Create a GPU performance-watt benchmarking diagram.\n4. Write a multithreaded program that adds (in parallel) elements of two integer vectors.\n5. Recommend a set of design choices for alternative computer architectures.\n107\n6. Enumerate key concepts associated with dynamic voltage and frequency scaling.\n7. Measure energy savings improvement for an 8-bit integer quantization compared to a 32-bit\nquantization."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Project_Management.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSE-Project Management: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SE-Project Management.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Testing_and_Quality_Assurance.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSE-Testing and Quality Assurance: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SE-Testing and Quality Assurance.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Architecture.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSE-Software Architecture: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SE-Software Architecture.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Agile_and_DevOps.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSE-Agile and DevOps: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SE-Agile and DevOps.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Formal_Methods.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSE-Formal Methods: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SE-Formal Methods.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Requirements_Engineering.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSE-Requirements Engineering: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SE-Requirements Engineering.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Usability_and_Human_Factors.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSE-Usability and Human Factors: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SE-Usability and Human Factors.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Development.txt", "Pages: 237-238\nHOURS\n    CS Core = 3\n    KA Core = 2\n\nSE-Software Development: Engineering Software Systems\nCS Core:\n1. Software development lifecycle models.\n2. Requirements engineering principles.\n3. Software design patterns and architectures.\n4. Software testing methodologies.\n5. Version control and collaboration tools.\n\nKA Core:\n6. Agile and DevOps methodologies.\n7. Software maintenance and evolution.\n8. Formal methods for verification and validation."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Software_Development.txt", "Illustrative Learning Outcomes:\n1. Differentiate between various software development models.\n2. Apply software testing techniques to ensure quality assurance.\n3. Explain the role of version control in team-based software development."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Engineering_SE/SE-Maintenance_and_Evolution.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSE-Maintenance and Evolution: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SE-Maintenance and Evolution.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt", "Pages:70-70\n\nHOURS\n\tCS Core = 2\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt", "AI-KRR: Fundamental Knowledge Representation and Reasoning\nCS Core:\n1. Types of representations\na. Symbolic, logical\ni. Creating a representation from a natural language problem statement\nb. Learned subsymbolic representations\nc. Graphical models (e.g., naive Bayes, Bayesian network)\n2. Review of probabilistic reasoning, Bayes theorem (See also: MSF-Probability)\n3. Bayesian reasoning\na. Bayesian inference\nKA Core:\n4. Random variables and probability distributions\na. Axioms of probability\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt", ". Axioms of probability\nb. Probabilistic inference\nc. Bayes\u2019 Rule (derivation)\nd. Bayesian inference (more complex examples)\n5. Independence\n6. Conditional Independence\n7. Markov chains and Markov models\n8. Utility and decision making\nIllustrative Learning Outcomes:\n1. Given a natural language problem statement, encode it as a symbolic or logical representation.\n2. Explain how we can make decisions under uncertainty, using concepts such as Bayes theorem and\nutility.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt", ".\n3. Compute a probabilistic inference in a real-world problem using Bayes\u2019 theorem to determine the\nprobability of a hypothesis given evidence.\n4. Apply Bayes\u2019 rule to determine the probability of a hypothesis given evidence.\n5. Compute the probability of outcomes and test whether outcomes are independent.\n71\nAI-ML: Machine Learning\nCS Core:\n1. Definition and examples of a broad variety of machine learning tasks\na. Supervised learning\ni. Classification\nii. Regression\nb. Reinforcement learning\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-KRR_Fundamental_Knowledge_Representation_and_Reasoning.txt", ". Regression\nb. Reinforcement learning\nc. Unsupervised learning\ni. Clustering\n2. Fundamental ideas:\na. No free lunch theorem: no one learner can solve all problems; representational design decisions\nhave consequences.\nb. Sources of error and undecidability"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt", "Pages:76-77\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt", "AI-LRR: Logical Representation and Reasoning\nNon-core:\n77\n1. Review of propositional and predicate logic (See also: MSF-Discrete)\n2. Resolution and theorem proving (propositional logic only)\na. Forward chaining, backward chaining\n3. Knowledge representation issues\na. Description logics\nb. Ontology engineering\n4. Semantic web\n5. Non-monotonic reasoning (e.g., non-classical logics, default reasoning)\n6. Argumentation\n7. Reasoning about action and change (e.g., situation and event calculus)\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt", ".g., situation and event calculus)\n8. Temporal and spatial reasoning\n9. Logic programming\na. Prolog, Answer Set Programming\n10. Rule-based Expert Systems\n11. Semantic networks\n12. Model-based and Case-based reasoning\nIllustrative Learning Outcomes:\n1. Translate a natural language (e.g., English) sentence into a predicate logic statement.\n2. Convert a logic statement into clausal form.\n3. Apply resolution to a set of logic statements to answer a query.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt", ".\n4. Compare and contrast the most common models used for structured knowledge representation,\nhighlighting their strengths and weaknesses.\n5. Identify the components of non-monotonic reasoning and its usefulness as a representational\nmechanism for belief systems.\n6. Compare and contrast the basic techniques for representing uncertainty.\n7. Compare and contrast the basic techniques for qualitative representation.\n8. Apply situation and event calculus to problems of action and change.\n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt", ".\n9. Explain the distinction between temporal and spatial reasoning, and how they interrelate.\n10. Explain the difference between rule-based, case-based, and model-based reasoning techniques.\n11. Define the concept of a planning system and how it differs from classical search techniques.\n12. Describe the differences between planning as search, operator-based planning, and propositional\nplanning, providing examples of domains where each is most applicable.\n13"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-LRR_Logical_Representation_and_Reasoning.txt", ".\n13. Explain the distinction between monotonic and non-monotonic inference."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Introduction_Fundamental_Issues.txt", "Pages : 67-68\nHOURS\n\tCS Core = 2\n\tKA Core = 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Introduction_Fundamental_Issues.txt", "AI-Introduction: Fundamental Issues\nCS Core:\n1. Overview of AI problems, Examples of successful recent AI applications\n2. Definitions of agents with examples (e.g., reactive, deliberative)\n3. What is intelligent behavior?\na. The Turing test and its flaws\nb. Multimodal input and output\nc. Simulation of intelligent behavior\nd. Rational versus non-rational reasoning\n4. Problem characteristics\na. Fully versus partially observable\nb. Single versus multi-agent\nc. Deterministic versus stochastic\nd"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Introduction_Fundamental_Issues.txt", ". Deterministic versus stochastic\nd. Static versus dynamic\ne. Discrete versus continuous\n5. Nature of agents\n68\na. Autonomous, semi-autonomous, mixed-initiative autonomy\nb. Reflexive, goal-based, and utility-based\nc. Decision making under uncertainty and with incomplete information\nd. The importance of perception and environmental interactions\ne. Learning-based agents\nf. Embodied agents\ni. sensors, dynamics, effectors\n6. Overview of AI Applications, growth, and impact (economic, societal, ethics)\nKA Core:\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Introduction_Fundamental_Issues.txt", ". Practice identifying problem characteristics in example environments\n8. Additional depth on nature of agents with examples\n9. Additional depth on AI Applications, Growth, and Impact (economic, societal, ethics, security)\nNon-core:\n10. Philosophical issues\n11. History of AI\nIllustrative Learning Outcomes:\n1. Describe the Turing test and the \u201cChinese Room\u201d thought experiment.\n2. Differentiate between optimal reasoning/behavior and human-like reasoning/behavior.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Introduction_Fundamental_Issues.txt", ".\n3. Differentiate the terms: AI, machine learning, and deep learning.\n4. Enumerate the characteristics of a specific problem."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Agents_Agents_and_Cognitive_Systems.txt", "Pages:79-79\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Agents_Agents_and_Cognitive_Systems.txt", "AI-Agents: Agents and Cognitive Systems\nNon-core:\n1. Agent architectures (e.g., reactive, layered, cognitive)\n2. Agent theory (including mathematical formalisms)\n3. Rationality, Game Theory\na. Decision-theoretic agents\nb. Markov decision processes (MDP)\nc. Bandit algorithms\n4. Software agents, personal assistants, and information access\na. Collaborative agents\nb. Information-gathering agents\nc. Believable agents (synthetic characters, modeling emotions in agents)\n5. Learning agents\n6. Cognitive systems\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Agents_Agents_and_Cognitive_Systems.txt", ". Learning agents\n6. Cognitive systems\na. Cognitive architectures (e.g., ACT-R, SOAR, ICARUS, FORR)\nb. Capabilities (e.g., perception, decision making, prediction, knowledge maintenance)\nc. Knowledge representation, organization, utilization, acquisition, and refinement\nd. Applications and evaluation of cognitive systems\n7. Multi-agent systems\na. Collaborating agents\nb. Agent teams\nc. Competitive agents (e.g., auctions, voting)\nd. Swarm systems and biologically inspired models\ne. Multi-agent learning\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Agents_Agents_and_Cognitive_Systems.txt", ". Multi-agent learning\n8. Human-agent interaction (See also: HCI-User, HCI-Accessibility)\na. Communication methodologies (verbal and non-verbal)\nb. Practical issues\nc. Applications\ni. Trading agents, supply chain management\nii. Ethical issues of AI interactions with humans\niii. Regulation and legal requirements of AI systems for interacting with humans\nIllustrative Learning Outcomes:\n1. Characterize and contrast the standard agent architectures.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Agents_Agents_and_Cognitive_Systems.txt", ".\n2. Describe the applications of agent theory to domains such as software agents, personal assistants,\nand believable agents, and discuss associated ethical implications.\n3. Describe the primary paradigms used by learning agents.\n4. Demonstrate using appropriate examples how multi-agent systems support agent interaction.\n5. Construct an intelligent agent using a well-established cognitive architecture (ACT-R, SOAR) for\nsolving a specific problem."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt", "Pages:79-80\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt", "AI-NLP: Natural Language Processing\nNon-core:\n1. Deterministic and stochastic grammars\n2. Parsing algorithms\na. CFGs and chart parsers (e.g., CYK)\nb. Probabilistic CFGs and weighted CYK\n3. Representing meaning/Semantics\na. Logic-based knowledge representations\nb. Semantic roles\nc. Temporal representations\nd. Beliefs, desires, and intentions\n4. Corpus-based methods\n5. N-grams and HMMs\n6. Smoothing and backoff\n7. Examples of use: POS tagging and morphology\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt", ". Examples of use: POS tagging and morphology\n8. Information retrieval (See also: DM-Unstructured)\na. Vector space model\ni. TF & IDF\nb. Precision and recall\n9. Information extraction\n10. Language translation\n11. Text classification, categorization\na. Bag of words model\n12. Deep learning for NLP (See also: AI-ML)\na. RNNs\nb. Transformers\nc. Multi-modal embeddings (e.g., images + text)\nd. Generative language models\nIllustrative Learning Outcomes:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt", ". Define and contrast deterministic and stochastic grammars, providing examples to show the\nadequacy of each.\n2. Simulate, apply, or implement classic and stochastic algorithms for parsing natural language.\n3. Identify the challenges of representing meaning.\n4. List the advantages of using standard corpora. Identify examples of current corpora for a variety of\nNLP tasks.\n5. Identify techniques for information retrieval, language translation, and text classification.\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-NLP_Natural_Language_Processing.txt", ".\n6. Implement a TF/IDF transform, use it to extract features from a corpus, and train an off-the-shelf\nmachine learning algorithm using those features to do text classification."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Probability_Probabilistic_Representation_and_Reasoning.txt", "Pages:77-78\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Probability_Probabilistic_Representation_and_Reasoning.txt", "AI-Probability: Probabilistic Representation and Reasoning\nNon-core:\n1. Conditional Independence review\n2. Knowledge representations\na. Bayesian Networks\ni. Exact inference and its complexity\nii. Markov blankets and d-separation\niii. Randomized sampling (Monte Carlo) methods (e.g., Gibbs sampling)\nb. Markov Networks\n78\nc. Relational probability models\nd. Hidden Markov Models\n3. Decision Theory\na. Preferences and utility functions\nb. Maximizing expected utility\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Probability_Probabilistic_Representation_and_Reasoning.txt", ". Maximizing expected utility\nc. Game theory\nIllustrative Learning Outcomes:\n1. Compute the probability of a hypothesis given the evidence in a Bayesian network.\n2. Explain how conditional independence assertions allow for greater efficiency of probabilistic\nsystems.\n3. Identify examples of knowledge representations for reasoning under uncertainty.\n4. State the complexity of exact inference. Identify methods for approximate inference.\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Probability_Probabilistic_Representation_and_Reasoning.txt", ". Identify methods for approximate inference.\n5. Design and implement at least one knowledge representation for reasoning under uncertainty.\n6. Describe the complexities of temporal probabilistic reasoning.\n7. Design and implement an HMM as one example of a temporal probabilistic system.\n8. Describe the relationship between preferences and utility functions.\n9. Explain how utility functions and probabilistic reasoning can be combined to make rational\ndecisions."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_SEP_Applications_and_Societal_Impact.txt", "Pages:75-76\n\nHOURS\n\tCS Core = 3\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_SEP_Applications_and_Societal_Impact.txt", "AI-SEP: Applications and Societal Impact\nNote: There is substantial benefit to studying applications and ethics/fairness/trust/explainability in a\ncurriculum alongside the methods and theory that they apply to, rather than covering ethics in a\nseparate, dedicated class session"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_SEP_Applications_and_Societal_Impact.txt", ". Whenever possible, study of these topics should be integrated\nalongside other modules, such as exploring how decision trees could be applied to a specific problem\nin environmental sustainability such as land use allocation, then assessing the\nsocial/environmental/ethical implications of doing so.\nCS Core:\n1. At least one application of AI to a specific problem and field, such as medicine, health,\nsustainability, social media, economics, education, robotics, etc. (choose at least one for the CS\nCore).\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_SEP_Applications_and_Societal_Impact.txt", ". (choose at least one for the CS\nCore).\na. Formulating and evaluating a specific application as an AI problem\ni. How to deal with underspecified or ill-posed problems\nb. Data availability/scarcity and cleanliness\ni. Basic data cleaning and preprocessing\nii. Data set bias\nc. Algorithmic bias\nd. Evaluation bias\ne. Assessment of societal implications of the application\n2. Deployed deep generative models\na. High-level overview of deep image generative models (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_SEP_Applications_and_Societal_Impact.txt", ".g., as of 2023, DALL-E, Midjourney,\nStable Diffusion, etc.), their uses, and their shortcomings/pitfalls.\nb. High-level overview of large language models (e.g., as of 2023, ChatGPT, Bard, etc.), their\nuses, and their shortcomings/pitfalls.\n3. Overview of societal impact of AI\n76\na. Ethics (See also: SEP-Context)\nb. Fairness (See also: SEP-Privacy, SEP-DEIA)\nc. Trust/explainability (See also: SEP-Context)\nd. Privacy and usage of training data (See also: SEP-Privacy)\ne"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_SEP_Applications_and_Societal_Impact.txt", ". Human autonomy and oversight/regulations/legal requirements (See also: SEP-Context)\nf. Sustainability (See also: SEP-Sustainability)\nKA Core:\n4. One or more additional applications of AI to a broad set of problems and diverse fields, such as\nmedicine, health, sustainability, social media, economics, education, robotics, etc. (choose a\ndifferent area from that chosen for the CS Core).\na. Formulating and evaluating a specific application as an AI problem\ni"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_SEP_Applications_and_Societal_Impact.txt", ". How to deal with underspecified or ill-posed problems\nb. Data availability/scarcity and cleanliness\ni. Basic data cleaning and preprocessing\nii. Data set bias\nc. Algorithmic bias\nd. Evaluation bias\ne. Assessment of societal implications of the application\n5. Additional depth on deployed deep generative models\na. Introduction to how deep image generative models work, (e.g., as of 2023, DALL-E, Midjourney,\nStable Diffusion) including discussion of attention\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_SEP_Applications_and_Societal_Impact.txt", ". Introduction to how large language models work, (e.g., as of 2023, ChatGPT, Bard) including\ndiscussion of attention\nc. Idea of foundational models, how to use them, and the benefits/issues with training them from\nbig data\n6. Analysis and discussion of the societal impact of AI\na. Ethics (See also: SEP-Context)\nb. Fairness (See also: SEP-Privacy, SEP-DEIA)\nc. Trust/explainability (See also: SEP-Context)\nd. Privacy and usage of training data (See also: SEP-Privacy)\ne"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_SEP_Applications_and_Societal_Impact.txt", ". Human autonomy and oversight/regulations/legal requirements (See also: SEP-Context)\nf. Sustainability (See also: SEP-Sustainability)\nIllustrative Learning Outcomes:\n1. Given a real-world application domain and problem, formulate an AI solution to it, identifying proper\ndata/input, preprocessing, representations, AI techniques, and evaluation metrics/methodology.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_SEP_Applications_and_Societal_Impact.txt", ".\n2. Analyze the societal impact of one or more specific real-world AI applications, identifying issues\nregarding ethics, fairness, bias, trust, and explainability.\n3. Describe some of the failure modes of current deep generative models for language or images, and\nhow this could affect their use in an application."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_Search_Search.txt", "AI-Search: Search\nPages: 68-70\nHOURS\n\tCS Core = 5\n\tKA Core = 6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_Search_Search.txt", "AI-Search: Search\nCS Core:\n1. State space representation of a problem\na. Specifying states, goals, and operators\nb. Factoring states into representations (hypothesis spaces)\nc. Problem solving by graph search\ni. e.g., Graphs as a space, and tree traversals as exploration of that space\nii. Dynamic construction of the graph (not given upfront)\n2. Uninformed graph search for problem solving (See also: AL-Foundational)\na. Breadth-first search\nb. Depth-first search\ni. With iterative deepening\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_Search_Search.txt", ". Depth-first search\ni. With iterative deepening\nc. Uniform cost search\n3. Heuristic graph search for problem solving (See also: AL-Strategies)\na. Heuristic construction and admissibility\nb. Hill-climbing\nc. Local minima and the search landscape\ni. Local vs global solutions\nd. Greedy best-first search\ne. A* search\n69\n4. Space and time complexities of graph search algorithms\nKA Core:\n5. Bidirectional search\n6. Beam search\n7. Two-player adversarial games\na. Minimax search\nb. Alpha-beta pruning\ni. Ply cutoff\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_Search_Search.txt", ". Alpha-beta pruning\ni. Ply cutoff\n8. Implementation of A* search\n9. Constraint satisfaction\nNon-core:\n10. Understanding the search space\na. Constructing search trees\nb. Dynamic search spaces\nc. Combinatorial explosion of search space\nd. Search space topology (e.g., ridges, saddle points, local minima)\n11. Local search\n12. Tabu search\n13. Variations on A* (IDA*, SMA*, RBFS)\n14. Two-player adversarial games\na. The horizon effect\nb. Opening playbooks/endgame solutions\nc. What it means to \u201csolve\u201d a game (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_Search_Search.txt", ". What it means to \u201csolve\u201d a game (e.g., checkers)\n15. Implementation of minimax search, beam search\n16. Expectimax search (MDP-solving) and chance nodes\n17. Stochastic search\na. Simulated annealing\nb. Genetic algorithms\nc. Monte-Carlo tree search\nIllustrative Learning Outcomes:\n1. Design the state space representation for a puzzle (e.g., N-queens or 3-jug problem)\n2. Select and implement an appropriate uninformed search algorithm for a problem (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_Search_Search.txt", ".g., tic-tac-toe),\nand characterize its time and space complexities.\n3. Select and implement an appropriate informed search algorithm for a problem after designing a\nhelpful heuristic function (e.g., a robot navigating a 2D gridworld).\n4. Evaluate whether a heuristic for a given problem is admissible/can guarantee an optimal solution.\n5. Apply minimax search in a two-player adversarial game (e.g., connect four), using heuristic\nevaluation at a particular depth to compute the scores to back up. [KA Core]\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_Search_Search.txt", ". [KA Core]\n6. Design and implement a genetic algorithm solution to a problem.\n7. Design and implement a simulated annealing schedule to avoid local minima in a problem.\n70\n8. Design and implement A*/beam search to solve a problem, and compare it against other search\nalgorithms in terms of the solution cost, number of nodes expanded, etc.\n9. Apply minimax search with alpha-beta pruning to prune search space in a two-player adversarial\ngame (e.g., connect four).\n10"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI_Search_Search.txt", ".g., connect four).\n10. Compare and contrast genetic algorithms with classic search techniques, explaining when it is most\nappropriate to use a genetic algorithm to learn a model versus other forms of optimization (e.g.,\ngradient descent).\n11. Compare and contrast various heuristic searches vis-a-vis applicability to a given problem.\n12. Model a logic or Sudoku puzzle as a constraint satisfaction problem, solve it with backtrack search,\nand determine how much arc consistency can reduce the search space."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Planning_Planning.txt", "Pages:78-78\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Planning_Planning.txt", "AI-Planning: Planning\nNon-core:\n1. Review of propositional and first-order logic\n2. Planning operators and state representations\n3. Total order planning\n4. Partial-order planning\n5. Plan graphs and GraphPlan\n6. Hierarchical planning\n7. Planning languages and representations\na. PDDL\n8. Multi-agent planning\n9. MDP-based planning\n10. Interconnecting planning, execution, and dynamic replanning\na. Conditional planning\nb. Continuous planning\nc. Probabilistic planning\nIllustrative Learning Outcomes:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Planning_Planning.txt", ". Construct the state representation, goal, and operators for a given planning problem.\n2. Encode a planning problem in PDDL and use a planner to solve it.\n3. Given a set of operators, initial state, and goal state, draw the partial-order planning graph and\ninclude ordering constraints to resolve all conflicts.\n4. Construct the complete planning graph for GraphPlan to solve a given problem."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", "Pages:71-75\n\nHOURS\n\tCS Core = 4\n\tKA Core = 6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", "AI-ML: Machine Learning\nCS Core:\n1. Definition and examples of a broad variety of machine learning tasks\na. Supervised learning\ni. Classification\nii. Regression\nb. Reinforcement learning\nc. Unsupervised learning\ni. Clustering\n2. Fundamental ideas:\na. No free lunch theorem: no one learner can solve all problems; representational design decisions\nhave consequences.\nb. Sources of error and undecidability in machine learning\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". A simple statistical-based supervised learning such as linear regression or decision trees\na. Focus on how they work without going into mathematical or optimization details; enough to\nunderstand and use existing implementations correctly\n4. The overfitting problem/controlling solution complexity (regularization, pruning \u2013 intuition only)\na. The bias (underfitting) \u2013 variance (overfitting) tradeoff\n5. Working with Data\na. Data preprocessing\ni. Importance and pitfalls of preprocessing choices\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". Handling missing values (imputing, flag-as-missing)\ni. Implications of imputing vs flag-as-missing\nc. Encoding categorical variables, encoding real-valued data\nd. Normalization/standardization\ne. Emphasis on real data, not textbook examples\n6. Representations\na. Hypothesis spaces and complexity\nb. Simple basis feature expansion, such as squaring univariate features\nc. Learned feature representations\n7. Machine learning evaluation\na. Separation of train, validation, and test sets\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". Separation of train, validation, and test sets\nb. Performance metrics for classifiers\nc. Estimation of test performance on held-out data\nd. Tuning the parameters of a machine learning model with a validation set\ne. Importance of understanding what a model is doing, where its pitfalls/shortcomings are, and the\nimplications of its decisions\n8. Basic neural networks\na. Fundamentals of understanding how neural networks work and their training process, without\ndetails of the calculations\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". Basic introduction to generative neural networks (e.g., large language models)\n9. Ethics for Machine Learning (See also: SEP-Context)\na. Focus on real data, real scenarios, and case studies\nb. Dataset/algorithmic/evaluation bias and unintended consequences\n72\nKA Core:\n10. Formulation of simple machine learning as an optimization problem, such as least squares linear\nregression or logistic regression\na. Objective function\nb. Gradient descent\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". Objective function\nb. Gradient descent\nc. Regularization to avoid overfitting (mathematical formulation)\n11. Ensembles of models\na. Simple weighted majority combination\n12. Deep learning\na. Deep feed-forward networks (intuition only, no mathematics)\nb. Convolutional neural networks (intuition only, no mathematics)\nc. Visualization of learned feature representations from deep nets\nd. Other architectures (generative NN, recurrent NN, transformers, etc.)\n13. Performance evaluation\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ".)\n13. Performance evaluation\na. Other metrics for classification (e.g., error, precision, recall)\nb. Performance metrics for regressors\nc. Confusion matrix\nd. Cross-validation\ni. Parameter tuning (grid/random search, via cross-validation)\n14. Overview of reinforcement learning methods\n15. Two or more applications of machine learning algorithms\na. E.g., medicine and health, economics, vision, natural language, robotics, game play\n16. Ethics for Machine Learning\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". Ethics for Machine Learning\na. Continued focus on real data, real scenarios, and case studies (See also: SEP-Context)\nb. Privacy (See also: SEP-Privacy)\nc. Fairness (See also: SEP-Privacy)\nd. Intellectual property\ne. Explainability\nNon-core:\n17. General statistical-based learning, parameter estimation (maximum likelihood)\n18. Supervised learning\na. Decision trees\nb. Nearest-neighbor classification and regression\nc. Learning simple neural networks / multi-layer perceptrons\nd. Linear regression\ne"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". Linear regression\ne. Logistic regression\nf. Support vector machines (SVMs) and kernels\ng. Gaussian Processes\n19. Overfitting\na. The curse of dimensionality\nb. Regularization (mathematical computations, L2 and L1 regularization)\n20. Experimental design\n73\na. Data preparation (e.g., standardization, representation, one-hot encoding)\nb. Hypothesis space\nc. Biases (e.g., algorithmic, search)\nd. Partitioning data: stratification, training set, validation set, test set\ne"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". Parameter tuning (grid/random search, via cross-validation)\nf. Performance evaluation\ni. Cross-validation\nii. Metric: error, precision, recall, confusion matrix\niii. Receiver operating characteristic (ROC) curve and area under ROC curve\n21. Bayesian learning (Cross-Reference AI/Reasoning Under Uncertainty)\na. Naive Bayes and its relationship to linear models\nb. Bayesian networks\nc. Prior/posterior\nd. Generative models\n22. Deep learning\na. Deep feed-forward networks\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". Deep learning\na. Deep feed-forward networks\nb. Neural tangent kernel and understanding neural network training\nc. Convolutional neural networks\nd. Autoencoders\ne. Recurrent networks\nf. Representations and knowledge transfer\ng. Adversarial training and generative adversarial networks\nh. Attention mechanisms\n23. Representations\na. Manually crafted representations\nb. Basis expansion\nc. Learned representations (e.g., deep neural networks)\n24. Unsupervised learning and clustering\na. K-means\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". K-means\nb. Gaussian mixture models\nc. Expectation maximization (EM)\nd. Self-organizing maps\n25. Graph analysis (e.g., PageRank)\n26. Semi-supervised learning\n27. Graphical models (See also: AI-Probability)\n28. Ensembles\na. Weighted majority\nb. Boosting/bagging\nc. Random forest\nd. Gated ensemble\n29. Learning theory\na. General overview of learning theory / why learning works\nb. VC dimension\nc. Generalization bounds\n74\n30. Reinforcement learning\na. Exploration vs exploitation tradeoff\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". Exploration vs exploitation tradeoff\nb. Markov decision processes\nc. Value and policy iteration\nd. Policy gradient methods\ne. Deep reinforcement learning\nf. Learning from demonstration and inverse RL\n31. Explainable / interpretable machine learning\na. Understanding feature importance (e.g., LIME, Shapley values)\nb. Interpretable models and representations\n32. Recommender systems\n33. Hardware for machine learning\na. GPUs / TPUs\n34. Application of machine learning algorithms to:\na. Medicine and health\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". Medicine and health\nb. Economics\nc. Education\nd. Vision\ne. Natural language\nf. Robotics\ng. Game play\nh. Data mining (Cross-reference DM/Data Analytics)\n35. Ethics for Machine Learning\na. Continued focus on real data, real scenarios, and case studies (See also: SEP-Context)\nb. In depth exploration of dataset/algorithmic/evaluation bias, data privacy, and fairness (See also:\nSEP-Privacy, SEP-Context)\nc. Trust / explainability\nIllustrative Learning Outcomes:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ". Describe the differences among the three main styles of learning (supervised, reinforcement, and\nunsupervised) and determine which is appropriate to a particular problem domain.\n2. Differentiate the terms of AI, machine learning, and deep learning.\n3. Frame an application as a classification problem, including the available input features and output\nto be predicted (e.g., identifying alphabetic characters from pixel grid input).\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ".\n4. Apply two or more simple statistical learning algorithms to a classification task and measure the\nclassifiers\u2019 accuracy.\n5. Identify overfitting in the context of a problem and learning curves and describe solutions to\noverfitting.\n6. Explain how machine learning works as an optimization/search process.\n7. Implement a statistical learning algorithm and the corresponding optimization process to train the\nclassifier and obtain a prediction on new data.\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ".\n8. Describe the neural network training process and resulting learned representations.\n75\n9. Explain proper ML evaluation procedures, including the differences between training and testing\nperformance, and what can go wrong with the evaluation process leading to inaccurate reporting of\nML performance.\n10. Compare two machine learning algorithms on a dataset, implementing the data preprocessing and\nevaluation methodology (e.g., metrics and handling of train/test splits) from scratch.\n11"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ".\n11. Visualize the training progress of a neural network through learning curves in a well-established\ntoolkit (e.g., TensorBoard) and visualize the learned features of the network.\n12. Compare and contrast several learning techniques (e.g., decision trees, logistic regression, naive\nBayes, neural networks, and belief networks), providing examples of when each strategy is\nsuperior.\n13. Evaluate the performance of a simple learning system on a real-world dataset.\n14"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ".\n14. Characterize the state of the art in learning theory, including its achievements and shortcomings.\n15. Explain the problem of overfitting, along with techniques for detecting and managing the problem.\n16. Explain the triple tradeoff among the size of a hypothesis space, the size of the training set, and\nperformance accuracy.\n17"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-ML_Machine_Learning.txt", ".\n17. Given a real-world application of machine learning, describe ethical issues regarding the choices of\ndata, preprocessing steps, algorithm selection, and visualization/presentation of results"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Vision_Perception_and_Computer_Vision.txt", "Pages:82-83\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Vision_Perception_and_Computer_Vision.txt", "AI-Vision: Perception and Computer Vision\nNon-core:\n1. Computer vision\na. Image acquisition, representation, processing, and properties\nb. Shape representation, object recognition, and segmentation\nc. Motion analysis\nd. Generative models\n2. Audio and speech recognition\n3. Touch and proprioception\n4. Other modalities (e.g., olfaction)\n5. Modularity in recognition\n6. Approaches to pattern recognition (See also: AI-ML)\na. Classification algorithms and measures of classification quality\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Vision_Perception_and_Computer_Vision.txt", ". Statistical techniques\nc. Deep learning techniques\nIllustrative Learning Outcomes:\n1. Summarize the importance of image and object recognition in AI and indicate several significant\napplications of this technology.\n2. List at least three image-segmentation approaches, such as thresholding, edge-based and region-\nbased algorithms, along with their defining characteristics, strengths, and weaknesses.\n3. Implement 2d object recognition based on contour-based and/or region-based shape\nrepresentations.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Vision_Perception_and_Computer_Vision.txt", ".\n4. Distinguish the goals of sound-recognition, speech-recognition, and speaker-recognition and\nidentify how the raw audio signal will be handled differently in each of these cases.\n5. Provide at least two examples of a transformation of a data source from one sensory domain to\nanother, e.g., tactile data interpreted as single-band 2d images.\n6. Implement a feature-extraction algorithm on real data, e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Vision_Perception_and_Computer_Vision.txt", ".g., an edge or corner detector for images\nor vectors of Fourier coefficients describing a short slice of audio signal.\n7. Implement an algorithm combining features into higher-level percepts, e.g., a contour or polygon\nfrom visual primitives or phoneme hypotheses from an audio signal.\n8. Implement a classification algorithm that segments input percepts into output categories and\nquantitatively evaluates the resulting classification.\n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Vision_Perception_and_Computer_Vision.txt", ".\n9. Evaluate the performance of the underlying feature-extraction, relative to at least one alternative\npossible approach (whether implemented or not) in its contribution to the classification task (8),\nabove.\n83\n10. Describe at least three classification approaches, their prerequisites for applicability, their strengths,\nand their shortcomings.\n11. Implement and evaluate a deep learning solution to problems in computer vision, such as object or\nscene recognition."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Robotics_Robotics.txt", "Pages:80-82\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Robotics_Robotics.txt", "AI-Robotics: Robotics\n(See also: SPD-Robot)\nNon-core:\n1. Overview: problems and progress\na. State-of-the-art robot systems, including their sensors and an overview of their sensor\nprocessing\n81\nb. Robot control architectures, e.g., deliberative vs reactive control and Braitenberg vehicles\nc. World modeling and world models\nd. Inherent uncertainty in sensing and in control\n2. Sensors and effectors\na. Sensors: e.g., LIDAR, sonar, vision, depth, stereoscopic, event cameras, microphones, haptics,\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Robotics_Robotics.txt", ". Effectors: e.g., wheels, arms, grippers\n3. Coordinate frames, translation, and rotation (2D and 3D)\n4. Configuration space and environmental maps\n5. Interpreting uncertain sensor data\n6. Localization and mapping\n7. Navigation and control\n8. Forward and inverse kinematics\n9. Motion path planning and trajectory optimization\n10. Manipulation and grasping\n11. Joint control and dynamics\n12. Vision-based control\n13. Multiple-robot coordination and collaboration\n14"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Robotics_Robotics.txt", ". Multiple-robot coordination and collaboration\n14. Human-robot interaction (See also: HCI-User, HCI-Accessibility)\na. Shared workspaces\nb. Human-robot teaming and physical HRI\nc. Social assistive robots\nd. Motion/task/goal prediction\ne. Collaboration and communication (explicit vs implicit, verbal or symbolic vs non-verbal or visual)\nf. Trust\n15. Applications and Societal, Economic, and Ethical Issues\na. Societal, economic, right-to-work implications\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Robotics_Robotics.txt", ". Societal, economic, right-to-work implications\nb. Ethical and privacy implications of robotic applications\nc. Liability in autonomous robotics\nd. Autonomous weapons and ethics\ne. Human oversight and control\nIllustrative Learning Outcomes:\n(Note: Due to the expense of robot hardware, all of these could be done in simulation or\nwith low-cost educational robotic platforms.)\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Robotics_Robotics.txt", ".)\n1. List capabilities and limitations of today's state-of-the-art robot systems, including their sensors and\nthe crucial sensor processing that informs those systems.\n2. Integrate sensors, actuators, and software into a robot designed to undertake a specific task.\n3. Program a robot to accomplish simple tasks using deliberative, reactive, and/or hybrid control\narchitectures.\n4. Implement fundamental motion planning algorithms within a robot configuration space.\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Robotics_Robotics.txt", ".\n5. Characterize the uncertainties associated with common robot sensors and actuators; articulate\nstrategies for mitigating these uncertainties.\n6. List the differences among robots' representations of their external environment, including their\nstrengths and shortcomings.\n82\n7. Compare and contrast at least three strategies for robot navigation within known and/or unknown\nenvironments, including their strengths and shortcomings.\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Artificial_Intelligence_AI/AI-Robotics_Robotics.txt", ".\n8. Describe at least one approach for coordinating the actions and sensing of several robots to\naccomplish a single task.\n9. Compare and contrast a multi-robot coordination and a human-robot collaboration approach and\nattribute their differences to differences between the problem settings.\n10. Analyze the societal, economic, and ethical issues of a real-world robotics application."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt", "Pages:93-95\n\nHOURS\n\tCS Core = 9\n\tKA Core = 23"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt", "AL-Models: Computational Models and Formal Languages\nCS Core:\n1. Formal automata\na. Finite State\nb. Pushdown\nc. Linear Bounded\nd. Turing Machine\n2. Formal languages, grammars and Chomsky Hierarchy\n(See also: FPL-Translation, FPL-Syntax)\na. Regular (Type-3)\ni. Regular Expressions\nb. Context-Free (Type-2)\nc. Context-Sensitive (Type-1)\nd. Recursively Enumerable (Type-0)\n3. Relations among formal automata, languages, and grammars\n4. Decidability, (un)computability, and halting\n5. The Church-Turing thesis\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt", ". The Church-Turing thesis\n6. Algorithmic correctness\na. Invariants (e.g., in iteration, recursion, tree search)\nKA Core:\n7. Deterministic and nondeterministic automata\n8. Pumping Lemma proofs\na. Proof of Finite State/Regular-Language limitation\nb. Pushdown Automata/Context-Free-Language limitation\n9. Decidability\na. Arithmetization and diagonalization\n10. Reducibility and reductions\n11. Time complexity based on Turing Machine\n12. Space complexity (e.g., Pspace, Savitch\u2019s Theorem)\n13"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt", ".g., Pspace, Savitch\u2019s Theorem)\n13. Equivalent models of algorithmic computation\na. Turing Machines and Variations (e.g., multi-tape, non-deterministic)\nb. Lambda Calculus (See also: FPL-Functional)\nc. Mu-Recursive Functions\nNon-core:\n14. Quantum computation (See also: AR-Quantum)\na. Postulates of quantum mechanics\ni. State space\n94\nii. State evolution\niii. State composition\niv. State measurement\nb. Column vector representations of qubits\nc. Matrix representations of quantum operations\nd"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt", ". Matrix representations of quantum operations\nd. Simple quantum gates (e.g., XNOT, CNOT)\nIllustrative Learning Outcomes:\nCS Core:\n1. For each formal automaton in this unit:\na. Explain its definition comparing its characteristics with this unit\u2019s other automata,\nb. Using an example, explain step-by-step how the automaton operates on input including whether\nit accepts the associated input,\nc. Explain an example of inputs that can and cannot be accepted by the automaton.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt", ".\n2. Given a problem, develop an appropriate automaton that addresses the problem.\n3. Develop a regular expression for a given regular language expressed in natural language.\n4. Explain the difference between regular expressions (Type-3 acceptors) and the regular expressions\n(Type-2 acceptors) used in programming languages.\n5. For each formal model in this unit:\na. Explain its definition comparing its characteristics with the others in this unit,\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt", ". Explain example inputs that are and cannot be accepted by the language/grammar.\n6. Explain a universal Turing Machine and its operation.\n7. Present to an audience of co-workers and managers the impossibility of providing them a program\nthat checks all other programs, including some seemingly simple ones, for infinite loops including\nan explanation of the Halting problem, why it has no algorithmic solution, and its significance for\nreal-world algorithmic computation.\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt", ".\n8. Explain examples of classic uncomputable problems.\n9. Explain the Church-Turing Thesis and its significance for algorithmic computation.\n10. Explain how (loop) invariants can be used to prove the correctness of an algorithm.\nIllustrative Learning Outcomes:\nKA Core:\n11. For each formal automaton in this unit explain (compare/contrast) its deterministic and\nnondeterministic capabilities.\n12. Apply pumping lemmas, or alternative means, to prove the limitations of Finite State and Pushdown\nautomata.\n13"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt", ".\n13. Apply arithmetization and diagonalization to prove the Halting Problem for Turing Machines is\nUndecidability.\n14. Given a known undecidable language, apply a mapping reduction or computational history to prove\nthat another language is undecidable.\n15. Convert among equivalently powerful notations for a language, including among DFAs, NFAs, and\nregular expressions, and between PDAs and CFGs.\n16. Explain Rice\u2019s theorem and its significance.\n95\n17"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt", ".\n95\n17. Explain an example proof of a problem that is uncomputable by reducing a classic known\nuncomputable problem to it.\n18. Explain the Primitive and General Recursive functions (zero, successor, selection, primitive\nrecursion, composition, and Mu), their significance, and Turing Machine implementations.\n19. Explain how computation is performed in Lambda Calculus (e.g., Alpha conversion and Beta\nreduction)\nNon-core:\n20. For a quantum system give examples that explain the following postulates.\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Models_Computational_Models_and_Formal_Languages.txt", ".\na. State Space \u2013 system state represented as a unit vector in Hilbert space,\nb. State Evolution \u2013 the use of unitary operators to evolve system state,\nc. State Composition \u2013 the use of tensor product to compose systems states,\nd. State Measurement \u2013 the probabilistic output of measuring a system state.\n21. Explain the operation of a quantum XNOT or CNOT gate on a quantum bit represented as a matrix\nand column vector, respectively"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-SEP_Society_Ethics_and_the_Profession.txt", "Pages:95-95\n\nHOURS\n\tCS Core = ?\n\tKA Core = ?"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-SEP_Society_Ethics_and_the_Profession.txt", "AL-SEP: Society, Ethics, and the Profession\nCS Core: (See also: SEP-Context, SEP-Sustainability)\n1. Social, ethical, and secure algorithms\n2. Algorithmic fairness\n3. Anonymity (e.g., Differential Privacy)\n4. Accountability/Transparency\n5. Responsible algorithms\n6. Economic and other impacts of inefficient algorithms\n7. Sustainability\nKA Core:\n8. Context aware computing\nIllustrative Learning Outcomes:\nCS Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-SEP_Society_Ethics_and_the_Profession.txt", ". Develop algorithmic solutions to real-world societal problems, such as routing an ambulance to a\nhospital.\n2. Explain the impact that an algorithm may have on the environment and society when used to solve\na real-world problem while considering its sustainability and that it can affect different societal\ngroups in different ways.\n3. Prepare a presentation that justifies the selection of appropriate data structures and/or algorithms to\nsolve a given real-world problem.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-SEP_Society_Ethics_and_the_Profession.txt", ".\n4. Explain an example that articulates how differential privacy protects knowledge of an individual\u2019s\ndata.\n5. Explain the environmental impacts of design choices that relate to algorithm design.\n6. Explain the tradeoffs involved in proof-of-work and proof-of-stake algorithms."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Strategies_Algorithmic_Strategies.txt", "Pages:90-91\n\nHOURS\n\tCS Core = 6\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Strategies_Algorithmic_Strategies.txt", "AL-Strategies: Algorithmic Strategies\nCS Core:\n1. Paradigms\na. Brute-Force (e.g., linear search, selection sort, traveling salesperson, knapsack)\nb. Decrease-and-Conquer\ni. By a Constant (e.g., insertion sort, topological sort),\nii. By a Constant Factor (e.g., binary search),\niii. By a Variable Size (e.g., Euclid\u2019s)\nc. Divide-and-Conquer (e.g., binary search, quicksort, mergesort, Strassen\u2019s)\nd. Greedy (e.g., Dijkstra\u2019s, Kruskal\u2019s, Knapsack)\ne. Transform-and-Conquer\ni. Instance simplification (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Strategies_Algorithmic_Strategies.txt", ". Instance simplification (e.g., find duplicates via list presort)\nii. Representation change (e.g., heapsort)\niii. Problem reduction (e.g., least-common-multiple, linear programming)\niv. Dynamic programming (e.g., Floyd\u2019s, Warshall, Bellman-Ford)\nf. Space vs time tradeoffs (e.g., hashing)\n2. Handling exponential growth (e.g., heuristic A*, branch-and-bound, backtracking)\n3. Iteration vs recursion (e.g., factorial, tree search)\nKA Core:\n4. Paradigms\na. Approximation algorithms\nb. Iterative improvement (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Strategies_Algorithmic_Strategies.txt", ". Iterative improvement (e.g., Ford-Fulkerson, simplex)\nc. Randomized/Stochastic algorithms (e.g., max-cut, balls and bins)\nNon-core:\n5. Quantum computing\n91\nIllustrative Learning Outcomes:\nCS Core:\n1. For each of the paradigms in this unit,\na. Explain its definitional characteristics,\nb. Explain an example that demonstrates the paradigm including how this example satisfies the\nparadigm\u2019s characteristics.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Strategies_Algorithmic_Strategies.txt", ".\n2. For each of the algorithms in the AL-Foundational unit, explain the paradigm used by the algorithm\nand how it exemplifies this paradigm.\n3. Given an algorithm, explain the paradigm used by the algorithm and how it exemplifies this\nparadigm.\n4. Give a real-world problem, evaluate appropriate algorithmic paradigms and algorithms from these\nparadigms that address the problem including evaluating the tradeoffs among the paradigms and\nalgorithms selected.\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Strategies_Algorithmic_Strategies.txt", ".\n5. Give examples of iterative and recursive algorithms that solve the same problem, explain the\nbenefits and disadvantages of each approach.\n6. Evaluate whether a greedy approach leads to an optimal solution.\n7. Explain various approaches for addressing computational problems whose algorithmic solutions are\nexponential."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt", "Pages:91-93\n\nHOURS\n\tCS Core = 6\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt", "AL-Complexity: Complexity\nCS Core:\n1. Complexity Analysis Framework\na. Best, average, and worst-case performance of an algorithm\nb. Empirical and relative (Order of Growth) measurements\nc. Input size and primitive operations\nd. Time and space efficiency\n2. Asymptotic complexity analysis (average and worst-case bounds)\na. Big-O, Big-Omega, and Big-Theta formal notations\nb. Foundational Complexity Classes and Representative Examples/Problems\ni. O(1) Constant (e.g., array access)\nii. O(log2 n) Logarithmic (e"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt", ".g., array access)\nii. O(log2 n) Logarithmic (e.g., binary search)\niii. O(n) Linear (e.g., linear search)\niv. O(n log2 n) Log Linear (e.g., mergesort)\nv. O(n2) Quadratic (e.g., selection sort)\nvi. O(nc) Polynomial (e.g., O(n3) Gaussian elimination)\nvii. O(2n) Exponential (e.g., Knapsack, Satisfiability (SAT),\nTraveling Sales-Person (TSP), all subsets)\nviii. O(n!) Factorial (e.g., Hamiltonian circuit, all permutations)\n3. Empirical measurements of performance\n4. Tractability and intractability\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt", ". Tractability and intractability\na. P, NP, and NP-Complete Complexity Classes\nb. NP-Complete Problems (e.g., SAT, Knapsack, TSP)\nc. Reductions\n5. Time and space tradeoffs in algorithms\n92\nKA Core:\n6. Little-o, Little-Omega, and Little Theta notations\n7. Formal recursive analysis\n8. Amortized analysis\n9. Turing Machine-based models of complexity\na. Time complexity\ni. P, NP, NP-C, and EXP classes\nii. Cook-Levin theorem\nb. Space Complexity\ni. NSpace and PSpace\nii"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt", ". Space Complexity\ni. NSpace and PSpace\nii. Savitch\u2019s theorem\nIllustrative Learning Outcomes:\nCS Core:\n1. Prepare a presentation that explains to first year students the basic concepts of algorithmic\ncomplexity including best, average, and worst-case algorithm behavior, Big- O, Omega, and Theta\nnotations, complexity classes, time and space tradeoffs, empirical measurement, and impact on\npractical problems.\n2. Using examples, explain each of the foundational complexity classes in this unit.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt", ".\n3. For each foundational complexity class in this unit, explain an algorithm that demonstrates the\nassociated runtime complexity.\n4. For each algorithm in the AL-Foundational unit, explain its runtime complexity class and why it\nbelongs to this class.\n5. Informally evaluate the foundational complexity class of simple algorithms.\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt", ".\n6. Given a problem to program for which there may be several algorithmic approaches, evaluate them\nand determine which are feasible, and select one that is optimal in implementation and run-time\nbehavior.\n7. Develop empirical studies to determine and validate hypotheses about the runtime complexity of\nvarious algorithms by running algorithms on input of various sizes and comparing actual\nperformance to the theoretical analysis.\n8. Explain examples that illustrate time-space tradeoffs of algorithms.\n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt", ".\n9. Explain how tree balance affects the efficiency of binary search tree operations.\n10. Explain to a non-technical audience the significance of tractable versus intractable algorithms using\nan intuitive explanation of Big-O complexity.\n11. Explain the significance of NP-Completeness.\n12. Explain how NP-Hard is a lower bound and NP is an upper bound for NP-Completeness.\n13. Explain examples of NP-complete problems.\nKA Core:\n14"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt", ".\nKA Core:\n14. Use recurrence relations to evaluate the time complexity of recursively defined algorithms.\n15. Apply elementary recurrence relations using a form of the Master Theorem.\n16. Apply Big-O notation to give upper case bounds on time/space complexity of algorithms.\n17. Explain the Cook-Levin Theorem and the NP-Completeness of SAT.\n93\n18. Explain the classes P and NP.\n19. Prove that a problem is NP-Complete by reducing a classic known NP-C problem to it (e.g., 3SAT\nand Clique).\n20"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Complexity_Complexity.txt", ".g., 3SAT\nand Clique).\n20. Explain the P-space class and its relation to the EXP class."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt", "Pages:88-90\n\nHOURS\n\tCS Core = 11\n\tKA Core = 6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt", "AL-Foundational: Foundational Data Structures and Algorithms\nCS Core: (See also: SDF-Data-Structures, SDF-Algorithms)\n1. Abstract Data Type (ADT) and operations on an ADT (See also: FPL-Types)\na. Dictionary operations (insert, delete, find)\n2. Arrays\na. Numeric vs non-numeric, character strings\nb. Single (vector) vs multidimensional (matrix)\n3. Records/Structs/Tuples and Objects (See also: FPL-OOP)\n4. Linked lists (for historical reasons)\na. Single vs Double and Linear vs Circular\n5. Stacks\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt", ". Stacks\n6. Queues and deques\na. Heap-based priority queue\n7. Hash tables/maps\na. Collision resolution and complexity (e.g., probing, chaining, rehash)\n8. Graphs (e.g., [un]directed, [a]cyclic, [un]connected, and [un]weighted)\n(See also: MSF-Discrete)\na. Graph representation: adjacency list vs matrix\n9. Trees (See also: MSF-Discrete)\na. Binary, n-ary, and search trees\nb. Balanced (e.g., AVL, Red-Black, Heap)\n10. Sets (See also: MSF-Discrete)\n11. Search algorithms\na. O(n) complexity (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt", ". Search algorithms\na. O(n) complexity (e.g., linear/sequential array/list search)\nb. O(log2 n) complexity (e.g., binary search)\nc. O(logb n) complexity (e.g., uninformed depth/breadth-first tree search)\n12. Sorting algorithms (e.g., stable, unstable)\na. O(n2) complexity (e.g., insertion, selection),\nb. O(n log n) complexity (e.g., quicksort, merge, timsort)\n13. Graph algorithms\na. Shortest path (e.g., Dijkstra\u2019s, Floyd\u2019s)\nb. Minimal spanning tree (e.g., Prim\u2019s, Kruskal\u2019s)\nKA Core:\n14. Sorting algorithms\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt", ". Sorting algorithms\na. O(n log n) complexity heapsort\nb. Pseudo O(n) complexity (e.g., bucket, counting, radix)\n15. Graph algorithms\na. Transitive closure (e.g., Warshall\u2019s)\nb. Topological sort\n16. Matching\na. Efficient string matching (e.g., Boyer-Moore, Knuth-Morris-Pratt)\nb. Longest common subsequence matching\nc. Regular expression matching\nNon-core:\n17. Cryptography algorithms (e.g., SHA-256) (See also: SEC-Crypto)\n18. Parallel algorithms (See also: PDC-Algorithms, FPL-Parallel)\n19"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt", ". Consensus algorithms (e.g., Blockchain) (See also: SEC-Crypto)\na. Proof of work vs proof of stake (See also: SEP-Sustainability)\n20. Quantum computing algorithms (See also: AL-Models, AR-Quantum)\na. Oracle-based (e.g., Deutsch-Jozsa, Bernstein-Vazirani, Simon)\nb. Superpolynomial speed-up via QFT (e.g., Shor\u2019s)\nc. Polynomial speed-up via amplitude amplification (e.g., Grover\u2019s)\n21. Fast-Fourier Transform (FFT) algorithm\n22. Differential evolution algorithm\nIllustrative Learning Outcomes:\nCS Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt", ". For each ADT/Data-Structure in this unit\na. Explain its definition, properties, representation(s), and associated ADT operations.\nb. Explain step-by-step how the ADT operations associated with the data structure transform it.\n2. For each algorithm in this unit explain step-by-step how the algorithm operates.\n3. For each algorithmic approach (e.g., sorting) in this unit apply a prototypical example of the\napproach (e.g., merge sort).\n90\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt", ".g., merge sort).\n90\n4. Given requirements for a problem, develop multiple solutions using various data structures and\nalgorithms. Subsequently, evaluate the suitability, strengths, and weaknesses selecting an\napproach that best satisfies the requirements.\n5. Explain how collision avoidance and collision resolution is handled in hash tables.\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt", ".\n6. Explain factors beyond computational efficiency that influence the choice of algorithms, such as\nprogramming time, maintainability, and the use of application-specific patterns in the input data.\n7. Explain the heap property and the use of heaps as an implementation of a priority queue.\nKA Core:\n8. For each of the algorithms and algorithmic approaches in the KA Core topics:\na. Explain a prototypical example of the algorithm, and\nb. Explain step-by-step how the algorithm operates.\nNon-core:\n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Algorithmic_Foundations_AL/AL-Foundational_Foundational_Data_Structures_and_Algorithms.txt", ".\nNon-core:\n9. An appreciation of quantum computation and its application to certain problems."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt", "Pages: 136-137-138\n\nHOURS\n\tCS Core = 3\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt", "FPL-Types: Type Systems\nCS Core:\n1. A type as a set of values together with a set of operations\na. Primitive types (e.g., numbers, Booleans) (See also: SDF-Fundamentals)\nb. Compound types built from other types (e.g., records/structs, unions, arrays, lists, functions,\nreferences using set operations) (See also: SDF-Data-Structures)\n2. Association of types to variables, arguments, results, and fields\n3. Type safety as an aspect of program correctness (See also: FPL-Formalism)\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt", ". Type safety and errors caused by using values inconsistently given their intended types\n5. Goals and limitations of static and dynamic typing: detecting and eliminating errors as early as\npossible.\n6. Generic types (parametric polymorphism)\na. Definition and advantages of polymorphism: parametric, subtyping, overloading, and coercion\nb. Comparison of monomorphic and polymorphic types\nc. Comparison with ad-hoc polymorphism (overloading) and subtype polymorphism\nd. Generic parameters and typing\ne"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt", ". Generic parameters and typing\ne. Use of generic libraries such as collections\nf. Comparison with ad hoc polymorphism (overloading) and subtype polymorphism\ng. Prescriptive vs descriptive polymorphism\nh. Implementation models of polymorphic types\ni. Subtyping\nKA Core:\n7. Type equivalence: structural vs name equivalence\n8. Complementary benefits of static and dynamic typing:\na. Errors early vs errors late/avoided\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt", ". Errors early vs errors late/avoided\nb. Enforce invariants during code development and code maintenance vs postpone typing\ndecisions while prototyping and conveniently allow flexible coding patterns such as\nheterogeneous collections.\nc. Typing rules for function, product, and sum types\nd. Avoiding misuse of code vs allowing more code reuse\ne. Detect incomplete programs vs allow incomplete programs to run\nf. Relationship to static analysis\ng. Decidability\nNon-core:\n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt", ". Decidability\nNon-core:\n9. Compositional type constructors, such as product types (for aggregates), sum types (for unions),\nfunction types, quantified types, and recursive types\n10. Type checking\n11. Subtyping: (See also: FPL-OOP)\na. Subtype polymorphism; implicit upcasts in typed languages\nb. Notion of behavioral replacement: subtypes acting like supertype\nc. Relationship between subtyping and inheritance\n12. Type safety as preservation plus progress\n13. Type inference\n14. Static overloading\n15"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt", ". Type inference\n14. Static overloading\n15. Propositions as types (implication as a function, conjunction as a product, disjunction as a sum)\n(See also: FPL-Formalism)\n16. Dependent types (universal quantification as dependent function, existential quantification as\ndependent product). (See also: FPL-Formalism)\nIllustrative learning outcomes:\nCS Core:\n1. Describe, for both a primitive and a compound type, the values that have that type.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt", ".\n2. Describe, for a language with a static type system, the operations that are forbidden statically, such\nas passing the wrong type of value to a function or method.\n3. Describe examples of program errors detected by a type system.\n4. Identify program properties, for multiple programming languages, that are checked statically and\nprogram properties that are checked dynamically.\n5. Describe an example program that does not type-check in a particular language and yet would have\nno error if run.\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt", ".\n6. Use types and type-error messages to write and debug programs.\nKA Core:\n7. Explain how typing rules define the set of operations that are legal for a type.\n8. List the type rules governing the use of a particular compound type.\n9. Explain why undecidability requires type systems to conservatively approximate program behavior.\n10. Define and use program pieces (such as functions, classes, methods) that use generic types,\nincluding for collections.\n11"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt", ".\n11. Discuss the differences among generics, subtyping, and overloading.\n12. Explain multiple benefits and limitations of static typing in writing, maintaining, and debugging\nsoftware.\nNon-core:\n13. Define a type system precisely and compositionally.\n14. For various foundational type constructors, identify the values they describe and the invariants they\nenforce.\n15. Precisely describe the invariants preserved by a sound type system.\n16"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Types_Type_Systems.txt", ".\n16. Prove type safety for a simple language in terms of preservation and progress theorems.\n17. Implement a unification-based type-inference algorithm for a simple language.\n18. Explain how static overloading and associated resolution algorithms influence the dynamic behavior\nof programs."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt", "Pages: 147\n\nHOURS\n\tCS Core = SEP hours\n\tKA Core = SEP hours"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt", "FPL-SEP: Society, Ethics, and the Profession\nNon-core:\n1. Impact of English-centric programming languages\n2. Enhancing accessibility and inclusivity for people with disabilities \u2013 Supporting assistive\ntechnologies\n3. Human factors related to programming languages and usability\na. Impact of syntax on accessibility\nb. Supporting cultural differences (e.g., currency, decimals, dates)\nc. Neurodiversity\n4. Etymology of terms such as \u201cclass,\u201d \u201cmaster,\u201d and \u201cslave\u201d in programming languages\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-SEP_Society_Ethics_and_the_Profession.txt", ". Increasing accessibility by supporting multiple languages within applications (UTF)\nIllustrative learning outcomes:\nNon-core:\n1. Consciously design programming languages to be inclusive and non-offensive."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Run-Time_Run-time_Behavior_and_Systems.txt", "Pages: 143-144\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Run-Time_Run-time_Behavior_and_Systems.txt", "FPL-Run-Time: Run-time Behavior and Systems\nNon-core:\n1. Process models using stacks and heaps to allocate and deallocate activation records and\nrecovering environments using frame pointers and return addresses during a procedure call\nincluding parameter-passing examples\n2. Schematics of code lookup using hash tables for methods in implementations of object-oriented\nprograms\n3. Data layout for objects and activation records\n4. Object allocation in heap\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Run-Time_Run-time_Behavior_and_Systems.txt", ". Object allocation in heap\n5. Implementing virtual entities and virtual methods; virtual method tables and their application\n6. Run-time behavior of object-oriented programs\n7. Compare and contrast allocation of memory during information exchange using parameter-passing\nand non-local variables (using chain of static links).\n8. Dynamic memory management approaches and techniques: malloc/free, garbage collection (marksweep, copying, reference counting), regions (also known as arenas or zones)\n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Run-Time_Run-time_Behavior_and_Systems.txt", ". Just-in-time compilation and dynamic recompilation\n10. Interface to operating system (e.g., for program initialization)\n11. Interoperability between programming languages including parameter-passing mechanisms and\ndata representation (See also: AR-Representation)\na. Big endian, little endian\nb. Data layout of composite data types such as arrays\n12. Other common features of virtual machines, such as class loading, threads, and security checking\n13. Sandboxing\nIllustrative learning outcomes:\nNon-core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Run-Time_Run-time_Behavior_and_Systems.txt", ". Discuss benefits and limitations of automatic memory management.\n2. Explain the use of metadata in run-time representations of objects and activation records, such as\nclass pointers, array lengths, return addresses, and frame pointers.\n3. Compare and contrast static allocation vs stack-based allocation vs heap-based allocation of data\nelements.\n4. Explain why some data elements cannot be automatically deallocated at the end of a\nprocedure/method call (need for garbage collection).\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Run-Time_Run-time_Behavior_and_Systems.txt", ".\n5. Discuss advantages, disadvantages, and difficulties of just-in-time and dynamic recompilation.\n6. Discuss the use of sandboxing in mobile code.\n7. Identify the services provided by modern language run-time systems."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt", "Pages: 131-132-133\n\nHOURS\n\tCS Core = 4\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt", "FPL-Functional: Functional Programming\nCS Core:\n1. Lambda expressions and evaluation: (See also: AL-Models, FPL-Formalism)\na. Variable binding and scope rules. (See also: SDF-Fundamentals)\nb. Parameter-passing. (See also: SDF-Fundamentals)\nc. Nested lambda expressions and reduction order.\n2. Effect-free programming:\na. Function calls have no side effects, facilitating compositional reasoning.\nb. Immutable variables and data copying vs reduction.\nc. Use of recursion vs loops vs pipelining (map/reduce).\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt", ".\n3. Processing structured data (e.g., trees) via functions with cases for each data variant:\na. Functions defined over compound data in terms of functions applied to the constituent pieces.\nb. Persistent data structures.\n4. Using higher-order functions (taking, returning, and storing functions).\nKA Core:\n5. Metaprogramming and reflection.\n6. Function closures (functions using variables in the enclosing lexical environment).\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt", ".\na. Basic meaning and definition \u2013 creating closures at run-time by capturing the environment.\nb. Canonical idioms: call-backs, arguments to iterators, reusable code via function arguments.\nc. Using a closure to encapsulate data in its environment.\nd. Delayed versus eager evaluation.\nNon-core:\n7. Graph reduction machine and call-by-need.\n8. Implementing delayed evaluation.\n9. Integration with logic programming paradigm using concepts such as equational logic, narrowing,\nresiduation and semantic unification"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt", ". (See also: FPL-Logic)\n10. Integration with other programming paradigms such as imperative and object-oriented.\nIllustrative learning outcomes:\nCS Core:\n1. Develop basic algorithms that avoid assigning to mutable states or considering reference equality.\n2. Develop useful functions that take and return other functions.\n3. Compare and contrast how computational solutions to a problem differ in procedural, functional,\nand object-oriented approaches.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt", ".\n4. Compare and contrast mechanisms to define and protect data elements within procedural,\nfunctional, and object-oriented approaches.\nKA Core:\n5. Explain a simple example of lambda expression being implemented using a virtual machine, such\nas a SECD machine, showing storage and reclaim of the environment.\n6. Correctly interpret variables and lexical scope in a program using function closures.\n7. Use functional encapsulation mechanisms such as closures and modular interfaces.\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt", ".\n8. Compare and contrast stateful vs stateless execution.\n9. Define and use iterators and other operations on aggregates, including operations that take\nfunctions as arguments, in multiple programming languages, selecting the most natural idioms for\neach language. (See also: FPL-OOP)\nNon-core:\n10. Illustrate graph reduction using a \u03bb-expression using a shared subexpression.\n11. Illustrate the execution of a simple nested \u03bb-expression using an abstract machine, such as an ABC\nmachine.\n12"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Functional_Functional_Programming.txt", ".\n12. Illustrate narrowing, residuation, and semantic unification using simple illustrative examples.\n13. Illustrate the concurrency constructs using simple programming examples of known concepts such\nas a buffer being read and written concurrently or sequentially. (See also: FPL-OOP)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Aspect_Aspect-Oriented_Programming.txt", "Pages: 136\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0\n\nFPL-Aspect: Aspect-Oriented Programming\nNon-core:\n1. Aspects\n2. Join points\n3. Advice\na. Before\nb. After (as finally, returning or throwing)\nc. Around\n4. Point cuts\na. Designators\n5. Weaving \u2013 static and dynamic\n6. Alternatives including annotations and IDEs"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Analysis_Program_Analysis_and_Analyzers.txt", "Pages: 142\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Analysis_Program_Analysis_and_Analyzers.txt", "FPL-Analysis: Program Analysis and Analyzers\nNon-core:\n4. Relevant program representations, such as basic blocks, control-flow graphs, def-use chains, and\nstatic single assignment\n5. Undecidability and consequences for program analysis\n6. Flow-insensitive analysis, such as type-checking and scalable pointer and alias analysis\n7. Flow-sensitive analysis, such as forward and backward dataflow analyses\n8. Path-sensitive analysis, such as software model checking and software verification\n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Analysis_Program_Analysis_and_Analyzers.txt", ". Tools and frameworks for implementing analyzers\n10. Role of static analysis in program optimization and data dependency analysis during exploitation of\nconcurrency (See also: FPL-Code)\n11. Role of program analysis in (partial) verification and bug-finding (See also: FPL-Code)\n12. Parallelization:\na. Analysis for auto-parallelization\nb. Analysis for detecting concurrency bugs\nIllustrative learning outcomes:\nNon-core:\n1. Explain the difference between dataflow graph and control flow graph.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Analysis_Program_Analysis_and_Analyzers.txt", ".\n2. Explain why non-trivial sound program analyses must be approximate.\n3. Argue why an analysis is correct (sound and terminating).\n4. Explain why potential aliasing limits sound program analysis and how alias analysis can help.\n5. Use the results of a program analysis for program optimization and/or partial program correctness."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Translation_Language_Translation_and_Execution.txt", "Pages: 139-140\n\nHOURS\n\tCS Core = 2\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Translation_Language_Translation_and_Execution.txt", "FPL-Translation: Language Translation and Execution\nCS Core:\n1. Execution models for JIT (Just-In-Time), compiler, interpreter\n2. Use of intermediate code, e.g., bytecode\n3. Limitations and benefits of JIT, compiler, and interpreter\n4. Cross compilers/transpilers\n5. BNF and extended BNF representation of context-free grammar\n6. Parse tree using a simple sentence such as arithmetic expression or if-then-else statement\n7. Execution as native code or within a virtual machine\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Translation_Language_Translation_and_Execution.txt", ". Language translation pipeline: syntax analysis, parsing, optional type-checking, translation/code\ngeneration and optimization, linking, loading, execution\nKA Core:\n9. Run-time representation of core language constructs such as objects (method tables) and functions\nthat can be passed as parameters to and returned from functions (closures)\n10. Secure compiler development (See also: SEC-Foundations, SEC-Coding)\nIllustrative learning outcomes:\nCS Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Translation_Language_Translation_and_Execution.txt", ". Explain and understand the differences between compiled, JIT, and interpreted language\nimplementations, including the benefits and limitations of each.\n2. Differentiate syntax and parsing from semantics and evaluation.\n3. Use BNF and extended BNF to specify the syntax of simple constructs such as if-then-else, type\ndeclaration and iterative constructs for known languages such as C++ or Python.\n4. Illustrate the parse tree using a simple sentence/arithmetic expression.\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Translation_Language_Translation_and_Execution.txt", ".\n5. Illustrate translation of syntax diagrams to BNF/extended BNF for simple constructs such as if-thenelse, type declaration, iterative constructs, etc.\n6. Illustrate ambiguity in parsing using nested if-then-else/arithmetic expression and show resolution\nusing precedence order.\nKA-Core:\n7. Discuss the benefits and limitations of garbage collection, including the notion of reachability."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt", "Pages: 130-131\n\nHOURS\n\tCS Core = 4 + 1 (SDF)\n\tKA Core = 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt", "FPL-OOP: Object-Oriented Programming\nCS Core:\n1. Imperative programming as a subset of object-oriented programming.\n2. Object-oriented design:\na. Decomposition into objects carrying state and having behavior.\nb. Class-hierarchy design for modeling.\n3. Definition of classes: fields, methods, and constructors. (See also: SDF-Fundamentals)\n4. Subclasses, inheritance (including multiple inheritance), and method overriding.\n5. Dynamic dispatch: definition of method-call.\n6. Exception handling"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt", ".\n6. Exception handling. (See also: SDF-Fundamentals, PDC-Coordination, SE-Construction)\n7. Object-oriented idioms for encapsulation:\na. Privacy, data hiding, and visibility of class members.\nb. Interfaces revealing only method signatures.\nc. Abstract base classes, traits and mixins.\n8. Dynamic vs static properties.\n9. Composition vs inheritance.\n10. Subtyping:\na. Subtype polymorphism; implicit upcasts in typed languages.\nb. Notion of behavioral replacement: subtypes acting like supertype.\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt", ".\nc. Relationship between subtyping and inheritance.\nKA Core:\n11. Collection classes, iterators, and other common library components.\n12. Metaprogramming and reflection.\nIllustrative Learning Outcomes:\nCS Core:\n1. Enumerate the differences between imperative and object-oriented programming paradigms.\n2. Compose a class through design, implementation, and testing to meet behavioral requirements.\n3. Build a simple class hierarchy utilizing subclassing that allows code to be reused for distinct\nsubclasses.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt", ".\n4. Predict and validate control flow in a program using dynamic dispatch.\n5. Compare and contrast how computational solutions to a problem differ in procedural, functional,\nand object-oriented approaches.\n6. Compare and contrast mechanisms to define and protect data elements within procedural,\nfunctional, and object-oriented approaches.\n7. Compare and contrast the benefits and costs/impact of using inheritance (subclasses) and\ncomposition (specifically, how to base composition on higher order functions)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt", ".\n8. Explain the relationship between object-oriented inheritance (code-sharing and overriding) and\nsubtyping (the idea of a subtype being usable in a context that expects the supertype).\n9. Use object-oriented encapsulation mechanisms such as interfaces and private members.\n10. Define and use iterators and other operations on aggregates, including operations that take\nfunctions as arguments, in multiple programming languages, selecting the most natural idioms for\neach language"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-OOP_Object-Oriented_Programming.txt", ". (See also: FPL-Functional)\nKA Core:\n11. Use collection classes and iterators effectively to solve a problem."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Constructs_Advanced_Programming_Constructs.txt", "Pages: 144\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Constructs_Advanced_Programming_Constructs.txt", "FPL-Constructs: Advanced Programming Constructs\nNon-core:\n1. Encapsulation mechanisms\n2. Delayed evaluation and infinite streams\n3. Compare and contrast delayed evaluation vs eager evaluation\n4. Unification vs assertion vs expression evaluation\n5. Control abstractions: exception handling, continuations, monads.\n6. Object-oriented abstractions: multiple inheritance, mixins, traits, multimethods\n7. Metaprogramming: macros, generative programming, model-based development\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Constructs_Advanced_Programming_Constructs.txt", ". String manipulation via pattern-matching (regular expressions)\n9. Dynamic code evaluation (\"eval\")\n10. Language support for checking assertions, invariants, and pre/post-conditions\n11. Domain specific languages, such as database languages, data science languages, embedded\ncomputing languages, synchronous languages, hardware interface languages\n12. Massive parallel high performance computing models and languages\nIllustrative learning outcomes:\nNon-core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Constructs_Advanced_Programming_Constructs.txt", ". Use various advanced programming constructs and idioms correctly.\n2. Discuss how various advanced programming constructs aim to improve program structure, software\nquality, and programmer productivity.\n3. Discuss how various advanced programming constructs interact with the definition and\nimplementation of other language features."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt", "Pages: 146-147\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt", "FPL-Design: Design Principles of Programming Languages\nNon-core:\n1. Language design principles\na. Simplicity\nb. Security (See also: SEC-Coding)\nc. Fast translation\nd. Efficient object code\ne. Orthogonality\nf. Readability\ng. Completeness\nh. Implementation strategies\n2. Designing a language to fit a specific domain or problem\n3. Interoperability between programming languages\n4. Language portability\n5. Formal description of a programming language\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Design_Design_Principles_of_Programming_Languages.txt", ". Formal description of a programming language\n6. Green computing principles (See also: SEP-Sustainability)\nIllustrative Learning Outcomes:\nNon-core:\n1. Understand what constitutes good language design and apply that knowledge to evaluate a real\nprogramming language."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Semantics_Compiler_Semantic_Analysis.txt", "Pages: 141-142\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Semantics_Compiler_Semantic_Analysis.txt", "FPL-Semantics: Compiler Semantic Analysis\nNon-core:\n1. Abstract syntax trees; contrast with concrete syntax\n2. Defining, traversing, and modifying high-level program representations\n3. Scope and binding resolution\n4. Static semantics\na. Type checking.\nb. Define before use\nc. Annotation and extended static checking frameworks.\n5. L-values/R-values (See also: SDF-Fundamentals)\n6. Call semantics\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Semantics_Compiler_Semantic_Analysis.txt", ". Call semantics\n7. Types of parameter-passing with simple illustrations and comparison: call by value, call by\nreference, call by value-result, call by name, call by need and their variations\n8. Declarative specifications such as attribute grammars and their applications in handling limited\ncontext-base grammar\nIllustrative learning outcomes:\nNon-core:\n1. Draw the abstract syntax tree for a small language.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Semantics_Compiler_Semantic_Analysis.txt", ".\n2. Implement context-sensitive, source-level static analyses such as type-checkers or resolving\nidentifiers to identify their binding occurrences.\n3. Describe semantic analyses using an attribute grammar."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Pragmatics_Language_Pragmatics.txt", "Pages: 144-145\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Pragmatics_Language_Pragmatics.txt", "FPL-Pragmatics: Language Pragmatics\nNon-core:\n1. Effect of technology needs and software requirements on programming language development and\nevolution\n2. Problem domains and programming paradigm\n3. Criteria for good programming language design\na. Principles of language design such as orthogonality\nb. Defining control and iteration constructs\nc. Modularization of large software\n4. Evaluation order, precedence, and associativity\n5. Eager vs delayed evaluation\n6. Defining control and iteration constructs\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Pragmatics_Language_Pragmatics.txt", ". Defining control and iteration constructs\n7. External calls and system libraries\nIllustrative learning outcomes:\nNon-core:\n1. Discuss the role of concepts such as orthogonality and well-chosen defaults in language design.\n2. Objectively evaluate and justify language-design decisions.\n3. Implement an example program whose result can differ under different rules for evaluation order,\nprecedence, or associativity.\n4. Illustrate uses of delayed evaluation, such as user-defined control abstractions.\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Pragmatics_Language_Pragmatics.txt", ".\n5. Discuss the need for allowing calls to external calls and system libraries and the consequences for\nlanguage implementation."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Event-Driven_Event-Driven_and_Reactive_Programming.txt", "Pages: 134-135\n\nHOURS\n\tCS Core = 2\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Event-Driven_Event-Driven_and_Reactive_Programming.txt", "FPL-Event-Driven: Event-Driven and Reactive Programming\nCS Core:\n1. Procedural programming vs reactive programming: advantages of reactive programming in\ncapturing events.\n2. Components of reactive programming: event-source, event signals, listeners and dispatchers, event\nobjects, adapters, event-handlers. (See also: GIT-Interaction, SPD-Web, SPD-Mobile, SPD-Robot,\nSPD-Embedded, SPD-Game, SPD-Interactive)\n3. Stateless and state-transition models of event-based programming.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Event-Driven_Event-Driven_and_Reactive_Programming.txt", ".\n4. Canonical uses such as GUIs, mobile devices, robots, servers. (See also: GIT-Interaction, GITImage, SPD-Web, SPD-Mobile, SPD-Robot, SPD-Embedded, SPD-Game, SPD-Interactive)\nKA Core:\n5. Using a reactive framework:\na. Defining event handlers/listeners\nb. Parameterization of event senders and event arguments\nc. Externally generated events and program-generated events\n6. Separation of model, view, and controller\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Event-Driven_Event-Driven_and_Reactive_Programming.txt", ". Separation of model, view, and controller\n7. Event-driven and reactive programs as state-transition systems\nIllustrative learning outcomes:\nCS Core:\n1. Implement event handlers for use in reactive systems, such as GUIs.\n2. Examine why an event-driven programming style is natural in domains where programs react to\nexternal events.\nKA Core:\n3. Define and use a reactive framework.\n4. Describe an interactive system in terms of a model, a view, and a controller."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt", "Pages: 140-141\n\nHOURS\n\tCS Core = 0\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt", "FPL-Abstraction: Program Abstraction and Representation\nKA Core:\n1. BNF and regular expressions\n2. Programs that take (other) programs as input such as interpreters, compilers, type-checkers,\ndocumentation generators\n3. Components of a language:\na. Definitions of alphabets, delimiters, sentences, syntax, and semantics\nb. Syntax vs semantics\n4. Program as a set of non-ambiguous meaningful sentences\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt", ". Basic programming abstractions: constants, variables, declarations (including nested declarations),\ncommand, expression, assignment, selection, definite and indefinite iteration, iterators, function,\nprocedure, modules, exception handling (See also: SDF-Fundamentals)\n6. Mutable vs immutable variables: advantages and disadvantages of reusing existing memory\nlocation vs advantages of copying and keeping old values; storing partial computation vs\nrecomputation\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt", ". Types of variables: static, local, nonlocal, global; need and issues with nonlocal and global\nvariables.\n8. Scope rules: static vs dynamic; visibility of variables; side-effects.\n9. Side-effects induced by nonlocal variables, global variables and aliased variables.\nNon-core:\n10. L-values and R-values: mapping mutable variable-name to L-values; mapping immutable variablenames to R-values\n11. Environment vs store and their properties\n12. Data and control abstraction\n13"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt", ". Data and control abstraction\n13. Mechanisms for information exchange between program units such as procedures, functions, and\nmodules: nonlocal variables, global variables, parameter-passing, import-export between modules\n14. Data structures to represent code for execution, translation, or transmission.\n15. Low level instruction representation such as virtual machine instructions, assembly language, and\nbinary representation (See also: AR-Representation, AR-Assembly)\n16"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt", ". Lambda calculus, variable binding, and variable renaming. (See also: AL-Models, FPL-Formalism)\n17. Types of semantics: operational, axiomatic, denotational, behavioral; define and use abstract\nsyntax trees; contrast with concrete syntax.\nIllustrative learning outcomes:\nKA Core:\n1. Illustrate the scope of variables and visibility using simple programs.\n2. Illustrate different types of parameter-passing using simple pseudo programming language.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt", ".\n3. Explain side-effect using global and nonlocal variables and how to fix such programs.\n4. Explain how programs that process other programs treat the other programs as their input data.\n5. Describe a grammar and an abstract syntax tree for a small language.\n6. Describe the benefits of having program representations other than strings of source code.\n7. Implement a program to process some representation of code for some purpose, such as an\ninterpreter, an expression optimizer, or a documentation generator"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Abstraction_Program_Abstraction_and_Representation.txt", "."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt", "Pages: 133-134\n\nHOURS\n\tCS Core = 2\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt", "FPL-Scripting: Shell Scripting\nCS Core:\n1. Error/exception handling\n2. Piping (See also: AR-Organization, SF-Overview, OS-Process)\n3. System commands (See also: SF-Overview)\na. Interface with operating systems (See also: SF-Overview, OS-Principles)\n4. Environment variables (See also: SF-Overview)\n5. File abstraction and operators (See also: SDF-Fundamentals, OS-Files, SF-Resource)\n6. Data structures, such as arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDFData-Structures)\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Scripting_Shell_Scripting.txt", ". Regular expressions (See also: AL-Models)\n8. Programs and processes (See also: OS-Process)\n9. Workflow\nIllustrative learning outcomes:\nCS Core:\n1. Create and execute automated scripts to manage various system tasks.\n2. Solve various text processing problems through scripting."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Parallel_Parallel_and_Distributed_Computing.txt", "Pages: 135-136\n\nHOURS\n\tCS Core = 2 + 1 (PDC)\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Parallel_Parallel_and_Distributed_Computing.txt", "FPL-Parallel: Parallel and Distributed Computing\nCS Core:\n1. Safety and liveness (See also: PDC-Evaluation)\na. Race conditions (See also: OS-Concurrency)\nb. Dependencies/preconditions\nc. Fault models (See also: OS-Faults)\nd. Termination (See also: PDC-Coordination)\n2. Programming models (See also: PDC-Programs)\nOne or more of the following:\na. Actor models\nb. Procedural and reactive models\nc. Synchronous/asynchronous programming models\nd. Data parallelism\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Parallel_Parallel_and_Distributed_Computing.txt", ". Data parallelism\n3. Properties (See also: PDC-Programs, PDC-Coordination)\na. Order-based properties\ni. Commutativity\nii. Independence\nb. Consistency-based properties\ni. Atomicity\nii. Consensus\n4. Execution control: (See also: PDC-Coordination, SF-Foundations)\na. Async await\nb. Promises\nc. Threads\n5. Communication and coordination (See also: OS-Process, PDC-Communication, PDC-Coordination)\na. Mutexes\nb. Message-passing\nc. Shared memory\nd. Cobegin-coend\ne. Monitors\nf. Channels\ng. Threads\nh"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Parallel_Parallel_and_Distributed_Computing.txt", ". Monitors\nf. Channels\ng. Threads\nh. Guards\nKA Core:\n6. Futures\n7. Language support for data parallelism such as forall, loop unrolling, map/reduce\n8. Effect of memory-consistency models on language semantics and correct code generation\n9. Representational State Transfer Application Programming Interfaces (REST APIs)\n10. Technologies and approaches: cloud computing, high performance computing, quantum computing,\nubiquitous computing\n11. Overheads of message-passing\n12"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Parallel_Parallel_and_Distributed_Computing.txt", ". Overheads of message-passing\n12. Granularity of program for efficient exploitation of concurrency\n13. Concurrency and other programming paradigms (e.g., functional)\nIllustrative learning outcomes:\nCS Core:\n1. Explain why programming languages do not guarantee sequential consistency in the presence of\ndata races and what programmers must do as a result.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Parallel_Parallel_and_Distributed_Computing.txt", ".\n2. Implement correct concurrent programs using multiple programming models, such as shared\nmemory, actors, futures, synchronization constructs, and data-parallelism primitives.\n3. Use a message-passing model to analyze a communication protocol.\n4. Use synchronization constructions such as monitor/synchronized methods in a simple program.\n5. Modeling data dependency using simple programming constructs involving variables, read and\nwrite.\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Parallel_Parallel_and_Distributed_Computing.txt", ".\n6. Modeling control dependency using simple constructs such as selection and iteration.\nKA Core:\n7. Explain how REST API's integrate applications and automate processes.\n8. Explain benefits, constraints and challenges related to distributed and parallel computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Syntax_Syntax_Analysis.txt", "Pages: 141\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Syntax_Syntax_Analysis.txt", "FPL-Syntax: Syntax Analysis\nNon-core:\n1. Regular grammars vs context-free grammars (See also: AL-Models)\n2. Scanning and parsing based on language specifications\n3. Lexical analysis using regular expressions\n4. Tokens and their use\n5. Parsing strategies including top-down (e.g., recursive descent, or LL) and bottom-up (e.g., LR or\nGLR) techniques\na. Lookahead tables and their application to parsing\n6. Language theory:\na. Chomsky hierarchy (See also: AL-Models)\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Syntax_Syntax_Analysis.txt", ". Chomsky hierarchy (See also: AL-Models)\nb. Left-most/right-most derivation and ambiguity\nc. Grammar transformation\n7. Parser error recovery mechanisms\n8. Generating scanners and parsers from declarative specifications\nIllustrative learning outcomes:\nNon-core:\n1. Use formal grammars to specify the syntax of languages.\n2. Illustrate the role of lookahead tables in parsing.\n3. Use declarative tools to generate parsers and scanners.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Syntax_Syntax_Analysis.txt", ".\n4. Recognize key issues in syntax definitions: ambiguity, associativity, precedence."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt", "Pages: 145-146\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt", "FPL-Formalism: Formal Semantics\nNon-core:\n1. Syntax vs semantics\n2. Approaches to semantics: axiomatic, operational, denotational, type-based\n3. Axiomatic semantics of abstract constructs such as assignment, selection, iteration using precondition, post-conditions, and loop invariant\n4. Operational semantics analysis of abstract constructs and sequence of such as assignment,\nexpression evaluation, selection, iteration using environment and store\na. Symbolic execution\nb. Constraint checkers\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt", ". Symbolic execution\nb. Constraint checkers\n5. Denotational semantics\na. Lambda Calculus. (See also: AL-Models, FPL-Functional)\n6. Proofs by induction over language semantics\n7. Formal definitions and proofs for type systems (See also: FPL-Types)\na. Propositions as types (implication as a function, conjunction as a product, disjunction as a sum)\nb. Dependent types (universal quantification as dependent function, existential quantification as\ndependent product)\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt", ". Parametricity\nIllustrative learning outcomes:\nNon-core:\n1. Construct formal semantics for a small language.\n2. Write a lambda-calculus program and show its evaluation to a normal form.\n3. Discuss the different approaches of operational, denotational, and axiomatic semantics.\n4. Use induction to prove properties of all programs in a language.\n5. Use induction to prove properties of all programs in a language that is well-typed according to a\nformally defined type system.\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Formalism_Formal_Semantics.txt", ".\n6. Use parametricity to establish the behavior of code given only its type."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Methodologies_Formal_Development_Methodologies.txt", "Pages: 146\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Methodologies_Formal_Development_Methodologies.txt", "FPL-Methodologies: Formal Development Methodologies\n1. Formal specification languages and methodologies\n2. Theorem provers, proof assistants, and logics\n3. Constraint checkers (See also: FPL-Formalism)\n4. Dependent types (universal quantification as dependent function, existential quantification as\ndependent product) (See also: FPL-Types, FPL-Formalism)\n5. Specification and proof discharge for fully verified software systems using pre/post conditions,\nrefinement types, etc.\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Methodologies_Formal_Development_Methodologies.txt", ".\n6. Formal modeling and manual refinement/implementation of software systems.\n7. Use of symbolic testing and fuzzing in software development.\n8. Model checking.\n9. Understanding of situations where formal methods can be effectively applied and how to structure\ndevelopment to maximize their value.\nIllustrative learning outcomes:\nNon-core:\n1. Use formal modeling techniques to develop and validate architectures.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Methodologies_Formal_Development_Methodologies.txt", ".\n2. Use proof assisted programming languages to develop fully specified and verified software artifacts.\n3. Use verifier and specification support in programming languages to formally validate system\nproperties.\n4. Integrate symbolic validation tooling into a programming workflow.\n5. Discuss when and how formal methods can be effectively used in the development process."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Code_Code_Generation.txt", "Pages: 142-143\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Code_Code_Generation.txt", "FPL-Code: Code Generation\nNon-core:\n1. Instruction sets (See also: AR-Assembly)\n2. Control flow\n3. Memory management (See also: AR-Memory, OS-Memory)\n4. Procedure calls and method dispatching\n5. Separate compilation; linking\n6. Instruction selection\n7. Instruction scheduling (e.g., pipelining)\n8. Register allocation\n9. Code optimization as a form of program analysis (See also: FPL-Analysis)\n10. Program generation through generative AI\nIllustrative learning outcomes:\nNon-core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Code_Code_Generation.txt", ". Identify all essential steps for automatically converting source code into assembly or other low-level\nlanguages.\n2. Explain the low-level code necessary for calling functions/methods in modern languages.\n3. Discuss why separate compilation requires uniform calling conventions.\n4. Discuss why separate compilation limits optimization because of unknown effects of calls.\n5. Discuss opportunities for optimization introduced by naive translation and approaches for achieving"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Code_Code_Generation.txt", ".\noptimization, such as instruction selection, instruction scheduling, register allocation, and peephole\noptimization."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt", "Pages: 133\n\nHOURS\n\tCS Core = 0\n\tKA Core = 2 + 1 (MSF)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt", "FPL-Logic: Logic Programming\nKA Core:\n1. Universal vs existential quantifiers. (See also: AI-LRR, MSF-Discrete)\n2. First order predicate logic vs higher order logic. (See also: AI-LRR, MSF-Discrete)\n3. Expressing complex relations using logical connectives and simpler relations.\n4. Definitions of Horn clause, facts, goals and subgoals.\n5. Unification and unification algorithm; unification vs assertion vs expression evaluation.\n6. Mixing relations with functions. (See also: MSF-Discrete)\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt", ". (See also: MSF-Discrete)\n7. Cuts, backtracking, and non-determinism.\n8. Closed-world vs open-world assumptions.\nNon-core:\n9. Memory overhead of variable copying in handling iterative programs.\n10. Programming constructs to store partial computation and pruning search trees.\n11. Mixing functional programming and logic programming using concepts such as equational logic,\nnarrowing, residuation, and semantic unification. (See also: FPL-Functional)\n12. Higher-order, constraint, and inductive logic programming"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt", ". (See also: AI-LRR)\n13. Integration with other programming paradigms such as object-oriented programming.\n14. Advance programming constructs such as difference-lists, creating user defined data structures, set\nof, etc.\nIllustrative learning outcomes:\nKA Core:\n1. Use a logic language to implement a conventional algorithm.\n2. Use a logic language to implement an algorithm employing implicit search using clauses, relations,\nand cuts.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt", ".\n3. Use a simple illustrative example to show correspondence between First Order Predicate Logic\n(FOPL) and logic programs using Horn clauses.\n4. Use examples to illustrate the unification algorithm and its role of parameter-passing in query\nreduction.\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Logic_Logic_Programming.txt", ".\n5. Use simple logic programs interleaving relations, functions, and recursive programming such as\nfactorial and Fibonacci numbers and simple complex relationships between entities and illustrate\nexecution and parameter-passing using unification and backtracking.\nNon-core:\n6. Illustrate computation of simple programs such as Fibonacci and show overhead of recomputation,\nand then show how to improve execution overhead."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Systems_Systems_Execution_and_Memory_Model.txt", "Pages: 138-139\n\nHOURS\n\tCS Core = 2 + 1 (AR and OS)\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Systems_Systems_Execution_and_Memory_Model.txt", "FPL-Systems: Systems Execution and Memory Model\nCS Core:\n1. Data structures for translation, execution, translation, and code mobility such as stack, heap,\naliasing (sharing using pointers), indexed sequence and string\n2. Direct, indirect, and indexed access to memory location\n3. Run-time representation of data abstractions such as variables, arrays, vectors, records, pointerbased data elements such as linked-lists and trees, and objects\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Systems_Systems_Execution_and_Memory_Model.txt", ". Abstract low-level machine with simple instruction, stack, and heap to explain translation and\nexecution\n5. Run-time layout of memory: activation record (with various pointers), static data, call-stack, heap\n(See also: AR-Memory, OS-Memory)\na. Translating selection and iterative constructs to control-flow diagrams\nb. Translating control-flow diagrams to low level abstract code\nc. Implementing loops, recursion, and tail calls\nd"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Systems_Systems_Execution_and_Memory_Model.txt", ". Implementing loops, recursion, and tail calls\nd. Translating function/procedure calls and return from calls, including different parameter-passing\nmechanisms using an abstract machine\n6. Memory management: (See also: AR-Memory, OS-Memory)\na. Low level allocation and accessing of high-level data structures such as basic data types, ndimensional array, vector, record, and objects\nb. Return from procedure as automatic deallocation mechanism for local data elements in the\nstack\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Systems_Systems_Execution_and_Memory_Model.txt", ". Manual memory management: allocating, de-allocating, and reusing heap memory\nd. Automated memory management: garbage collection as an automated technique using the\nnotion of reachability\n7. Green computing. (See also: SEP-Sustainability)\nIllustrative learning outcomes:\nCS Core:\n1. Explain how a core language construct, such as data abstractions and control abstractions, is\nexecuted.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Foundations_of_Programming_Languages_FPL/FPL-Systems_Systems_Execution_and_Memory_Model.txt", ".\n2. Explain how programming language implementations typically organize memory into global data,\ntext, heap, and stack sections and how features such as recursion and memory management map\nto this memory model.\n3. Explain why memory leaks and dangling pointer problems occur, and what can be done by a\nprogrammer to avoid/fix them."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Robot_Platforms.txt", "Pages : 242-243\nCS Core : None, KA Core : 4 (+6)\n(Additional hours here are hours shared with other Areas)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Robot_Platforms.txt", "KA Core:  \n1. Types of robotic platforms and devices (See also: AI-Robotics) \n2. Sensors, embedded computation, and effectors (actuators) (See also: GIT-Physical)  \n3. Robot-specific languages and libraries (See also: AI-Robotics) \n4. Robotic software architecture (e.g., using the Robot Operating System (ROS)) \n5. Robotic platform constraints and design considerations (See also: AI-Robotics) \n6. Interconnections with physical or simulated systems (See also: GIT-Physical, GIT-Simulation) \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Robot_Platforms.txt", ". Robotic Algorithms (See also: AI-Robotics, GIT-Animation) \na. Forward kinematics \nb. Inverse kinematics  \nc. Dynamics \nd. Navigation and path planning \ne. Grasping and manipulation  \n8. Safety and interaction considerations (See also: SEP-Professional-Ethics, SEP-Context) \n \nIllustrative Learning Outcomes: \nKA Core: \n1. Design and implement an application on a given robotic platform. \n2. Integrate an Arduino-based robot kit and program it to navigate a maze. \n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Robot_Platforms.txt", ". \n3. Compare robot-specific languages and techniques with those used for general-purpose software development. \n4. Explain the rationale behind the design of the robotic platform and its interconnections with physical or simulated systems. \n5. Given a high-level application, design a robot software architecture using ROS specifying all components and interconnections (ROS topics) to accomplish that application. \n6. Discuss the constraints a given robotic platform imposes on developers."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Mobile_Platforms.txt", "Pages : 241-242\nCS Core : None, KA Core : 3 (+5)\n(Additional hours here are hours shared with other Areas)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Mobile_Platforms.txt", "KA Core: \n1. Development with  \na. Mobile programming languages \nb. Mobile programming environments \n2. Mobile platform constraints \na. User interface design (See also: HCI-User) \nb. Security \n3. Access \na. Accessing data through APIs (See also: DM-Querying) \nb. Designing API endpoints for mobile apps: pitfalls and design considerations \nc. Network and web interfaces (See also: NC-Fundamentals, DM-Modeling) \n \nNon-core: \n4. Development \na. Native versus cross-platform development \nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Mobile_Platforms.txt", ". Native versus cross-platform development \nb. Software design/architecture patterns for mobile applications (See also: SE-Design) \n5. Mobile platform constraints \na. Responsive user interface design (See also: HCI-Accessibility) \nb. Heterogeneity and mobility of devices \nc. Differences in user experiences (e.g., between mobile and web-based applications) \nd. Power and performance tradeoff \n6. Mobile computing affordances \na. Location-aware applications \nb. Sensor-driven computing (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Mobile_Platforms.txt", ". Sensor-driven computing (e.g., gyroscope, accelerometer, health data from a watch) \nc. Telephony and instant messaging \nd. Augmented reality (See also: GIT-Immersion) \n7. Specification and testing (See also: SDF-Practices, SE-Validation) \n8. Asynchronous computing (See also: PDC-Algorithms) \na. Difference from traditional synchronous programming \nb. Handling success via callbacks \nc. Handling errors asynchronously \nd"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Mobile_Platforms.txt", ". Handling errors asynchronously \nd. Testing asynchronous code and typical problems in testing \n \nIllustrative Learning Outcomes: \nKA Core: \n1. Compare mobile programming with general-purpose programming. \n2. Develop a location-aware mobile application with data API integration. \n3. Build a sensor-driven mobile application capable of logging data on a remote server. \n4. Create a communication app incorporating telephony and instant messaging. \n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Mobile_Platforms.txt", ". \n5. Evaluate the pros and cons of native and cross-platform mobile application development."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", "Pages : 244-245-246\nCS Core : None, KA Core : 4 (+16)\n(Additional hours here are hours shared with other Areas)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", "KA Core:  \n1. Historical and contemporary platforms for games (See also: AR-Logic) \na. Evolution of Game Platforms (e.g., Brown Box to Metaverse and beyond; Improvement in Computing Architectures (CPU and GPU); Platform Convergence and Mobility) \nb. Typical Game Platforms (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". Typical Game Platforms (e.g., Personal Computer; Home Console; Handheld Console; Arcade Machine; Interactive Television; Mobile Phone; Tablet; Integrated Head-Mounted Display; Immersive Installations and Simulators; Internet of Things enabled Devices; CAVE Systems; Web Browsers; Cloud-based Streaming Systems) \nc. Characteristics and Constraints of Different Game Platforms (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ".g., Features (local storage, internetworking, peripherals); Run-time performance (GPU/CPU frequency, number of cores); Chipsets (physics processing units, vector co-processors); Expansion Bandwidth (PCIe); Network throughput (Ethernet); Memory types and capacities (DDR/GDDR); Maximum stack depth; Power consumption; Thermal design; Endian)  \nd. Typical Sensors, Controllers, and Actuators (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". Typical Sensors, Controllers, and Actuators (e.g., distinctive control system designs \u2013peripherals (mouse, keypad, joystick), game controllers, wearables, interactive surfaces; electronics and bespoke hardware; computer vision, inside-out tracking, and outside-in tracking; IoT-enabled electronics and I/O) (See also: GIT-Interaction) \ne. eSports Ecosystems (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". eSports Ecosystems (e.g., evolution of gameplay across platforms; games and eSports; game events such as LAN/arcade tournaments and international events such as the Olympic eSports Series; streamed media and spectatorship; multimedia technologies and broadcast management; professional play; data and machine learning for coaching and training) \n2. Real-time Simulation and Rendering Systems \na. CPU and GPU architectures (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". CPU and GPU architectures (e.g., Flynn\u2019s taxonomy; parallelization; instruction sets; standard components \u2013 graphics compute array, graphics memory controller, video graphics array basic input/output system; bus interface; power management unit; video processing unit; display interface) (See also: AR-Heterogeneity) \nb. Pipelines for physical simulations and graphical rendering: (e.g., tile-based, immediate-mode). (See also: GIT-Rendering) \nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". (See also: GIT-Rendering) \nc. Common Contexts for Algorithms, Data Structures, and Mathematical Functions (e.g., game loops; spatial partitioning, viewport culling, and level of detail; collision detection and resolution; physical simulation; behavior for intelligent agents; procedural content generation) (See also: MSF-Discrete, AL-Foundational) \nd. Media representations (e.g., I/O, and computation techniques for virtual worlds: audio; music; sprites; models and textures; text; dialogue; multimedia (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ".g., olfaction, tactile)) (See also: GIT-Fundamentals) \n3. Game Development Tools and Techniques \na. Programming Languages (e.g., C++; C#; Lua; Python; JavaScript) \nb. Shader Languages (e.g., HLSL, GLSL; Shader Graph) \nc. Graphics Libraries and APIs (e.g., DirectX; SDL; OpenGL; Metal; Vulkan; WebGL). (See also: GIT-Rendering, HCI-Design) \nd. Common Development Tools and Environments (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". Common Development Tools and Environments (e.g., IDEs; Debuggers; Profilers; Version Control Systems including those handling binary assets; Development Kits and Production/Consumer Kits; Emulators) (See also: SDF-Practices, SE-Tools) \n4. Game Engines \na. Open Game Engines (e.g., Unreal; Unity; Godot; CryEngine; Phyre; Source 2; Pygame and Ren\u2019Py; Phaser; Twine; Spring RTS) \nb. Techniques (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". Techniques (e.g., Ideation, Prototyping, Iterative Design and Implementation, Compiling Executable Builds, Development Operations and Quality Assurance \u2013 Play Testing and Technical Testing, Profiling; Optimization, Porting; Internationalization and Localization, Networking) (See also: AR-Performance-Energy, SE-Requirements) \n5. Game Design \na. Vocabulary (e.g., game definitions; mechanics-dynamics-aesthetics model; industry terminology; experience design; models of experience and emotion) \nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". Design Thinking and User-Centered Experience Design (e.g., methods of designing games; iteration, incrementing, and the double-diamond; phases of pre- and post-production; quality assurance, including alpha and beta testing; stakeholder and customer involvement; community management) (See also: SE-Design) \nc. Genres (e.g., adventure; walking simulator; first-person shooter; real-time strategy; multiplayer online battle arena (MOBA); role-playing game (rpg)) \nd. Audiences and Player Taxonomies (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". Audiences and Player Taxonomies (e.g., people who play games; diversity and broadening participation; pleasures, player types, and preferences; Bartle, yee) (See also: HCI-User) \ne. Proliferation of digital game technologies to domains beyond entertainment (e.g., Education and Training; Serious Games; Virtual Production; eSports; Gamification; Immersive Experience Design; Creative Industry Practice; Artistic Practice; Procedural Rhetoric) (See also: AI-SEP) \n \nIllustrative Learning Outcomes: \nKA Core: \n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". Recall the characteristics of common general-purpose graphics processing architectures. \n2. Identify the key stages of the immediate-mode rendering pipeline. \n3. Describe the key constraints a specific game platform will likely impose on developers. \n4. Explain how eSports are streamed to large audiences over the internet. \n5. Translate complex mathematical functions into performant source code. \n6. Use an industry-standard graphics API to render a 3D model in a virtual scene. \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". \n7. Modify a shader to change a visual effect according to stated requirements. \n8. Implement a game for a particular platform according to the specification. \n9. Optimize a function for processing collision detection in a simulated environment. \n10. Assess a game's run-time and memory performance using an industry-standard tool and development environment. \n11. Compare the interfaces of different game platforms, highlighting their respective implications for human-computer interaction. \n12"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Game_Platforms.txt", ". \n12. Recommend an appropriate set of development tools and techniques for implementing a game of a particular genre for a given platform. \n13. Discuss the key challenges in making a digital game that is cross-platform compatible. \n14. Express how game developers can enhance the accessibility of a game interface. \n15. Create novel forms of gameplay using frontier game platforms."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Interactive_Computing_Platforms.txt", "Pages : 246-247\nCS Core : None, KA Core : 3 (+5)\n(Additional hours here are hours shared with other Areas)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Interactive_Computing_Platforms.txt", "Non-core: \n1. Data Analysis Platforms \na. Jupyter notebooks; Google Colab; R; SPSS; Observable. \nb. Cloud SQL/data analysis platforms (e.g., BigQuery) (See also: DM-Querying) \ni. Apache Spark \nii. Data Visualizations (See also: GIT-Visualization) \nc. Interactive presentations backed by data \nd. Design tools requiring low-latency feedback loops \ni. Rendering tools \nii. Graphic design tools \n2. Prompt programming  \na. Generative AI (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Interactive_Computing_Platforms.txt", ". Prompt programming  \na. Generative AI (e.g., OpenAI\u2019s ChatGPT, OpenAI\u2019s Codex, GitHub\u2019s Copilot) and LLMs are accessed/interacted \n3. Quantum Platforms (See also: AR-Quantum) \na. Program quantum logic operators in quantum machines.  \nb. Use API for available quantum services \nc. Signal analysis/Fourier analysis/Signal processing (for music composition, audio/RF analysis) (See also: GIT-Image) \n \nIllustrative Learning Outcomes: \nNon-core: \n1. Analyze large datasets interactively. \n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Interactive_Computing_Platforms.txt", ". Analyze large datasets interactively. \n2. Create a backing track for a musical performance, such as live coding. \n3. Create compelling computational notebooks that construct a narrative for a given journalistic goal/story. \n4. Implement interactive code that uses a dataset and generates exploratory graphics. \n5. Create a program that performs a task using LLM systems. \n6. Contrast a program developed by an AI platform and by a human. \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Interactive_Computing_Platforms.txt", ". \n7. Implement a system that interacts with a human without using a screen. \n8. Contextualize the attributes of different data analysis styles, such as interactive vs engineered pipeline. \n9. Write a program using a notebook computing platform (e.g., searching, sorting, or graph manipulation). \n10. Demonstrate a quantum gate outcome using a quantum platform."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", "Pages : 247-248-249-250\nCS Core : None, KA Core : None\n(This section will be divided with the SEP area for each platform)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", "SPD-SEP/Mobile \nNon-core: \n1. Privacy and data protection \n2. Accessibility in mobile design \n3. Security and cybersecurity \n4. Social impacts of mobile technology \n5. Ethical use of AI and algorithms \n \nIllustrative Learning Outcomes: \nNon-core: \n1. Understand and uphold ethical responsibilities for safeguarding user privacy and data protection in mobile applications. \n2. Design mobile applications with accessibility in mind, ensuring effective use by people with disabilities. \n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". \n3. Demonstrate proficiency in secure coding practices to mitigate risks associated with various security threats in mobile development. \n4. Analyze the broader social impacts of mobile technology, including its influence on communication patterns, relationships, and mental health. \n5. Comprehend the ethical considerations of using AI in mobile applications, ensuring unbiased and fair algorithms."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", "SPD-SEP/Web \nNon-core: \n1. Privacy concerns with mobile apps \n2. Designing for inclusivity and accessibility \n3. Ethical use of AI in mobile apps \n4. Sustainable app development and server hosting \n5. Avoiding spam or intrusive notifications \n6. Addressing cyberbullying and harassment \n7. Promoting positive online communities \n8. Monetization and advertising \n9. Ethical use of gamification \n \nIllustrative Learning Outcomes: \nNon-core: \n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". Understand how mobile computing impacts communications and the flow of information within society. \n2. Design mobile apps that have made daily tasks easier/faster. \n3. Recognize how the ubiquity of mobile computing has affected work-life balance. \n4. Understand how mobile computing impacts health monitoring and healthcare services. \n5. Define how mobile apps are used to educate about and help achieve UN sustainability goals."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", "SPD-SEP/Game \nNon-core: \n1. Intellectual Property Rights in Creative Industries \na. Intellectual Property Ownership: copyright, trademark; design right, patent, trade secret, civil versus criminal law; international agreements; procedural content generation and the implications of generative artificial intelligence \nb. Licensing: Usage and fair usage exceptions; open-source license agreements; proprietary and bespoke licensing; enforcement \n2. Fair Access to Play \na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". Fair Access to Play \na. Game Interface Usability: user requirements, affordances, ergonomic design, user research, experience measurement, and heuristic evaluation methods for games \nb. Game Interface Accessibility: forms of impairment and disability; means to facilitate game access; universal design; legislated requirements for game platforms; compliance evaluation; challenging game mechanics and access \n3. Game-Related Health and Safety \na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". Game-Related Health and Safety \na. Injuries in Play: ways of mitigating common upper body injuries, such as repetitive strain injury; exercise psychology and physiotherapy in eSports \nb. Risk Assessment for Events and Manufacturing: control of substances hazardous to health (COSHH); fire safety; electrical and electronics safety; risk assessment for games and game events; risk assessment for manufacturing \nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". Mental Health: motivation to play; gamification and gameful design; game psychology \u2013internet gaming disorder  \n4. Platform Hardware Supply Chain and Sustainability \na. Platform Lifecycle: platform composition \u2013 materials, assembly; mineral excavation and processing; power usage; recycling; planned obsolescence. \nb. Modern Slavery: supply chains; forced labor and civil rights; working conditions; detection and remission; certification bodies and charitable endeavors. \n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". \n5. Representation in the Media and Industry \na. Inclusion: identity and identification; inclusion of a broad range of characters for diverse audiences; media representation and its effects; media literacy; content analysis; stereotyping; sexualization \nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". Equality: histories and controversies, such as gamergate, quality of life in the industry, professional discourse and conduct in business contexts, pathways to game development careers, social mobility, the experience of developers from different backgrounds and identities, gender, and technology \n \nIllustrative Learning Outcomes: \nNon-core: \n1. Discuss how creators can protect their intellectual property. \n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". \n2. Identify common pitfalls in game interfaces that exclude players with impaired or non-functional vision. \n3. Describe how heuristic evaluation can be used to identify usability problems in game interfaces. \n4. Explain why upper body injuries are common in eSports. \n5. Discuss how to reform characters and dialogues in a scene to reduce stereotype threat. \n6. Illustrate how the portrayal of race in a game can influence the risk of social exclusion in the associated online community around the game. \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". \n7. Modify a policy for a LAN party event to include mitigations that lower the risk of fire. \n8. Design a gamification strategy to motivate serious play for an awareness-raising game. \n9. Analyze the role of company hiring policies and advocacy on social mobility. \n10. Assess the appropriateness of two manufacturers for producing a new game console. \n11. Compare options for open-source licensing of a game development tool. \n12"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". \n12. Recommend changes to a specific game interface to improve access to players who are deaf or whose hearing is otherwise impaired. \n13. Discuss whether games are addictive. \n14. Suggest how the portrayal of women in video games influences how players perceive members of those groups. \n15. Create a video game that successfully advocates for climate science."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", "SPD-SEP/Robotics \nNon-core: \n1. Fairness, transparency, and accountability in robotic algorithms \n2. Mitigating biases in robot decision-making \n3. Public safety in shared spaces with robots \n4. Compliance with data protection laws \n5. Patient consent and trust in medical robots"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", "Illustrative Learning Outcomes: \nNon-core: \n1. Identify instances of bias in robotic algorithms and propose strategies to mitigate them. \n2. Evaluate and critique robotic systems for ethical and fairness considerations, suggesting improvements where necessary. \n3. Analyze real-world examples of biases in robot decision-making and develop strategies to reduce bias in robotic systems. \n4. Assess the potential risks associated with robots in public spaces and propose safety measures to mitigate those risks"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". \n5. Evaluate the impact of patient consent and trust on the effectiveness of medical robot deployments in healthcare contexts."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", "SPD-SEP/Interactive \nNon-core:  \n1. Ethical guidelines when using AI models to assist in journalism and content creation \n2. Accountability for AI-generated outputs \n3. Behavior among prompt programmers and AI developers \n4. Trust with the public when using AI models \n \nIllustrative Learning Outcomes: \nNon-core: \n1. Indicate a framework for accountability in AI model deployment, including clear documentation and attribution. \n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Society_Ethics_and_the_Profession.txt", ". \n2. Discuss ethical codes of conduct and professional standards relevant to prompt programming and AI development. \n3. Create communication plans and materials to educate the public about AI capabilities, limitations, and ethical safeguards."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Embedded_Platforms.txt", "Pages : 243-244\nCS Core : None, KA Core : 4 (+10)\n(Additional hours here are hours shared with other Areas)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Embedded_Platforms.txt", "KA Core:  \n1. Introduction to the unique characteristics of embedded systems \na. Real-time vs soft real-time and non-real-time systems \nb. Resource constraints, such as memory profiles and deadlines (See also: AR-Memory) \n2. API for custom architectures \na. GPU technology (See also: AR-Heterogeneity, GIT-Shading) \nb. Field Programmable Gate Arrays (FPGA) (See also: AR-Logic) \nc. Cross-platform systems \n3. Embedded Systems \na. Microcontrollers \nb. Interrupts and feedback \nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Embedded_Platforms.txt", ". Microcontrollers \nb. Interrupts and feedback \nc. Interrupt handlers in high-level languages (See also: SF-Overview) \nd. Hard and soft interrupts and trap-exits (See also: OS-Principles) \ne. Interacting with hardware, actuators, and sensors \nf. Energy efficiency \ng. Loosely timed coding and synchronization \nh. Software adapters \n4. Embedded programming \n5. Hard real-time systems vs soft real-time systems (See also: OS-Real-time) \na. Timeliness \nb. Time synchronization/scheduling \nc. Prioritization \nd"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Embedded_Platforms.txt", ". Prioritization \nd. Latency \ne. Compute jitter \n6. Real-time resource management \n7. Memory management \na. Mapping programming construct (variable) to a memory location (See also: AR-Memory) \nb. Shared memory (See also: OS-Memory) \nc. Manual memory management. \nd. Garbage collection (See also: FPL-Translation) \n8. Safety considerations and safety analysis (See also: SEP-Context, SEP-Professional-Ethics) \n9. Sensors and actuators \n10. Analysis and verification \n11"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Embedded_Platforms.txt", ". Analysis and verification \n11. Application design \n \nIllustrative Learning Outcomes: \nKA Core: \n1. Design and implement a small embedded system for a given platform (e.g., a smart alarm clock or a drone). \n2. Describe the unique characteristics of embedded systems versus other systems. \n3. Interface with sensors/actuators. \n4. Debug a problem with an existing embedded platform. \n5. Identify different types of embedded architectures. \n6. Evaluate which architecture is best for a given set of requirements"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Embedded_Platforms.txt", ". \n7. Design and develop software to interact with and control hardware. \n8. Design methods for real-time systems. \n9. Evaluate real-time scheduling and schedulability analysis. \n10. Evaluate formal specification and verification of timing constraints and properties."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Web_Platforms.txt", "Page : 241\nCS Core : None, KA Core : 5 (+1)\n(Additional hours here are hours shared with other Areas)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Web_Platforms.txt", "KA Core: \n1. Web programming languages (e.g., HTML5, JavaScript, PHP, CSS) \n2. Web platforms, frameworks, or meta-frameworks \na. Cloud services \nb. API, Web Components \n3. Software as a Service (SaaS) \n4. Web standards such as document object model, accessibility (See also: HCI-Accessibility) \n5. Security and Privacy Considerations (See also: SEP-Security) \n \nNon-core:  \n6. Analyzing requirements for web applications \n7. Computing services (See also: DM-NoSQL) \na. Cloud Hosting \nb. Scalability (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Web_Platforms.txt", ". Cloud Hosting \nb. Scalability (e.g., Autoscaling, Clusters) \nc. Cost estimation for services \n8. Data management (See also: DM-Core) \na. Data residency: where the data is located and what paths can be taken to access it \nb. Data integrity: guaranteeing data is accessible and that data is deleted when required \n9. Architecture \na. Monoliths vs Microservices \nb. Micro-frontends \nc. Event-Driven vs RESTful architectures: advantages and disadvantages \nd. Serverless, cloud computing on demand \n10"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Web_Platforms.txt", ". Serverless, cloud computing on demand \n10. Storage solutions (See also: DM-Relational, DM-NoSQL) \na. Relational Databases \nb. NoSQL databases \n \nIllustrative Learning Outcomes: \nKA Core: \n1. Design and implement a web-based application using a microservice architecture design. \n2. Describe the constraints, such as hosting, services, and scalability, related to web platforms. \n3. Compare and contrast web programming with general-purpose programming.  \n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Web_Platforms.txt", ".  \n4. Describe the differences between Software-as-a-Service (SaaS) and traditional software products. \n5. Discuss how web standards impact software development.  \n6. Evaluate an existing web application against current web standards."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt", "Pages : 240-241\nCS Core : 4, KA Core : 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt", "CS Core: \n1. Overview of development platforms (i.e., web, mobile, game, robotics, embedded, and interactive). \na. Input/sensors/control devices/haptic devices \nb. Resource constraints \ni. Computational \nii. Data storage \niii. Memory \niv. Communication \nc. Requirements \u2013 security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-Engineering) \nd. Output/actuators/haptic devices \n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt", ". Output/actuators/haptic devices \n2. Programming via platform-specific Application Programming Interface (API) vs traditional application construction \n3. Overview of platform Languages (e.g., Python, Swift, Lua, Kotlin) \n4. Programming under platform constraints and requirements (e.g., available development tools, development, security considerations) (See also: SEC-Foundations) \n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Specialized_Platform_Development_SPD/SPD-Common_Aspects.txt", ". Techniques for learning and mastering a platform-specific programming language \n \nIllustrative Learning Outcomes: \nCS Core: \n1. List the constraints of mobile programming. \n2. List the characteristics of scripting languages. \n3. Describe the three-tier model of web programming.  \n4. Describe how the state is maintained in web programming."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Security_SEC/SEC-Access_Control.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSEC-Access Control: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SEC-Access Control.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Security_SEC/SEC-Cryptography.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSEC-Cryptography: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SEC-Cryptography.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Security_SEC/SEC-Threat_Modeling.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSEC-Threat Modeling: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SEC-Threat Modeling.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Security_SEC/SEC-Ethical_Hacking.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSEC-Ethical Hacking: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SEC-Ethical Hacking.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Security_SEC/SEC-Incident_Response.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSEC-Incident Response: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SEC-Incident Response.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Security_SEC/SEC-Security_Foundations.txt", "Pages: 255-256\nHOURS\n    CS Core = 3\n    KA Core = 2\n\nSEC-Security Foundations: Principles of Secure Computing\nCS Core:\n1. Fundamental security principles (Confidentiality, Integrity, Availability).\n2. Threat models and risk assessment.\n3. Cryptographic techniques for data protection.\n4. Secure coding practices.\n5. Authentication and access control mechanisms.\n\nKA Core:\n6. Network security concepts and protocols.\n7. Incident response and forensics.\n8. Advanced cryptographic methods."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Security_SEC/SEC-Security_Foundations.txt", "Illustrative Learning Outcomes:\n1. Explain the CIA triad and its role in security.\n2. Identify common security vulnerabilities in software applications.\n3. Apply cryptographic techniques to ensure secure communications."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Security_SEC/SEC-Malware_Analysis.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSEC-Malware Analysis: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SEC-Malware Analysis.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Security_SEC/SEC-Network_Security.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nSEC-Network Security: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of SEC-Network Security.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Processing_Query_Processing.txt", "Pages: 118-119\n\nHOURS\n\tCS Core = 0\n\tKA Core = 4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Processing_Query_Processing.txt", "DM-Processing: Query Processing\nKA Core:\n1. Page structures\n2. Index structures\na. B+ trees (See also: AL-Foundational)\nb. Hash indices: static and dynamic (See also: AL-Foundational, SEC-Foundations)\nc. Index creation in SQL\n3. File structures (See also: OS-Files)\na. Heap files\nb. Hash files\n4. Algorithms for query operators\na. External Sorting (See also: AL-Foundational)\nb. Selection\nc. Projection; with and without duplicate elimination\nd. Natural Joins: Nested loop, Sort-merge, Hash join\ne"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Processing_Query_Processing.txt", ". Analysis of algorithm efficiency (See also: AL-Complexity)\n5. Query transformations\n6. Query optimization\na. Access paths\nb. Query plan construction\nc. Selectivity estimation\nd. Index-only plans\n7. Parallel Query Processing (e.g., parallel scan, parallel join, parallel aggregation) (See also: PDC-\nAlgorithms)\n8. Database tuning/performance\na. Index selection\nb. Impact of indices on query performance (See also: SF-Performance, SEP-Sustainability)\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Processing_Query_Processing.txt", ". Denormalization\nIllustrative Learning Outcomes:\nKA Core:\n1. Describe the purpose and organization of both B+ tree and hash index structures.\n2. Compose an SQL command to create an index (any kind).\n3. Specify the steps for the various query operator algorithms: external sorting, projection with\nduplicate elimination, sort-merge join, hash-join, block nested-loop join.\n4. Derive the run-time (in I/O requests) for each of the above algorithms.\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Processing_Query_Processing.txt", ".\n5. Transform a query in relational algebra to its equivalent appropriate for a left-deep, pipelined\nexecution.\n6. Compute selectivity estimates for a given selection and/or join operation.\n7. Describe how to modify an index structure to facilitate an index-only operation for a given relation.\n8. For a given scenario decide on which indices to support for the efficient execution of a set of\nqueries.\n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Processing_Query_Processing.txt", ".\n9. Describe how DBMSs leverage parallelism to speed up query processing by dividing the work\nacross multiple processors or nodes."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Security_Data_Security_and_Privacy.txt", "Pages: 121\n\nHOURS\n\tCS Core = 1\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Security_Data_Security_and_Privacy.txt", "DM-Security: Data Security and Privacy\nCS Core:\n1. Differences between data security and data privacy (See also: SEC-Foundations)\n2. Protecting data and database systems from attacks, including injection attacks such as SQL\ninjection (See also: SEC-Foundations)\n3. Personally identifying information (PII) and its protection (See also: SEC-Foundations, SEP-\nSecurity, SEP-Privacy)\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Security_Data_Security_and_Privacy.txt", ". Ethical considerations in ensuring the security and privacy of data (See also: SEC-SEP, SEP-\nEthical-Analysis, SEP-Security, SEP-Privacy)\nKA Core:\n5. Need for, and different approaches to securing data at rest, in transit, and during processing (See\nalso: SEC-Foundations, SEC-Crypto)\n6. Database auditing and its role in digital forensics (See also: SEC-Forensics)\n7. Data inferencing and preventing attacks (See also: SEC-Crypto)\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Security_Data_Security_and_Privacy.txt", ". Laws and regulations governing data security and data privacy (See also: SEP-Security, SEP-\nPrivacy, SEC-Foundations, SEC-Governance)\nNon-core:\n9. Typical risk factors and prevention measures for ensuring data integrity (See also: SEC-\nGovernance)\n10. Ransomware and prevention of data loss and destruction (See also: SEC-Coding, SEC-Forensics)\nIllustrative Learning Outcomes:\nCS Core:\n1. Describe the differences in the goals for data security and data privacy.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Security_Data_Security_and_Privacy.txt", ".\n2. Identify and mitigate risks associated with different approaches to protecting data.\n3. Describe legal and ethical considerations of end-to-end data security and privacy.\nKA Core:\n4. Develop a database auditing system given risk considerations.\n5. Apply several data exploration approaches to understanding unfamiliar datasets."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt", "Pages: 117-118\n\nHOURS\n\tCS Core = 1\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt", "DM-Relational: Relational Databases\nCS Core:\n1. Entity and referential integrity: Candidate key, superkeys\n2. Relational database design\nKA Core:\n3. Mapping conceptual schema to a relational schema\n4. Physical database design: file and storage structures (See also: OS-Files)\n5. Introduction to Functional dependency theory\n6. Normalization Theory\na. Decomposition of a schema; lossless-join, and dependency-preservation properties of a\ndecomposition\nb. Normal forms (BCNF)\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt", ". Normal forms (BCNF)\nc. Denormalization (for efficiency)\nNon-core:\n7. Functional dependency theory\na. Closure of a set of attributes\nb. Canonical Cover\n8. Normalization theory\na. Multi-valued dependency (4NF)\nb. Join dependency (PJNF, 5NF)\nc. Representation theory\nIllustrative Learning Outcomes:\nCS Core:\n1. Describe the defining characteristics behind the relational data model.\n2. Comment on the difference between a foreign key and a superkey.\n3. Enumerate the different types of integrity constraints"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Relational_Relational_Databases.txt", ".\nKA Core:\n4. Compose a relational schema from a conceptual schema which contains 1:1, 1:n, and n:m\nrelationships.\n5. Map appropriate file structure to relations and indices.\n6. Describe how functional dependency theory generalizes the notion of key.\n7. Defend a given decomposition as lossless and or dependency preserving.\n8. Detect which normal form a given decomposition yields.\n9. Comment on reasons for denormalizing a relation."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-SEP_Society_Ethics_and_the_Profession.txt", "Pages: 123\n\nHOURS\n\tCS Core = Included in SEP hours\n\tKA Core = Included in SEP hours"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-SEP_Society_Ethics_and_the_Profession.txt", "DM-SEP: Society, Ethics, and the Profession\nCS Core:\n1. Issues related to scale (See also: SEP-Economies)\n2. Data privacy overall (See also: SEP-Privacy, SEP-Ethical-Analysis)\na. Privacy compliance by design (See also: SEP-Privacy)\n3. Data anonymity (See also: SEP-Privacy)\n4. Data ownership/custodianship (See also: SEP-Professional-Ethics)\n5. Intended and unintended applications of stored data (See also: SEP-Professional-Ethics, SECFoundations)\nKA Core:\n6. Reliability of data (See also: SEP-Security)\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-SEP_Society_Ethics_and_the_Profession.txt", ". Reliability of data (See also: SEP-Security)\n7. Provenance, data lineage, and metadata management (See also: SEP-Professional-Ethics)\n8. Data security (See also: DM-Security, SEP-Security)\nIllustrative Learning Outcomes:\nCS Core:\n1. Enumerate three social and three legal issues related to large data collections.\n2. Describe the value of data privacy.\n3. Identify the competing stakeholders with respect to data ownership.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-SEP_Society_Ethics_and_the_Profession.txt", ".\n4. Enumerate three negative unintended consequences from a given (well known) data-centric\napplication (e.g., Facebook, LastPass, Ashley Madison).\nKA Core:\n5. Describe the meaning of data provenance and lineage.\n6. Identify how a database might contribute to data security as well as how it may introduce\ninsecurities."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Data_The_Role_of_Data_and_the_Data_Life_Cycle.txt", "Pages: 115\n\nHOURS\n\tCS Core = 2\n\tKA Core = 0\n\nDM-Data: The Role of Data and the Data Life Cycle\nCS Core:\n1. The Data Life Cycle: Creation-Processing-Review/Reporting-Retention/Retrieval-Destruction (See\nalso: SEP-Context, SEP-Ethical-Analysis, SEP-Professional-Ethics, SEP-Privacy, SEP-Security,\nSEC-Foundations)\nIllustrative Learning Outcomes:\nCS Core:\n1. Identify the five stages of the Data Life Cycle."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Analytics_Data_Analytics.txt", "Pages: 121-122\n\nHOURS\n\tCS Core = 0\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Analytics_Data_Analytics.txt", "DM-Analytics: Data Analytics\nKA Core:\n1. Exploratory data techniques (motivation, representation, descriptive statistics, visualizations)\n2. Data science lifecycle: business understanding, data understanding, data preparation, modeling,\nevaluation, deployment, and user acceptance (See also: AI-ML)\n3. Data mining and machine learning algorithms: e.g., classification, clustering, association, regression\n(See also: AI-ML)\n4. Data acquisition and governance (See also: SEC-Governance)\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Analytics_Data_Analytics.txt", ". Data security and privacy considerations (See also: SEP-Security, SEP-Privacy, SEC-Foundations)\n6. Data fairness and bias (See also: SEP-Security, AI-SEP)\n7. Data visualization techniques and their use in data analytics (See also: GIT-Visualization)\n8. Entity Resolution\nIllustrative Learning Outcomes:\nKA Core:\n1. Describe several data exploration approaches, including visualization, to understanding unfamiliar\ndatasets.\n2. Apply several data exploration approaches to understanding unfamiliar datasets.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Analytics_Data_Analytics.txt", ".\n3. Describe basic machine learning/data mining algorithms and when they are appropriate for use.\n4. Apply several machine learning/data mining algorithms.\n5. Describe legal and ethical considerations in acquiring, using, and modifying datasets.\n6. Describe issues of fairness and bias in data collection and usage."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Distributed_Distributed_DatabasesCloud_Computing.txt", "Pages: 122\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Distributed_Distributed_DatabasesCloud_Computing.txt", "DM-Distributed: Distributed Databases/Cloud Computing\nNon-core:\n1. Distributed DBMS (See also: PDC-Communications)\na. Distributed data storage\nb. Distributed query processing\nc. Distributed transaction model\nd. Homogeneous and heterogeneous solutions\ne. Client-server distributed databases (See also: NC-Fundamentals)\n2. Parallel DBMS (See also: PDC-Algorithms)\na. Parallel DBMS architectures: shared memory, shared disk, shared nothing;\nb. Speedup and scale-up, e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Distributed_Distributed_DatabasesCloud_Computing.txt", ". Speedup and scale-up, e.g., use of the MapReduce processing model (See also: PDCPrograms, SF-Foundations)\nc. Data replication and weak consistency models (See also: PDC-Coordination)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-NoSQL_NoSQL_Systems.txt", "Pages: 120-121\n\nHOURS\n\tCS Core = 0\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-NoSQL_NoSQL_Systems.txt", "DM-NoSQL: NoSQL Systems\nKA Core:\n1. Why NoSQL? (e.g., Impedance mismatch between Application [CRUD] and RDBMS)\n2. Key-Value and Document data model\nNon-core:\n3. Storage systems (e.g., Key-Value systems, Data Lakes)\n4. Distribution Models (Sharding and Replication) (See also: PDC-Communication)\n5. Graph Databases\n6. Consistency Models (Update and Read, Quorum consistency, CAP theorem) (See also: PDC-\nCommunication)\n7. Processing model (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-NoSQL_NoSQL_Systems.txt", ". Processing model (e.g., Map-Reduce, multi-stage map-reduce, incremental map-reduce) (See also:\nPDC-Communication)\n8. Case Studies: Cloud storage system (e.g., S3); Graph databases; \u201cWhen not to use NoSQL\u201d (See\nalso: SPD-Web)\nIllustrative Learning Outcomes:\nKA Core:\n1. Develop a use case for the use of NoSQL over RDBMS.\n2. Describe the defining characteristics behind Key-Value and Document-based data models."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Unstructured_Semi-structured_and_Unstructured_Databases.txt", "Pages: 122-123\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Unstructured_Semi-structured_and_Unstructured_Databases.txt", "DM-Unstructured: Semi-structured and Unstructured Databases\nNon-core:\n1. Vectorized unstructured data (text, video, audio, etc.) and vector storage\na. TF-IDF Vectorizer with ngram\nb. Word2Vec\nc. Array database or array data type handling\n2. Semi-structured databases (e.g., JSON)\na. Storage\ni. Encoding and compression of nested data types\nb. Indexing\ni. Btree, skip index, Bloom filter\nii. Inverted index and bitmap compression\niii. Space filling curve indexing for semi-structured geo-data\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Unstructured_Semi-structured_and_Unstructured_Databases.txt", ". Query processing for OLTP and OLAP use cases\ni. Insert, Select, update/delete tradeoffs\nii. Case studies on Postgres/JSON, MongoDB, and Snowflake/JSON"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt", "Pages: 116-117\n\nHOURS\n\tCS Core = 2\n\tKA Core = 3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt", "DM-Modeling: Data Modeling\nCS Core:\n1. Data modeling (See also: SE-Requirements)\n2. Relational data model (See also: MSF-Discrete)\nKA Core:\n3. Conceptual models (e.g., entity-relationship, UML diagrams)\n4. Semi-structured data models (expressed using DTD, XML, or JSON Schema, for example)\nNon-core:\n5. Spreadsheet models\n6. Object-oriented models (See also: FPL-OOP)\na. GraphQL\n7. New features in SQL\n8. Specialized Data Modeling topics\na. Time series data (aggregation, join)\nb. Graph data (link traversal)\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt", ". Graph data (link traversal)\nc. Techniques for avoiding inefficient raw data access (e.g., \u201cavg daily price\u201d): materialized views\nand special data structures (e.g., Hyperloglog, bitmap)\nd. Geo-Spatial data (e.g., GIS databases) (See also: SPD-Interactive)\nIllustrative Learning Outcomes:\nCS Core:\n1. Describe the components of the relational data model.\n2. Model 1:1, 1:n, and n:m relationships using the relational data model.\nKA Core:\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Modeling_Data_Modeling.txt", ".\nKA Core:\n3. Describe the components of the E-R (or some other non-relational) data model.\n4. Model a given environment using a conceptual data model.\n5. Model a given environment using the document-based or key-value store-based data model."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Core_Core_Database_System_Concepts.txt", "Pages: 115-116\n\nHOURS\n\tCS Core = 2\n\tKA Core = 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Core_Core_Database_System_Concepts.txt", "DM-Core: Core Database System Concepts\nCS Core:\n1. Purpose and advantages of database systems\n2. Components of database systems\n3. Design of core DBMS functions (e.g., query mechanisms, transaction management, buffer\nmanagement, access methods)\n4. Database architecture, data independence, and data abstraction\n5. Transaction management\n6. Normalization\n7. Approaches for managing large volumes of data (e.g., NoSQL database systems, use of\nMapReduce) (See also: PDC-Algorithms)\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Core_Core_Database_System_Concepts.txt", ". How to support CRUD-only applications\n9. Distributed databases/cloud-based systems\n10. Structured, semi-structured, and unstructured data\n11. Use of a declarative query language\nKA Core:\n12. Systems supporting structured and/or stream content\nIllustrative Learning Outcomes:\nCS Core:\n1. Identify at least four advantages that using a database system provides.\n2. Enumerate the components of a (relational) database system.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Core_Core_Database_System_Concepts.txt", ".\n3. Follow a query as it is processed by the components of a (relational) database system.\n4. Defend the value of data independence.\n5. Compose a simple select-project-join query in SQL.\n6. Enumerate the four properties of a correct transaction manager.\n7. Describe the advantages for eliminating duplicate repeated data.\n8. Outline how MapReduce uses parallelism to process data efficiently.\n9. Evaluate the differences between structured and semi/unstructured databases."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Internals_DBMS_Internals.txt", "Pages: 119-120\n\nHOURS\n\tCS Core = 0\n\tKA Core = 4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Internals_DBMS_Internals.txt", "DM-Internals: DBMS Internals\nKA Core:\n1. DB Buffer Management (See also: OS-Memory, SF-Resource)\n2. Transaction Management (See also: PDC-Coordination)\na. Isolation Levels\nb. ACID\nc. Serializability\nd. Distributed Transactions\n3. Concurrency Control: (See also: OS-Concurrency)\na. 2-Phase Locking\nb. Deadlocks handling strategies\nc. Quorum-based consistency models\n4. Recovery Manager\na. Relation with Buffer Manager\nNon-core:\n5. Concurrency Control:\na. Optimistic concurrency control\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Internals_DBMS_Internals.txt", ". Optimistic concurrency control\nb. Timestamp concurrency control\n6. Recovery Manager\na. Write-Ahead logging\nb. ARIES recovery system (Analysis, REDO, UNDO)\nIllustrative Learning Outcomes:\nKA Core:\n1. Describe how a DBMS manages its Buffer Pool.\n2. Describe the four properties for a correct transaction manager.\n3. Outline the principle of serializability."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt", "Pages: 118\n\nHOURS\n\tCS Core = 2\n\tKA Core = 4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt", "DM-Querying: Query Construction\nCS Core:\n1. SQL Query Formation\na. Interactive SQL execution\nb. Programmatic execution of an SQL query\nKA Core:\n2. Relational Algebra\n3. SQL\na. Data definition including integrity and other constraint specifications\nb. Update sublanguage\nNon-core:\n4. Relational Calculus\n5. QBE and 4th-generation environments\n6. Different ways to invoke non-procedural queries in conventional languages\n7. Introduction to other major query languages (e.g., XPATH, SPARQL)\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Date_Management_DM/DM-Querying_Query_Construction.txt", ".g., XPATH, SPARQL)\n8. Stored procedures\nIllustrative Learning Outcomes:\nCS Core:\n1. Compose SQL queries that incorporate select, project, join, union, intersection, set difference, and\nset division.\n2. Determine when a nested SQL query is correlated or not.\n3. Iterate over data retrieved programmatically from a database via an SQL query.\nKA Core:\n4. Define, in SQL, a relation schema, including all integrity constraints and delete/update triggers.\n5. Compose an SQL query to update a tuple in a relation."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt", "Pages: 150-151\nHOURS\n    CS Core = 3\n    KA Core = 2\n\nGIT-Fundamentals: Fundamental Concepts\nCS Core:\n1. Overview of graphics and visualization.\n2. Basic graphics pipeline architecture.\n3. 2D and 3D transformations.\n4. Rasterization and rendering techniques.\n5. Fundamental shading models.\n\nKA Core:\n6. Advanced rendering techniques.\n7. Applications of visualization in different fields.\n8. Interaction methods for graphical environments."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Fundamentals.txt", "Illustrative Learning Outcomes:\n1. Explain the graphics rendering pipeline.\n2. Differentiate between rasterization and ray tracing.\n3. Apply transformations to 2D and 3D models."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Interaction_Design.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nGIT-Interaction Design: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of GIT-Interaction Design.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Augmented_Reality.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nGIT-Augmented Reality: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of GIT-Augmented Reality.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Virtual_Reality.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nGIT-Virtual Reality: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of GIT-Virtual Reality.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Game_Design.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nGIT-Game Design: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of GIT-Game Design.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Animation_and_Simulation.txt", "Pages: 152-153\nHOURS\n    CS Core = 3\n    KA Core = 2\n\nGIT-Animation and Simulation: Core Principles\nCS Core:\n1. Key concepts in animation and simulation.\n2. Procedural animation and physics-based modeling.\n3. Motion capture techniques and keyframe animation.\n4. Real-time simulation techniques for interactive applications.\n\nKA Core:\n5. AI-based animation and behavioral modeling.\n6. Crowd simulation and group behaviors in animations.\n7. Advanced physics-based simulations."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Animation_and_Simulation.txt", "Illustrative Learning Outcomes:\n1. Apply keyframe animation techniques to an interactive application.\n2. Differentiate between procedural and AI-driven animation.\n3. Understand the role of physics in real-time simulations."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-3D_Modeling.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nGIT-3D Modeling: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of GIT-3D Modeling.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Graphics_and_Interactive_Techniques_GIT/GIT-Rendering_and_Shaders.txt", "Pages: TBD\nHOURS\n    CS Core = TBD\n    KA Core = TBD\n\nGIT-Rendering and Shaders: Core Concepts\nCS Core:\n1. Placeholder topic 1\n2. Placeholder topic 2\n3. Placeholder topic 3\n\nKA Core:\n4. Placeholder advanced topic 1\n5. Placeholder advanced topic 2\n\nIllustrative Learning Outcomes:\n1. Explain key concepts of GIT-Rendering and Shaders.\n2. Apply principles in practical scenarios.\n3. Analyze the importance of this topic in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accessibility_Accessibility_and_Inclusive_Design.txt", "Pages: 177-178\n\nHOURS\n\tCS Core = 2\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accessibility_Accessibility_and_Inclusive_Design.txt", "HCI-Accessibility: Accessibility and Inclusive Design\nCS Core:\n1. Background (See also: SEP-DEIA, SEP-Security)\na. Societal and legal support for and obligations to people with disabilities\nb. Accessible design benefits everyone\n2. Techniques\na. Accessibility standards (e.g., Web Content Accessibility Guidelines) (See also: SPD-Web)\n3. Technologies (See also: SE-Tools)\na. Features and products that enable accessibility and support inclusive development by\ndesigners and engineers\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accessibility_Accessibility_and_Inclusive_Design.txt", ". IDFs (Inclusive Design Frameworks) (See also: SEP-DEIA)\na. Recognizing differences\n5. Universal design\nKA Core:\n6. Background\na. Demographics and populations (permanent, temporary, and situational disability)\nb. International perspectives on disability (See also: SEP-DEIA)\nc. Attitudes towards people with disabilities (See also: SEP-DEIA)\n7. Techniques\na. UX (user experience) design and research\nb. Software engineering practices that enable inclusion and accessibility. (See also: SEP-DEIA)\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accessibility_Accessibility_and_Inclusive_Design.txt", ". (See also: SEP-DEIA)\n8. Technologies\na. Examples of accessibility-enabling features, such as conformance to screen readers\n9. Inclusive Design Frameworks\na. Creating inclusive processes such as participatory design\nb. Designing for larger impact\nNon-core:\n10. Background (See also: SEP-DEIA)\na. Unlearning and questioning\nb. Disability studies\n11. Technologies: the Return On Investment (ROI) of inclusion\n12. Inclusive Design Frameworks: user-sensitive inclusive design (See also: SEP-DEIA)\n13"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accessibility_Accessibility_and_Inclusive_Design.txt", ". Critical approaches to HCI (e.g., inclusivity) (See also: SEP-DEIA)\nIllustrative Learning Outcomes:\nCS Core:\n1. Identify accessibility challenges faced by people with different disabilities and specify the associated\naccessible and assistive technologies that address them. (See also: AI-Agents, AI-Robotics)\n2. Identify appropriate inclusive design approaches, such as universal design and ability-based\ndesign.\n3. Identify and demonstrate understanding of software accessibility guidelines.\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accessibility_Accessibility_and_Inclusive_Design.txt", ".\n4. Demonstrate recognition of laws and regulations applicable to accessible design.\nKA Core:\n5. Apply inclusive frameworks to design, such as universal design and usability and ability-based\ndesign, and demonstrate accessible design of visual, voice-based, and touch-based UIs.\n6. Demonstrate understanding of laws and regulations applicable to accessible design.\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accessibility_Accessibility_and_Inclusive_Design.txt", ".\n7. Demonstrate understanding of what is appropriate and inappropriate high level of skill during\ninteraction with individuals from diverse populations.\n8. Analyze web pages and mobile apps for current standards of accessibility.\nNon-core:\n9. Biases towards disability, race, and gender have historically, either intentionally or unintentionally,\ninformed technology design.\na. Find examples.\nb. Consider how those experiences (learnings?) might inform design.\n10"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accessibility_Accessibility_and_Inclusive_Design.txt", ".\n10. Conceptualize user experience research to identify user needs and generate design insights."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt", "Pages: 178-179\n\nHOURS\n\tCS Core = 1\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt", "HCI-Evaluation: Evaluating the Design\nCS Core:\n1. Methods for evaluation with users\na. Formative (e.g., needs-finding, exploratory analysis) and summative assessment (e.g.,\nfunctionality and usability testing)\nb. Elements to evaluate (e.g., utility, efficiency, learnability, user satisfaction, affective elements\nsuch as pleasure and engagement)\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt", ". Understanding ethical approval requirements before engaging in user research (See also: SETools, SEP-Ethical-Analysis, SEP-Security, SEP-Privacy, SEP-Professional-Ethics)\nKA Core:\n2. Methods for evaluation with users (See also: SE-Validation)\na. Qualitative methods (qualitative coding and thematic analysis)\nb. Quantitative methods (statistical tests)\nc. Mixed methods (e.g., observation, think-aloud, interview, survey, experiment)\nd. Presentation requirements (e.g., reports, personas)\ne"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt", ".g., reports, personas)\ne. User-centered testing\nf. Heuristic evaluation\ng. Challenges and shortcomings to effective evaluation (e.g., sampling, generalization)\n3. Study planning\na. How to set study goals\nb. Hypothesis design\nc. Approvals from Institutional Research Boards and ethics committees (See also: SEP-EthicalAnalysis, SEP-Security, SEP-Privacy)\nd. How to pre-register a study\ne. Within-subjects vs between-subjects design\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt", ". Within-subjects vs between-subjects design\n4. Implications and impacts of design with respect to the environment, material, society, security,\nprivacy, ethics, and broader impacts. (See also: SEC-Foundations)\na. The environment\nb. Material\nc. Society\nd. Security\ne. Privacy\nf. Ethics\ng. Broader impacts\nNon-core:\n5. Techniques and tools for quantitative analysis\na. Statistical packages\nb. Visualization tools\nc. Statistical tests (e.g., ANOVA, t-tests, post-hoc analysis, parametric vs non-parametric tests)\nd"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt", ". Data exploration and visual analytics; how to calculate effect size.\n6. Data management\na. Data storage and data sharing (open science)\nb. Sensitivity and identifiability.\nIllustrative Learning Outcomes:\nCS Core:\n1. Discuss the differences between formative and summative assessment and their role in evaluating\ndesign\nKA Core:\n2. Select appropriate formative or summative evaluation methods at different points throughout the\ndevelopment of a design.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt", ".\n3. Discuss the benefits of using both qualitative and quantitative methods for evaluation.\n4. Evaluate the implications and broader impacts of a given design.\n5. Plan a usability evaluation for a given user interface, and justify its study goals, hypothesis design,\nand study design.\n6. Conduct a usability evaluation of a given user interface and draw defensible conclusions given the\nstudy design.\nNon-core:\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Evaluation_Evaluating_the_Design.txt", ".\nNon-core:\n7. Select and run appropriate statistical tests on provided study data to test for significance in the\nresults.\n8. Pre-register a study design, with planned statistical tests"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-User_Understanding_the_User_Individual_goals_and_interactions_with_others.txt", "Pages: 174-175\n\nHOURS\n\tCS Core = 2\n\tKA Core = 5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-User_Understanding_the_User_Individual_goals_and_interactions_with_others.txt", "HCI-User: Understanding the User: Individual goals and interactions with others\nCS Core:\n1. User-centered design and evaluation methods. (See also: SEP-Context, SEP-Ethical-Analysis,\nSEP-Professional-Ethics)\na. \u201cYou are not the users\u201d\nb. User needs-finding\nc. Formative studies\nd. Interviews\ne. Surveys\nf. Usability tests\nKA Core:\n2. User-centered design methodology. (See also: SE-Tools)\na. Personas/persona spectrum\nb. User stories/storytelling and techniques for gathering stories\nc. Empathy maps\nd"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-User_Understanding_the_User_Individual_goals_and_interactions_with_others.txt", ". Empathy maps\nd. Needs assessment (techniques for uncovering needs and gathering requirements - e.g.,\ninterviews, surveys, ethnographic and contextual enquiry) (See also: SE-Requirements)\ne. Journey maps\nf. Evaluating the design (See also: HCI-Evaluation)\ng. Interfacing with stakeholders, as a team\nh. Risks associated with physical, distributed, hybrid and virtual teams\n3. Physical and cognitive characteristics of the user\na. Physical capabilities that inform interaction design (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-User_Understanding_the_User_Individual_goals_and_interactions_with_others.txt", ".g., color perception, ergonomics)\nb. Cognitive models that inform interaction design (e.g., attention, perception and recognition,\nmovement, memory)\nc. Topics in social/behavioral psychology (e.g., cognitive biases, change blindness)\n4. Designing for diverse user populations. (See also: SEP-DEIA, HCI-Accessibility)\na. How differences (e.g., in race, ability, age, gender, culture, experience, and education)\nimpact user experiences and needs\nb. Internationalization\nc"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-User_Understanding_the_User_Individual_goals_and_interactions_with_others.txt", ". Internationalization\nc. Designing for users from other cultures\nd. Cross-cultural design\ne. Challenges to effective design evaluation. (e.g., sampling, generalization; disability and\ndisabled experiences)\nf. Universal design\n5. Collaboration and communication (See also: AI-SEP, SE-Teamwork, SEP-Communication, SPDGame)\na. Understanding the user in a multi-user context\nb. Synchronous group communication (e.g., chat rooms, conferencing, online games)\nc. Asynchronous group communication (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-User_Understanding_the_User_Individual_goals_and_interactions_with_others.txt", ". Asynchronous group communication (e.g., email, forums, social networks)\nd. Social media, social computing, and social network analysis\ne. Online collaboration\nf. Social coordination and online communities\ng. Avatars, characters, and virtual worlds\nNon-core:\n6. Multi-user systems\nIllustrative Learning Outcomes:\nCS Core:\n1. Conduct a user-centered design process that is integrated into a project.\nKA Core:\n2. Compare and contrast the needs of users with those of designers.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-User_Understanding_the_User_Individual_goals_and_interactions_with_others.txt", ".\n3. Identify the representative users of a design and discuss who else could be impacted by it.\n4. Describe empathy and evaluation as elements of the design process.\n5. Carry out and document an analysis of users and their needs.\n6. Construct a user story from a needs assessment.\n7. Redesign an existing solution to a population whose needs differ from those of the initial target\npopulation.\n8. Contrast the different needs-finding methods for a given design problem.\n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-User_Understanding_the_User_Individual_goals_and_interactions_with_others.txt", ".\n9. Reflect on whether your design would benefit from low-tech or no-tech components.\nNon-core:\n10. Recognize the implications of designing for a multi-user system/context."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-SEP_Society_Ethics_and_the_Profession.txt", "Pages: 181-182"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-SEP_Society_Ethics_and_the_Profession.txt", "HOURS\n\tCS Core = 1\n\tKA Core = 2\nHCI-SEP: Society, Ethics, and the Profession\nCS Core:\n1. Universal and user-centered design (See also: HCI-User, SEP-DEIA)\n2. Accountability (See also: HCI-Accountability)\n3. Accessibility and inclusive design (See also: SEP-DEIA, SEP-Security)\n4. Evaluating the design (See also: HCI-Evaluation)\n5. System design (See also: HCI-Design)\nKA Core:\n6. Participatory and inclusive design processes\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-SEP_Society_Ethics_and_the_Profession.txt", ". Participatory and inclusive design processes\n7. Evaluating the design: Implications and impacts of design: with respect to the environment,\nmaterial, society, security, privacy, ethics, and broader impacts (See also: SEC-Foundations, SEPPrivacy)\nNon-core:\n8. VR/AR/MR scenarios\nIllustrative Learning Outcomes:\nCS Core:\n1. Conduct a user-centered design process that is integrated into a project.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-SEP_Society_Ethics_and_the_Profession.txt", ".\n2. Identify and critique the potential impacts of a design on society and relevant communities to\naddress such concerns as sustainability, inclusivity, safety, security, privacy, harm, and disparate\nimpact.\nKA Core:\n2. Critique a recent example of a non-inclusive design choice, its societal implications, and propose\npotential design improvements.\n3. Evaluating the design: Identify the implications and broader impacts of a given design.\nNon-core:\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-SEP_Society_Ethics_and_the_Profession.txt", ".\nNon-core:\n4. Evaluate the privacy implications within a VR/AR/MR scenario."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Design_System_Design.txt", "Pages: 179-181\n\nHOURS\n\tCS Core = Included in SEP hours\n\tKA Core = Included in SEP hours"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Design_System_Design.txt", "HCI-Design: System Design\nCS Core:\n1. Prototyping techniques and tools\na. Low-fidelity prototyping\nb. Rapid prototyping\nc. Throw-away prototyping\nd. Granularity of prototyping\n2. Design patterns\na. Iterative design\nb. Universal design (See also: SEP-DEIA)\nc. Interaction design (e.g., data-driven design, event-driven design)\n3. Design constraints\na. Platforms (See also: SPD-Game)\nb. Devices\nc. Resources\nd. Balance among usability, security and privacy (See also: SEC-Foundations)\nKA Core:\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Design_System_Design.txt", ". Design patterns and guidelines\na. Software architecture patterns\nb. Cross-platform design\nc. Synchronization considerations\n5. Design processes (See also: SEP-Communication)\na. Participatory design\nb. Co-design\nc. Double-diamond\nd. Convergence and divergence\n6. Interaction techniques (See also: GIT-Interaction)\na. Input and output vectors (e.g., gesture, pose, touch, voice, force)\nb. Graphical user interfaces\nc. Controllers\nd. Haptics\ne. Hardware design\nf. Error handling\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Design_System_Design.txt", ". Haptics\ne. Hardware design\nf. Error handling\n7. Visual UI design (See also: GIT-Visualization)\na. Color\nb. Layout\nc. Gestalt principles\nNon-core:\n8. Immersive environments (See also: GIT-Immersion)\na. XR (encompasses virtual reality, augmented reality, and mixed reality)\nb. Spatial audio\n9. 3D printing and fabrication\n10. Asynchronous interaction models\n11. Creativity support tools\n12. Voice UI designs\nIllustrative Learning Outcomes:\nCS Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Design_System_Design.txt", ". Propose system designs tailored to a specified appropriate mode of interaction.\n2. Follow an iterative design and development process that incorporates the following:\na. Understanding the user\nb. Developing an increment\nc. Evaluating the increment\nd. Feeding those results into a subsequent iteration\n3. Explain the impact of changing constraints and design tradeoffs (e.g., hardware, user, security.) on\nsystem design.\nKA Core:\n4. Evaluate architectural design approaches in the context of project goals.\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Design_System_Design.txt", ".\n5. Identify synchronization challenges as part of the user experience in distributed environments.\n6. Evaluate and compare the privacy implications behind different input techniques for a given\nscenario.\n7. Explain the rationale behind a UI design based on visual design principles.\nNon-core:\n8. Evaluate the privacy implications within a VR/AR/MR scenario"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accountability_Accountability_and_Responsibility_in_Design.txt", "Pages: 176\n\nHOURS\n\tCS Core = 2\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accountability_Accountability_and_Responsibility_in_Design.txt", "HCI-Accountability: Accountability and Responsibility in Design\nCS Core: (See also: SEP-Context)\n1. Design impact\na. Sustainability (See also: SEP-Sustainability)\nb. Inclusivity (See also: SEP-DEIA)\nc. Safety, security and privacy (See also: SEP-Security, SEC-Foundations)\nd. Harm and disparate impact (See also: SEP-DEIA)\n2. Ethics in design methods and solutions (See also: SEP-Ethical-Analysis, SEP-Context, SEPIntellectual Property)\na. The role of artificial intelligence (See also: AI-SEP)\nb"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accountability_Accountability_and_Responsibility_in_Design.txt", ". Responsibilities for considering stakeholder impact and human factors (See also: SEPProfessional-Ethics)\nc. Role of design to meet user needs\n3. Requirements in design (See also: SEP-Professional-Ethics)\na. Ownership responsibility\nb. Legal frameworks, compliance requirements\nc. Consideration beyond immediate user needs, including via iterative reconstruction of\nproblem analysis and \u201cdigital well-being\u201d features\nKA Core:\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accountability_Accountability_and_Responsibility_in_Design.txt", ". Value-sensitive design (See also: SEP-Ethical-Analysis, SEP-Context, SEP-Communication)\na. Identify direct and indirect stakeholders\nb. Determine and include diverse stakeholder values and value systems.\n5. Persuasion through design (See also: SEP-Communication)\na. Assess the persuasive content of a design\nb. Employ persuasion as a design goal\nc. Distinguish persuasive interfaces from manipulative interfaces\nIllustrative Learning Outcomes:\nCS Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accountability_Accountability_and_Responsibility_in_Design.txt", ". Identify and critique the potential impacts of a design on society and relevant communities to\naddress such concerns as sustainability, inclusivity, safety, security, privacy, harm, and disparate\nimpact.\nKA Core:\n2. Identify the potential human factor elements in a design.\n3. Identify and understand direct and indirect stakeholders.\n4. Develop scenarios that consider the entire lifespan of a design, beyond the immediately planned\nuses that anticipate direct and indirect stakeholders.\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Human_Computer_Interaction_HCI/HCI-Accountability_Accountability_and_Responsibility_in_Design.txt", ".\n5. Identify and critique the potential factors in a design that impact direct and indirect stakeholders and\nbroader society (e.g., transparency, sustainability of the system, trust, artificial intelligence).\n6. Assess the persuasive content of a design and its intent relative to user interests.\n7. Critique the outcomes of a design given its intent.\n8. Understand the impact of design decisions."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Software_Development_Practices.txt", "Pages : 170-171\nCS Core : 5, KA Core : None\n\nCS Core: (See also: SE-Construction) \n1. Basic testing, including test case design \n2. Use of a general-purpose IDE, including its debugger \n3. Programming style that improves readability  \n4. Specifying functionality of a module in a natural language."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Software_Development_Practices.txt", "Illustrative Learning Outcomes: \nCS Core: \n1. Develop tests for modules and apply a variety of strategies to design test cases. \n2. Explain some limitations of testing programs. \n3. Build, execute, and debug programs using a modern IDE and associated tools such as visual debuggers.   \n4. Apply basic programming style guidelines to aid readability of programs such as comments, indentation, proper naming of variables, etc. \n5. Write specifications of a module as module comment describing its functionality."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt", "Pages : 171\nCS Core : None, KA Core : None\n(Hours here are included in Society, Ethics and the Profession Area)\n\nCS Core: \n1. Intellectual property rights of programmers for programs they develop. \n2. Plagiarism and academic integrity. \n3. Responsibility and liability of programmers regarding code they develop for solutions. (See also: SEC-Foundations) \n4. Basic professional work ethics of programmers."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Society_Ethics_and_the_Profession.txt", "Illustrative Learning Outcomes: \nCS Core: \n1. Explain/understand some of the intellectual property issues relating to programs.  \n2. Explain/understand when code developed by others can be used and proper ways of disclosing their use. \n3. Explain/understand the responsibility of programmers when developing code for an overall solution (which may be developed by a team). \n4. Explain/understand one or more codes of conduct applicable to programmers."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt", "Page : 170\nCS Core : 6, KA Core : None\n\nCS Core: (See also: AL-Foundational, AL-Complexity) \n1. Concept of algorithm and notion of algorithm efficiency \n2. Some common algorithms (e.g., sorting, searching, tree traversal, graph traversal) \n3. Impact of algorithms on time-space efficiency of programs"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Algorithms.txt", "Illustrative Learning Outcomes: \nCS Core: \n1. Explain the role of algorithms for writing programs.  \n2. Demonstrate how a problem may be solved by different algorithms, each with different properties. \n3. Explain some common algorithms (e.g., sorting, searching, tree traversal, graph traversal). \n4. Explain the impact on space/time performance of some algorithms."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Data_Structures.txt", "Pages : 169-170\nCS Core : 12, KA Core : None\n\nCS Core: (See also: AL-Foundational) \n1. Standard abstract data types such as lists, stacks, queues, sets, and maps/dictionaries, including operations on them.   \n2. Selecting and using appropriate data structures. \n3. Performance implications of choice of data structure(s). \n4. Strings and string processing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Data_Structures.txt", "Illustrative Learning Outcomes: \nCS Core: \n1. Write programs that use each of the key abstract data types provided in the language (e.g., arrays, tuples/records/structs, lists, stacks, queues, and associative data types like sets, dictionaries/maps). \n2. Select the appropriate data structure for a given problem.  \n3. Explain how the performance of a program may change when using different data structures or operations. \n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Data_Structures.txt", ". \n4. Write programs that work with text by using string processing capabilities provided by the language."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt", "Pages : 168-169\nCS Core : 20, KA Core : None"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt", "CS Core: \n1. Basic concepts such as variables, primitive data types, expressions, and their evaluation \n2. How imperative programs work: state and state transitions on execution of statements, flow of control \n3. Basic constructs such as assignment statements, conditional and iterative statements, basic I/O  \n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt", ". Key modularity constructs such as functions (and methods and classes, if supported in the language) and related concepts like parameter passing, scope, abstraction, data encapsulation (See also: FPL-OOP)\n5. Input and output using files and APIs \n6. Structured data types available in the chosen programming language like sequences (e.g., arrays, lists), associative containers (e.g., dictionaries, maps), others (e.g., sets, tuples) and when and how to use them (See also: AL-Foundational) \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt", ". Libraries and frameworks provided by the language (when/where applicable) \n8. Recursion \n9. Dealing with runtime errors in programs (e.g., exception handling). \n10. Basic concepts of programming errors, testing, and debugging (See also:  SE-Construction, SEC-Coding)  \n11. Documenting/commenting code at the program and module level.(See also:  SE-Construction)   \n12. Develop a security mindset. (See also: SEC-Foundations)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt", "Illustrative Learning Outcomes:\nCS Core:           \nIn these learning outcomes, the term \"develop\" means \"design, write, test, and debug.\" \n1. Develop programs that use the fundamental programming constructs: assignment and expressions, basic I/O, conditional and iterative statements. \n2. Develop programs using functions with parameter passing.  \n3. Develop programs that effectively use the different structured data types provided in the language like arrays/lists, dictionaries, and sets. \n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt", ". \n4. Develop programs that use file I/O to provide data persistence across multiple executions.  \n5. Develop programs that use language-provided libraries and frameworks (where applicable).  \n6. Develop programs that use APIs to access or update data (e.g., from the web).  \n7. Develop programs that create simple classes and instantiate objects of those classes (if supported by the language). \n8. Explain the concept of recursion and identify when and how to use it effectively. \n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Software_Development_Fundamentals_SDF/SDF-Fundamental_Programming_Concepts_and_Practices.txt", ". \n9. Develop recursive functions. \n10. Develop programs that can handle runtime errors. \n11. Read a given program and explain what it does. \n12. Write comments for a program or a module specifying what it does. \n13. Trace the flow of control during the execution of a program.  \n14. Use appropriate terminology to identify elements of a program (e.g., identifier, operator, operand)."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Communication.txt", "Pages : 217-218\nCS Core : 2, KA Core : 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Communication.txt", "Computing is an inherently collaborative and social discipline making communication an essential aspect of the profession. Much but not all of this communication occurs in a professional setting where communication styles, expectations, and norms differ from other contexts where similar technology  might be used. Both professional and informal communication conveys information to various audiences who may have different goals and needs for that information"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Communication.txt", ". Good communication is also necessary for transparency and trustworthiness. It is also important to note that computing professionals are not just communicators but are also listeners who must be able to hear and thoughtfully make use of feedback received from various stakeholders. Effective communication skills are not something one \u2018just knows\u2019 \u2013 they are developed and can be learned. Communication skills are best taught in context throughout the undergraduate curriculum."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Communication.txt", "CS Core: \n1. Oral, written, and electronic team and group communication \n2. Technical communication materials (e.g., source code, and documentation, tutorials, reference materials, API documentation) \n3. Communicating with different stakeholders such as customers, leadership, or the public \n4. Team collaboration (including tools) and conflict resolution \n5. Accessibility and inclusivity requirements for addressing professional audiences \n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Communication.txt", ". Cultural competence in communication including considering the impact of difference in natural language \n \nKA Core: \n7. Tradeoffs in competing factors that affect communication channels and choices \n8. Communicating to solve problems or make recommendations in the workplace, such as raising ethical concerns or addressing accessibility issues \n \nIllustrative Learning Outcomes: \nCS Core: \n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Communication.txt", ". Understand the importance of writing concise and accurate technical documents following well-defined standards for format and for including appropriate tables, figures, and references.  \n2. Analyze written technical documentation for technical accuracy, concision, lack of ambiguity, and awareness of audience.  \n3. Compose and deliver an audience-aware, accessible, and organized formal presentation.  \n4. Plan interactions (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Communication.txt", ".  \n4. Plan interactions (e.g., virtual, face-to-face, shared documents) with others in ways that invite inclusive participation, model respectful consideration of others\u2019 contributions, and explicitly value diversity of ideas.  \n5. Identify and describe qualities of effective communication (e.g., virtual, face-to-face, intragroup, shared documents).  \n6. Understand how to communicate effectively and appropriately as a member of a team including conflict resolution techniques.  \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Communication.txt", ".  \n7. Discuss ways to influence performance and results in diverse and cross-cultural teams.  \n \nKA Core: \n8. Assess personal strengths and weaknesses to work remotely as part of a team drawing from diverse backgrounds and experiences.  \n9. Choose an appropriate way to communicate delicate ethical concerns."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Social_Context.txt", "Pages : 211-212\nCS Core : 3, KA Core : 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Social_Context.txt", "Computers, the internet, and artificial intelligence - perhaps more than any other technologies - have transformed society over the past several decades, with dramatic increases in human productivity; an explosion of options for news, entertainment, and communication; and fundamental breakthroughs in almost every branch of science and engineering. It is imperative to recognize that this is not a one-way street"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Social_Context.txt", ". Society also affects computing, resulting in a complex socio-technical context that is constantly changing, requiring the perspective of history to put the present as well as the possible future into appropriate perspective.  \nSocial Context provides the foundation for all other knowledge units in SEP, particularly Professional Ethics."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Social_Context.txt", "CS Core: \n1. Social implications (e.g., political and cultural ideologies) in a hyper-networked world where the capabilities and impact of social media, artificial intelligence, and computing in general are rapidly evolving. \n2. Impact of computing applications (e.g., social media, artificial intelligence applications) on individual well-being, and safety of all kinds (e.g., physical, emotional, economic). \n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Social_Context.txt", ".g., physical, emotional, economic). \n3. Consequences of involving computing technologies, particularly artificial intelligence, biometric technologies, and algorithmic decision-making systems, in civic life (e.g., facial recognition technology, biometric tags, resource distribution algorithms, policing software) and how human agency and oversight is crucial. \n4. How deficits in diversity and accessibility in computing affect society and what steps can be taken to improve equity in computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Social_Context.txt", "KA Core: \n5. Growth and control of the internet, data, computing, and artificial intelligence \n6. Often referred to as the digital divide, differences in access to digital technology resources and its resulting ramifications for gender, class, ethnicity, geography, and/or developing countries, including consideration of responsibility to those who might be less wealthy, under threat, or who would struggle to have their voices heard. \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Social_Context.txt", ". \n7. Accessibility issues, including legal requirements such as Web Content Accessibility Guidelines (www.w3.org/TR/WCAG21) \n8. Context-aware computing  \n \nIllustrative Learning Outcomes: \nCS Core: \n1. Describe the different ways that computer technology (networks, mobile computing, artificial intelligence) mediates social interaction at the personal and collective levels. \n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Social_Context.txt", ". \n2. Identify developers\u2019 assumptions and values embedded in hardware and software design, especially as they pertain to usability for diverse populations including under-served and those with disabilities.  \n3. Interpret the social context of a given design and its implementation.  \n4. Analyze the efficacy of a given design and implementation using empirical data.  \n5. Understand the implications of technology use (e.g., social media) for different identities, cultures, and communities. \n \nKA Core: \n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Social_Context.txt", ". \n \nKA Core: \n6. Describe the internet\u2019s role in facilitating communication between citizens, governments, and each other.  \n7. Analyze the effects of reliance on computing in the implementation of democracy (e.g., delivery of social services, electronic voting).  \n8. Describe the impact of a lack of appropriate representation of people from historically minoritized populations in the computing profession (e.g., industry culture, product diversity).  \n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Social_Context.txt", ".g., industry culture, product diversity).  \n9. Discuss the implications of context awareness in ubiquitous computing systems.  \n10. Express how access to the internet and computing technologies affect different societies.  \n11. Identify why/how internet access can be viewed as a human right."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Sustainability.txt", "Pages : 219-220\nCS Core : 1, KA Core : 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Sustainability.txt", "Sustainability is defined by the United Nations as \u201cdevelopment that meets the needs of the present without compromising the ability of future generations to meet their own needs.\u201d [12] Alternatively, it is the \u201cbalance between the environment, equity and economy.\u201d [13] As computing extends into more and more aspects of human existence, we are already seeing estimates that double-digit percentages of global electricity usage are consumed by computing activities, which unchecked will likely grow"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Sustainability.txt", ". Further, electronics contribute individually to demand for rare earth elements, mineral extraction, and countless e-waste concerns. Students should gain a background that recognizes these global and environmental costs and their potential long-term effects on the environment and local communities."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Sustainability.txt", "CS Core: \n1. Environmental, social, and cultural impacts of implementation decisions (e.g., sustainability goals, algorithmic bias/outcomes, economic viability, and resource consumption) \n2. Local/regional/global social and environmental impacts of computing systems and their use (e.g.,carbon footprints, resource usage, e-waste) due to hardware (e.g., e-waste, data centers, rare element and resource utilization, recycling) and software (e.g., cloud-based services, blockchain, AI model training and use)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Sustainability.txt", ". This includes everyday use of hardware (cheap hardware replaced frequently) and software (web-browsing, email, and other services with hidden/remote computational demands). \n3. Guidelines for sustainable design standards. \n \nKA Core: \n4. Systemic effects of complex computing technologies and phenomena (e.g., generative AI, data centers, social media, offshoring, remote work). \n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Sustainability.txt", ". \n5. Pervasive computing: Information processing that has been integrated into everyday objects and activities, such as smart energy systems, social networking, and feedback systems to promote sustainable behavior, transportation, environmental monitoring, citizen science and activism. \n6. How the sustainability of software systems is interdependent with social systems, including the knowledge and skills of its users, organizational processes and policies, and its societal context (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Sustainability.txt", ".g., market forces, government policies). \n \nIllustrative Learning Outcomes: \nCS Core: \n1. Identify ways to be a sustainable practitioner in a specific area or with a specific project.  \n2. Assess the environmental impacts of a given project\u2019s deployment (e.g., energy consumption, contribution to e-waste, impact of manufacturing).  \n3. Describe global social and environmental impacts of computer use and disposal.  \n4. List the sustainable effects of modern practices and activities (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Sustainability.txt", ".g., remote work, e-commerce, cryptocurrencies, AI models, data centers). \n \nKA Core: \n5. Describe the environmental impacts of design choices within the field of computing that relate to algorithm design, operating system design, networking design, database design, etc.  \n6. Analyze the social and environmental impacts of new system designs.  \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Sustainability.txt", ".  \n7. Design guidelines for sustainable IT design or deployment in areas such as smart energy systems, social networking, transportation, agriculture, supply-chain systems, environmental monitoring, and citizen activism.  \n8. Assess computing applications in respect to environmental issues (e.g., energy, pollution, resource usage, recycling and reuse, food management and production)."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Privacy_and_Civil_Liberties.txt", "Pages : 216-217\nCS Core : 2, KA Core : 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Privacy_and_Civil_Liberties.txt", "Electronic information sharing highlights the need to balance privacy protections with information access. The ease of digital access to many types of data \u2013 in addition to copying and distributing these data \u2013 makes privacy rights and civil liberties more complex, especially given cultural and legal differences in these areas. Complicating matters further, privacy also has interpersonal, organizational, professional/business, and governance components"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Privacy_and_Civil_Liberties.txt", ". In addition, the interconnected nature of online communities raises challenges for managing expectations and protections for freedom of expression invarious cultures and nations. Technology companies that provide platforms for user-generated content are under increasing pressure to perform governance tasks, potentially facing liability for their decisions."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Privacy_and_Civil_Liberties.txt", "CS Core: \n1. Privacy implications of widespread data collection including but not limited to transactional databases, data warehouses, surveillance systems, cloud computing, and artificial intelligence \n2. Conceptions of anonymity, pseudonymity, and identity \n3. Technology-based solutions for privacy protection (e.g., end-to-end encryption and differential privacy) \n4. Civil liberties, privacy rights, and cultural differences \n \nKA Core: \n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Privacy_and_Civil_Liberties.txt", ". Philosophical and legal conceptions of the nature of privacy including the right to privacy \n6. Legal foundations of privacy protection in relevant jurisdictions (e.g., GDPR in the EU) \n7. Privacy legislation in areas of practice (e.g., HIPAA in the US, AI Act in the EU) \n8. Basic Principles of human-subjects research and principles beyond what the law requires (e.g., Belmont Report, UN Universal Declaration on Human Rights and how this relates to technology) \n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Privacy_and_Civil_Liberties.txt", ". Freedom of expression and its limitations  \n10. User-generated content, content moderation, and liability \n \nIllustrative Learning Outcomes: \nCS Core: \n1. Evaluate solutions to privacy threats in transactional databases and data warehouses.  \n2. Describe the role of data collection in the implementation of pervasive surveillance systems (e.g., RFID, face recognition, toll collection, mobile computing).  \n3. Distinguish the concepts and goals of anonymity and pseudonymity. \n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Privacy_and_Civil_Liberties.txt", ". \n4. Describe the ramifications of technology-based privacy protections, including differential privacy and end-to-end encryption. \n5. Identify cultural differences regarding the nature and necessity of privacy and other civil liberties.  \n \nKA Core: \n6. Discuss the philosophical basis for the legal protection of personal privacy in an appropriate context (e.g., country).  \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Privacy_and_Civil_Liberties.txt", ".g., country).  \n7. Critique the intent, potential value, and implementation of various forms of privacy legislation and principles beyond what the law requires.  \n8. Identify strategies to enable appropriate freedom of expression."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-History.txt", "Pages : 220-221\nCS Core : 1, KA Core : 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-History.txt", "History is important because it provides a mechanism for understanding why our computing systems operate the way they do, the societal contexts in which current approaches arose, and how those continue to echo through the discipline today. Not only does computing affect society but vice-versa, resulting in a complex socio-technical context that is constantly changing, requiring the perspective of history to put the present, as well as possible futures, into appropriate perspective"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-History.txt", ". It also informs decisions based on successes and failures of the past including harm done and how to not repeat them. The history of computing is often taught in context with foundational concepts, such as system fundamentals and software development fundamentals. A focus should be placed on those who, due to marginalization, have not historically featured as prominently as they should."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-History.txt", "CS Core: \n1. The history of computing: hardware, software, and human/organizational. \n2. The role of history in the present including within different social contexts, and the relevance of this history on the future. \n \nKA Core: \n3. Age I (Pre-digital): Ancient analog computing (Stonehenge, Antikythera mechanism, Salisbury Cathedral clock, etc.), human-calculated number tables, Euclid, Lovelace, Babbage, G\u00f6del, Church, Turing, pre-electronic (electro-mechanical and mechanical) hardware \n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-History.txt", ". Age II (Early modern computing): ENIAC, UNIVAC, Bombes (Bletchley Park and codebreakers), computer companies (e.g., IBM), mainframes, etc. \n5. Age III (PC era): PCs, modern computer hardware and software, Moore\u2019s Law \n6. Age IV (Internet): Networking, internet architecture, browsers and their evolution, standards, born-on-the-internet companies, and services (e.g., Google, Amazon, Microsoft, etc.), distributed computing \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-History.txt", ".), distributed computing \n7. Age V (Mobile & Cloud): Mobile computing and smartphones, cloud computing and models thereof (e.g., SaaS), remote servers, security and privacy, social media \n8. Age VI (AI): Decision making systems, recommender systems, generative AI and other machine learning driven tools and technologies \n \nIllustrative Learning Outcomes: \nCS Core:  \n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-History.txt", ". Understand the relevance and impact of computing history on recent events, present context, and possible future outcomes, from more than one cultural perspective. \n2. Discuss how perspectives held today have been shaped by history, and that alternative perspectives exist (e.g., fears of AI replacing human workers vs AI augmenting human work, various views on Moore\u2019s Law)."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-History.txt", "KA Core: \n3. Identify formative and consequential trends in the history of the computing field.  \n4. Identify the contributions of pioneering individuals or organizations (research labs, computer companies, government offices) in the computing field. \n5. Discuss the historical context for important moments in history of computing, such as the move from vacuum tubes to transistors (TRADIC), early seminal operating systems (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-History.txt", ".g., OS 360), Xerox PARC and the first Apple computer with a GUI, the creation of specific programming language paradigms, the first computer virus, the creation of the internet, the creation of the WWW, the dot com bubble, Y2K, the introduction of smartphones, etc.  \n6. Compare daily life before and after the advent of milestone developments (e.g., personal computers or the internet)."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Economies_of_Computing.txt", "Page : 220\nCS Core : 0, KA Core : 1\n\nThe economies of computing are important to those who develop and provide computing resources and services to others as well as society in general. They impact users of these resources and services, both professional and non-professional. Computing professionals have a duty to know the impact of these topics on their own roles and activities and how choices made will impact users and society."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Economies_of_Computing.txt", "KA Core: \n1. Economic models: regulated and unregulated, monopolies, network effects, and open market; knowledge and attention economies \n2. Pricing and deployment strategies: planned obsolescence, subscriptions, freemium, software licensing, open-source, free software, adware \n3. Impacts of differences in access to computing resources, and the effect of skilled labor supply and demand on the quality of computing products \n4. Automation, AI, and their effects on job markets, developers, and users \n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Economies_of_Computing.txt", ". Ethical concerns surrounding the attention economy and other economies of computing (e.g. informed consent, data collection, use of verbose legalese in user agreements) \n \nIllustrative Learning Outcomes: \nKA Core: \n1. Summarize the social effects of economic models (e.g., the knowledge and attention economies).  \n2. Describe the differences and similarities of competing strategies (e.g., subscription vs freemium vs free).  \n3. Discuss examples of digital divides. \n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Economies_of_Computing.txt", ".  \n3. Discuss examples of digital divides. \n4. Understand the effects of automation and AI on society. \n5. Understand the ethical implications of computing economies that rely on attention and data."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Methods_for_Ethical_Analysis.txt", "Pages : 212-213-214\nCS Core : 2, KA Core : 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Methods_for_Ethical_Analysis.txt", "Ethical theories and principles are the foundations of ethical analysis because they are the viewpoints which can provide guidance along the pathway to a decision. Each theory emphasizes different assumptions and methods for determining the ethicality of a given action"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Methods_for_Ethical_Analysis.txt", ". It is important for students to recognize that decisions in different contexts may require different ethical theories (including  combinations) to arrive at ethically acceptable outcomes, and what constitutes \u2018acceptable\u2019 depends on a variety of factors such as cultural context. Applying methods for ethical analysis requires both an understanding of the underlying principles and assumptions guiding a given tool and an awareness of the social context for that decision. Traditional ethical frameworks (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Methods_for_Ethical_Analysis.txt", ". Traditional ethical frameworks (e.g., [11]) as provided by western philosophy can be useful, but they are not all-inclusive. Effort must be taken to include decolonial, indigenous, and historically marginalized ethical perspectives whenever possible. No theory will be universally applicable to all contexts, nor is any single ethical framework the \u2018best"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Methods_for_Ethical_Analysis.txt", ".\u2019 Engagement across various ethical schools of thought is important for students to develop the critical thinking needed in judiciously applying methods for ethical analysis of a given situation."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Methods_for_Ethical_Analysis.txt", "CS Core: \n1. Avoiding fallacies and misrepresentation in argumentation \n2. Ethical theories and decision-making (philosophical and social frameworks, e.g. [1]) \n3. Recognition of the role culture plays in our understanding, adoption, design, and use of computing technology \n4. Why ethics is important in computing, and how ethics is similar to, and different from, laws andsocial norms \n \nKA Core: \n5. Professional checklists \n6. Evaluation rubrics \n7. Stakeholder analysis \n8. Standpoint theory \n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Methods_for_Ethical_Analysis.txt", ". Stakeholder analysis \n8. Standpoint theory \n9. Introduction to ethical frameworks (e.g., consequentialism such as utilitarianism, non-consequentialism such as duty, rights, or justice, agent-centered such as virtue or feminism, contractarianism, ethics of care) and their use for analyzing an ethical dilemma \n \nIllustrative Learning Outcomes: \nCS Core: \n1. Describe how a given cultural context impacts decision making. \n2. Express the use of example and analogy in ethical argument.  \n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Methods_for_Ethical_Analysis.txt", ".  \n3. Analyze (and avoid) basic logical fallacies in an argument.  \n4. Analyze an argument to identify premises and conclusion.  \n5. Evaluate how and why ethics is so important in computing and how it relates to cultural norms, values, and law. \n6. Justify a decision made on ethical grounds.  \n \nKA Core: \n7. Distinguish all stakeholder positions in relation to their cultural context in a given situation.  \n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Methods_for_Ethical_Analysis.txt", ".  \n8. Analyze the potential for introducing or perpetuating ethical debt (deferred consideration of ethical impacts or implications) in technical decisions. \n9. Discuss the advantages and disadvantages of traditional ethical frameworks.  \n10. Analyze ethical dilemmas related to the creation and use of technology from multiple perspectives using ethical frameworks."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Professional_Ethics.txt", "Pages : 214-215\nCS Core : 2, KA Core : 2\n\nComputer ethics is a branch of practical philosophy that deals with how computing professionals should make decisions regarding professional and social conduct. There are three primary influences: 1) the individual's own personal ethical code, 2) any informal or formal regulation/decree/etc. of ethical behavior existing in the workplace, applicable licensures, certifications, or laws, and 3) exposure to formal codes of ethics and ethical frameworks."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Professional_Ethics.txt", "CS Core: \n1. Community values and the laws by which we live  \n2. The nature of being a professional including care, attention, discipline, fiduciary responsibility, and mentoring \n3. Keeping up to date as a computing professional in terms of familiarity, tools, skills, legal and professional frameworks as well as the ability and responsibility to self-assess and progress in the computing field \n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Professional_Ethics.txt", ". Professional certification, codes of ethics, conduct, and practice, such as the ACM, IEEE, AAAI, and other international societies \n5. Accountability, responsibility, and liability (e.g., software correctness, reliability and safety, warranty, negligence, strict liability, ethical approaches to security vulnerability disclosures) including whether a product/service should be built, not just doing so because it is technically possible. \n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Professional_Ethics.txt", ". \n6. Introduction to theories describing the human creation and use of technology including instrumentalism, sociology of technological systems, disability justice, neutrality thesis, pragmatism, and decolonial models, including developing and using technology to right wrongs and do good \n7. Strategies for recognizing and reporting designs, systems, software, and professional conduct (or their outcomes) that may violate law or professional codes of ethics \n \nKA Core: \n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Professional_Ethics.txt", ". The role of the computing professional and professional societies in public policy \n9. Maintaining awareness of consequences \n10. Ethical dissent and whistleblowing \n11. The relationship between regional culture and ethical dilemmas \n12. Dealing with harassment and discrimination \n13. Forms of professional credentialing  \n14. Ergonomics and healthy computing environments \n15. Time-to-market and cost considerations versus quality professional standards \n \nIllustrative Learning Outcomes: \nCS Core:  \n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Professional_Ethics.txt", ". Identify ethical issues that arise in software design, development practices, and software deployment. \n2. Discuss how to address ethical issues in specific situations.  \n3. Express the ethical responsibility of ensuring software correctness, reliability and safety including from where this responsibility arises (e.g., ACM/IEEE/AAAI Codes of Ethics, laws and regulations, organizational policies).  \n4. Describe the mechanisms that typically exist for a professional to keep up to date in ethical matters"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Professional_Ethics.txt", ".  \n5. Describe the strengths and weaknesses of relevant professional codes as expressions of being a professional and guides to decision-making.  \n6. Analyze a global computing issue, observing the role of professionals and government officials in managing this problem.  \n \nKA Core: \n7. Describe ways in which professionals and professional organizations may contribute to public policy. \n8. Describe the consequences of inappropriate professional behavior.  \n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Professional_Ethics.txt", ".  \n9. Be familiar with whistleblowing and have access to knowledge to guide one through an incident.  \n10. Identify examples of how regional culture interplays with ethical dilemmas.  \n11. Describe forms of harassment and discrimination and avenues of assistance.  \n12. Assess various forms of professional credentialing.  \n13. State the relationship between ergonomics in computing environments and people\u2019s health.  \n14"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Professional_Ethics.txt", ".  \n14. Describe issues associated with industries\u2019 push to focus on time-to-market versus enforcing quality professional standards."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", "Pages : 223-224\nCS Core : 2, KA Core : 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", "Despite being a creative, often highly compensated field with myriad job (and other) opportunities, racial, gender, and many other inequities in representation are pervasive in many regions. For too many students, their first computer science course is their last. There are many factors including the legacy of systemic racism, ableism, sexism, classism, and other injustices that contribute to the lack of diverse identities within computer science, and there is no single or quick fix"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", ".  CS2023\u2019s sponsoring organizations are ACM, IEEE, and AAAI. Each of these places a high value on diversity, equity, inclusion, and accessibility; our computer science classrooms should promote and model those principles. We should welcome and seek diversity \u2013 the gamut of human differences including gender identity, ethnicity, race, politics, abilities and attributes, religion, nationality, etc.\u2013 in our classrooms, departments, and campuses"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", ".\u2013 in our classrooms, departments, and campuses. We should strive to make our classrooms, labs, and curricula accessible and to promote inclusion. We should aim for students and all community members to have a sense of belonging that comes with being respected, wanted, and valued. To achieve equity, we must allocate resources, promote fairness, and check our biases to ensure persons of all identities achieve success. Accessibility should be addressed and implemented in all computing activities and products"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", ".  Explicitly infusing diversity, equity, inclusion, and accessibility (DEIA) across the computer science curriculum demonstrates its importance for the department, institution, and our field \u2013 all of which are likely to have a DEIA statement and/or initiative(s). This emphasis on DEIA is important ethically and a bellwether issue of our time. Many professionals in computing already recognize attention to DEIA as integral to disciplinary practice"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", ". Regardless of the degree to which these values appear in any one computer science class, research suggests that a lack of attention to them results in inferior designs in addition to harm and its perpetuation. Not only does data support that diverse teams outperform homogeneous ones, but diverse teams may better prevent egregious technology failures in recent headlines such as facial recognition misuse, airbag injuries and deaths, and other well-known failures of science and computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", "CS Core: \n1. How identity impacts and is impacted by computing technologies and environments (academic and professional) \n2. The benefits of diverse development teams and the impacts of teams that are not diverse \n3. Inclusive language and charged terminology, and why their use matters \n4. Inclusive behaviors and why they matter \n5. Designing and developing technology with accessibility in mind \n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", ". How computing professionals can influence and impact diversity, equity, inclusion and accessibility, including but not only through the software they create \n \nKA Core: \n7. Experts and their practices that reflect the identities of the classroom and the world through practical DEIA principles \n8. Historic marginalization due to systemic social mechanisms, technological supremacy and global infrastructure challenges to diversity, equity, inclusion, and accessibility \n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", ". Cross-cultural differences in, and needs for, diversity, equity, inclusion, and accessibility  \n \nIllustrative Learning Outcomes: \nCS Core: \n1. Define and distinguish equity, equality, diversity, inclusion, and accessibility.  \n2. Identify language, practices, and behaviors that may make someone feel included in a workplace and/or a team, and why is it relevant. Avoid charged terminology - see Words Matter (www.acm"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", ".acm.org/diversity-inclusion/words-matter) \u2013 this includes identifying and accommodating users who are often excluded without thought and not considered at all. \n3. Evaluate the accessibility of your classroom or lab. Evaluate the accessibility of your webpage. (See www.w3.org/WAI and www.w3.org/TR/WCAG21). \n4. Demonstrate collegiality and respect when working with team members who do not share your identity. It is not enough to merely assign team projects"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", ". It is not enough to merely assign team projects. Faculty should prepare students for teamwork and monitor, mentor, and assess the effectiveness of their student teams throughout a project. \n5. Compare the demographics of your institution\u2019s computer science and STEM majors to the overall institutional demographics. If they differ, identify factors that contribute to inequitable access, engagement, and achievement in computer science among marginalized groups. If they do not, assess why not. \n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", ". If they do not, assess why not. \n6. Identify developers\u2019 assumptions and values embedded in hardware and software design, especially as they pertain to usability by diverse populations. \n7. Identify examples of the benefits that diverse teams can bring to software products, and how a lack of diversity has costs."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", "KA Core: \n8. Analyze the work of experts who reflect the identities of the classroom and the world. \n9. Assess the impact of power and privilege in the computing profession as it relates to culture, industry, products, and society. \n10. Develop examples of systemic changes that could positively address diversity, equity, inclusion, and accessibility in a familiar context (i.e., in an introductory computing course) and an unfamiliar context and when these might be different, or the same.  \n11"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Diversity_Equity_Inclusion_and_Accessibility.txt", ".  \n11. Compare the demographics of your institution to the overall community demographics. If they differ, identify factors that contribute to inequitable access, engagement, and achievement among marginalized groups. If they do not, assess why not."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Intellectual_Property.txt", "Pages : 215-216\nCS Core : 1, KA Core : 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Intellectual_Property.txt", "Intellectual property refers to a range of intangible rights of ownership in any product of human intellect, such as a software program. Laws, which vary by locality, provide different methods for protecting these rights of ownership based on their type. Ideally, intellectual property laws balance the interests of creators and users of the property. There are four types of intellectual property rights relevant to software: patents, copyrights, trade secrets, and trademarks"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Intellectual_Property.txt", ". Moreover, property rights are often protected by user licenses. Each affords a different type of legal protection."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Intellectual_Property.txt", "CS Core: \n1. Intellectual property rights \n2. Intangible digital intellectual property (IDIP) \n3. Legal foundations for intellectual property protection \n4. Common software licenses (e.g., MIT, GPL and its variants, Apache, Mozilla, Creative Commons) \n5. Plagiarism and authorship \n \nKA Core: \n6. Philosophical foundations of intellectual property \n7. Forms of intellectual property (e.g., copyrights, patents, trade secrets, trademarks) and the rights they protect \n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Intellectual_Property.txt", ". Limitations on copyright protections, including fair use and the first sale doctrine \n9. Intellectual property laws and treaties that impact the enforcement of copyrights \n10. Software piracy and technical methods for enforcing intellectual property rights, such as digital rights management and closed source software as a trade secret \n11. Moral and legal foundations of the open-source movement \n12. Systems that use others\u2019 data (e.g., large language models) \n \nIllustrative Learning Outcomes: \nCS Core: \n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Intellectual_Property.txt", ". Describe and critique legislation and precedent aimed at digital copyright infringements. \n2. Identify contemporary examples of intangible digital intellectual property. \n3. Select an appropriate software license for a given project. \n4. Defend legal and ethical uses of copyrighted materials. \n5. Interpret the intent and implementation of software licensing. \n6. Discuss whether a use of copyrighted material is likely to be fair use. \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Intellectual_Property.txt", ". \n7. Analyze the ethical issues inherent in various plagiarism detection mechanisms. \n8. Identify multiple forms of plagiarism beyond verbatim copying of text or software (e.g., intentional paraphrasing, authorship misrepresentation, and improper attribution).  \n \nKA Core: \n9. Discuss the philosophical bases of intellectual property in an appropriate context (e.g., country).  \n10. Distinguish the conflicting issues involved in securing software patents.  \n11"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Intellectual_Property.txt", ".  \n11. Contrast the protections and obligations of copyright, patent, trade secret, and trademarks.  \n12. Describe the rationale for the legal protection of intellectual property in the appropriate context (e.g., country).  \n13. Analyze the use of copyrighted work under the concepts of fair use and the first sale doctrine. \n14. Identify the goals of the open-source movement and its impact on fields beyond computing, such as the right-to-repair movement. \n15. Summarize the global nature of software piracy"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Intellectual_Property.txt", ". Summarize the global nature of software piracy.  \n16. Criticize the use of technical measures of digital rights management (e.g., encryption, watermarking, copy restrictions, and region lockouts) from multiple stakeholder perspectives. \n17. Discuss the nature of anti-circumvention laws in the context of copyright protection."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Security_Policies_Laws_and_Computer_Crimes.txt", "Page : 222\nCS Core : 2, KA Core : 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Security_Policies_Laws_and_Computer_Crimes.txt", "While security policies, laws and computer crimes are important topics, it is essential they are viewed with the foundation of other social and professional knowledge units, such as Intellectual Property, Privacy and Civil Liberties, Social Context, and Professional Ethics. Computers, the internet, and artificial intelligence, perhaps more than any other technologies, have transformed society over the past 75 years"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Security_Policies_Laws_and_Computer_Crimes.txt", ". At the same time, these technologies have contributed to unprecedented threats to privacy; new categories of computer crime and antisocial behavior; major disruptions to organizations; and the large-scale concentration of risk in information systems."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Security_Policies_Laws_and_Computer_Crimes.txt", "CS Core: \n1. Computer crimes, legal redress for computer criminals and impact on victims and society \n2. Social engineering, computing-enabled fraud, identity theft and recovery from these \n3. Cyber terrorism, criminal hacking, and hacktivism \n4. Malware, viruses, worms \n5. Attacks on critical infrastructure such as electrical grids and pipelines \n6. Non-technical fundamentals of security (e.g., human engineering, policy, confidentiality) \n \nKA Core: \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Security_Policies_Laws_and_Computer_Crimes.txt", ". Benefits and challenges of existing and proposed computer crime laws \n8. Security policies and the challenges of change and compliance \n9. Responsibility for security throughout the computing life cycle \n10. International and local laws and how they intersect \n \nIllustrative Learning Outcomes: \nCS Core: \n1. List classic examples of computer crimes and social engineering incidents with societal impact.  \n2. Identify issues with laws that apply to computer crimes.  \n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Security_Policies_Laws_and_Computer_Crimes.txt", ".  \n3. Describe the motivation and ramifications of cyber terrorism, data theft, hacktivism, ransomware, and other attacks.  \n4. Examine the ethical and legal issues surrounding the misuse of access and various breaches of security.  \n5. Discuss the professional's role in security and the tradeoffs and challenges involved.  \n \nKA Core: \n6. Investigate measures that can be taken by both individuals and organizations including governments to prevent or mitigate the undesirable effects of computer crimes.  \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Society_Ethics_and_the_Profession_SEP/SEP-Security_Policies_Laws_and_Computer_Crimes.txt", ".  \n7. Design a company-wide security policy, which includes procedures for managing passwords and employee monitoring.  \n8. Understand how legislation from one region may affect activities in another (e.g., how EU GDPR applies globally, when EU persons are involved)."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Real-time_Real-time_and_Embedded_Systems.txt", "Pages: 214\n\nHOURS\n\tCS Core = 0\n\tKA Core = 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Real-time_Real-time_and_Embedded_Systems.txt", "OS-Real-time: Real-time and Embedded Systems\nKA Core:\n1. Process and task scheduling.\n2. Deadlines and real-time issues. (See also: SPD-Embedded)\n3. Low-latency vs \u201dsoft real-time\" vs \"hard real time.\" (See also: SPD-Embedded, FPL-Event-Driven)\nNon-Core:\n4. Memory/disk management requirements in a real-time environment.\n5. Failures, risks, and recovery.\n6. Special concerns in real-time systems (safety).\nIllustrative Learning Outcomes:\nKA Core:\n1. Explain what makes a system a real-time system.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Real-time_Real-time_and_Embedded_Systems.txt", ".\n2. Explain latency and its sources in software systems and its characteristics.\n3. Explain special concerns that real-time systems present, including risk, and how these concerns are\naddressed.\nNon-Core:\n4. Explain specific real time operating systems features and mechanisms."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Advanced-Files_Advanced_File_systems.txt", "Pages: 212-213\n\nHOURS\n\tCS Core = 0\n\tKA Core = 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Advanced-Files_Advanced_File_systems.txt", "OS-Advanced-Files: Advanced File systems\nKA Core:\n1. File systems: partitioning, mount/unmount, virtual file systems\n2. In-depth implementation techniques\n3. Memory-mapped files (See also: AR-IO )\n4. Special-purpose file systems\n5. Naming, searching, access, backups\n6. Journaling and log-structured file systems (See also: SF-Reliability)\nNon-Core: (including emerging topics)\n1. Distributed file systems\n2. Encrypted file systems\n3. Fault tolerance\nIllustrative Learning Outcomes:\nKA Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Advanced-Files_Advanced_File_systems.txt", ". Explain how hardware developments have led to changes in the priorities for the design and the\nmanagement of file systems.\n2. Map file abstractions to a list of relevant devices and interfaces.\n3. Identify and categorize different mount types.\n4. Explain specific file systems requirements and the specialized file systems features that meet those\nrequirements.\n5. Explain the use of journaling and how log-structured file systems enhance fault tolerance.\nNon-Core:\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Advanced-Files_Advanced_File_systems.txt", ".\nNon-Core:\n6. Explain purpose and complexity of distributed file systems.\n7. List examples of distributed file systems protocols.\n8. Explain mechanisms in file systems to improve fault tolerance."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Concurrency_Concurrency.txt", "Pages: 208\n\nHOURS\n\tCS Core = 2\n\tKA Core = 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Concurrency_Concurrency.txt", "OS-Concurrency: Concurrency\nCS Core:\n1. Thread abstraction relative to concurrency\n2. Race conditions, critical regions (role of interrupts, if needed) (See also: PDC-Programs)\n3. Deadlocks and starvation (See also: PDC-Coordination)\n4. Multiprocessor issues (spin-locks, reentrancy).\n5. Multiprocess concurrency vs multithreading\nKA Core:\n6. Thread creation, states, structures (See also: SF-Foundations)\n7. Thread APIs\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Concurrency_Concurrency.txt", ". Thread APIs\n8. Deadlocks and starvation (necessary conditions/mitigations) (See also: PDC-Coordination)\n9. Implementing thread safe code (semaphores, mutex locks, condition variables). (See also: ARPerformance-Energy, SF-Evaluation, PDC-Evaluation)\n10. Race conditions in shared memory (See also: PDC-Coordination)\nNon-Core:\n11. Managing atomic access to OS objects (e.g., big kernel lock vs many small locks vs lockless data\nstructures like lists)\nIllustrative Learning Outcomes:\nCS Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Concurrency_Concurrency.txt", ". Understand the advantages and disadvantages of concurrency as inseparable functions within the\noperating system framework.\n2. Understand how architecture level implementation results in concurrency problems including race\nconditions.\n3. Understand concurrency issues in multiprocessor systems.\nKA Core:\n4. Understand the range of mechanisms that can be employed at the operating system level to realize\nconcurrent systems and describe the benefits of each.\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Concurrency_Concurrency.txt", ".\n5. Understand techniques for achieving synchronization in an operating system (e.g., describe how a\nsemaphore can be implemented using OS primitives) including intra-concurrency control and use of\nhardware atomics.\n6. Accurately analyze code to identify race conditions and appropriate solutions for addressing race\nconditions."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Process_Process_Model.txt", "Pages: 210\n\nHOURS\n\tCS Core = 0\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Process_Process_Model.txt", "OS-Process: Process Model\nKA Core:\n1. Processes and threads relative to virtualization protected memory, process state, memory\nisolation, etc.\n2. Memory footprint/segmentation (e.g., stack, heap, etc.) (See also: AR-Assembly)\n3. Creating and loading executables, shared libraries, and dynamic linking (See also: FPL-Translation)\n4. Dispatching and context switching (See also: AR-Assembly)\n5. Interprocess communication (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Process_Process_Model.txt", ". Interprocess communication (e.g., shared memory, message passing, signals, environment\nvariables) (See also: PDC-Communication)\nIllustrative Learning Outcomes:\nKA Core:\n1. Understand how processes and threads use concurrency features to virtualize control.\n2. Understand reasons for using interrupts, dispatching, and context switching to support concurrency\nand virtualization in an operating system.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Process_Process_Model.txt", ".\n3. Understand the different states that a task may pass through, and the data structures needed to\nsupport the management of many tasks.\n4. Understand the different ways of allocating memory to tasks, citing the relative merits of each.\n5. Apply the appropriate interprocess communication mechanism for a specific purpose in a\nprogrammed software artifact."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Purpose_Role_and_Purpose_of_Operating_Systems.txt", "Pages: 206-207\n\nHOURS\n\tCS Core = 2\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Purpose_Role_and_Purpose_of_Operating_Systems.txt", "OS-Purpose: Role and Purpose of Operating Systems\nCS Core:\n1. Operating systems mediate between general purpose hardware and application-specific software.\n2. Universal operating system functions (e.g., process, user and device interfaces, persistence of\ndata)\n3. Extended and/or specialized operating system functions (e.g., embedded systems, server types\nsuch as file, web, multimedia, boot loaders and boot security)\n4. Design issues (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Purpose_Role_and_Purpose_of_Operating_Systems.txt", ". Design issues (e.g., efficiency, robustness, flexibility, portability, security, compatibility, power,\nsafety, tradeoffs between error checking and performance, flexibility and performance, and security\nand performance) (See also: SEC-Engineering)\n5. Influences of security, networking, multimedia, parallel and distributed computing\n6. Overarching concern of security/protection: Neglecting to consider security at every layer creates\nan opportunity to inappropriately access resources.\n Example concepts:\na"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Purpose_Role_and_Purpose_of_Operating_Systems.txt", ".\n Example concepts:\na. Unauthorized access to files on an unencrypted drive can be achieved by moving the media to\nanother computer.\nb. Operating systems enforced security can be defeated by infiltrating the boot layer before the\noperating system is loaded.\nc. Process isolation can be subverted by inadequate authorization checking at API boundaries.\nd. Vulnerabilities in system firmware can provide attack vectors that bypass the operating system\nentirely.\ne"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Purpose_Role_and_Purpose_of_Operating_Systems.txt", ".\ne. Improper isolation of virtual machine memory, computing, and hardware can expose the host\nsystem to attacks from guest systems.\nf. The operating system may need to mitigate exploitation of hardware and firmware\nvulnerabilities, leading to potential performance reductions (e.g., Spectre and Meltdown\nmitigations).\n7. Exposure of operating systems functions in shells and systems programming. (See also: FPLScripting)\nIllustrative Learning Outcomes:\nCS Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Purpose_Role_and_Purpose_of_Operating_Systems.txt", ". Understand the objectives and functions of modern operating systems.\n2. Evaluate the design issues in different usage scenarios (e.g., real time OS, mobile, server).\n3. Understand the functions of a contemporary operating system with respect to convenience,\nefficiency, and the ability to evolve.\n4. Understand how evolution and stability are desirable and mutually antagonistic in operating\nsystems function."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Scheduling_Scheduling.txt", "Pages: 209-210\n\nHOURS\n\tCS Core = 0\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Scheduling_Scheduling.txt", "OS-Scheduling: Scheduling\nKA Core:\n1. Preemptive and non-preemptive scheduling\n2. Schedulers and policies (e.g., first come, first serve, shortest job first, priority, round robin,\nmultilevel) (See also: SF-Resource)\n3. Concepts of Symmetric Multi-Processor (SMP) scheduling and cache coherence (See also: ARMemory)\n4. Timers (e.g., building many timers out of finite hardware timers) (See also: AR-Assembly)\n5. Fairness and starvation\nNon-Core:\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Scheduling_Scheduling.txt", ". Fairness and starvation\nNon-Core:\n6. Subtopics of operating systems such as energy-aware scheduling and real-time scheduling (See\nalso: AR-Performance-Energy, SPD-Embedded, SPD-Mobile)\n7. Cooperative scheduling, such as Linux futexes and userland scheduling.\nIllustrative Learning Outcomes:\nKA Core:\n1. Compare and contrast the common algorithms used for both preemptive and non-preemptive\nscheduling of tasks in operating systems, such as priority, performance comparison, and fair-share\nschemes.\n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Scheduling_Scheduling.txt", ".\n2. Explain the relationships between scheduling algorithms and application domains.\n3. Explain the distinctions among types of processor scheduler such as short-term, medium-term,\nlong-term, and I/O.\n4. Evaluate a problem or solution to determine appropriateness for asymmetric and/or symmetric\nmultiprocessing.\n5. Evaluate a problem or solution to determine appropriateness as a process vs threads.\n6. List some contexts benefitting from preemption and deadline scheduling.\nNon-Core:\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Scheduling_Scheduling.txt", ".\nNon-Core:\n7. Explain the ways that the logic embodied in scheduling algorithms are applicable to other operating\nsystems mechanisms, such as first come first serve or priority to disk I/O, network scheduling,\nproject scheduling, and problems beyond computing."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Files_File_Systems_API_and_Implementation.txt", "Pages: 212\n\nHOURS\n\tCS Core = 0\n\tKA Core = 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Files_File_Systems_API_and_Implementation.txt", "OS-Files: File Systems API and Implementation\nKA Core:\n1. Concept of a file including data, metadata, operations, and access-mode\n2. File system mounting\n3. File access control\n4. File sharing\n5. Basic file allocation methods, including linked allocation table\n6. File system structures comprising file allocation including various directory structures and methods\nfor uniquely identifying files (e.g., name, identified or metadata storage location)\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Files_File_Systems_API_and_Implementation.txt", ". Allocation/deallocation/storage techniques (algorithms and data structure) impact on performance\nand flexibility (i.e., internal and external fragmentation and compaction)\n8. Free space management such as using bit tables vs linking\n9. Implementation of directories to segment and track file location\nIllustrative Learning Outcomes:\nKA Core:\n1. Explain the choices to be made in designing file systems.\n2. Evaluate different approaches to file organization, recognizing the strengths and weaknesses of\neach.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Files_File_Systems_API_and_Implementation.txt", ".\n3. Apply software constructs appropriately given knowledge of the file system implementation."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Devices_Device_management.txt", "Pages: 211-212\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0.5 + 0.5 (AR)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Devices_Device_management.txt", "OS-Devices: Device management\nKA Core:\n1. Buffering strategies (See also: AR-IO)\n2. Direct Memory Access (DMA) and polled I/O, Memory-mapped I/O (See also: AR-IO)\nExample concept: DMA communication protocols (e.g., ring buffers etc.)\n3. Historical and contextual - Persistent storage device management (e.g., magnetic, Solid State\nDevice (SSD)) (See also: SEP-History)\nNon-Core:\n4. Device interface abstractions, hardware abstraction layer\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Devices_Device_management.txt", ". Device driver purpose, abstraction, implementation, and testing challenges\n6. High-level fault tolerance in device communication\nIllustrative Learning Outcomes:\nKA Core:\n1. Explain architecture level device control implementation and link relevant operating system\nmechanisms and policy (e.g., buffering strategies, direct memory access).\n2. Explain OS device management layers and the architecture (e.g., device controller, device driver,\ndevice abstraction).\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Devices_Device_management.txt", ".\n3. Explain the relationship between the physical hardware and the virtual devices maintained by the\noperating system.\n4. Explain I/O data buffering and describe strategies for implementing it.\n5. Describe the advantages and disadvantages of direct memory access and discuss the\ncircumstances in which its use is warranted.\nNon-Core:\n6. Describe the complexity and best practices for the creation of device drivers."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Protection_Protection_and_Safety.txt", "Pages: 209\n\nHOURS\n\tCS Core = 2\n\tKA Core = 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Protection_Protection_and_Safety.txt", "OS-Protection: Protection and Safety\nCS Core:\n1. Overview of operating system security mechanisms (See also: SEC-Foundations)\n2. Attacks and antagonism (scheduling, etc.) (See also: SEC-Foundations)\n3. Review of major vulnerabilities in real operating systems (See also: SEC-Foundations)\n4. Operating systems mitigation strategies such as backups (See also: SF-Reliability)\nKA Core:\n5. Policy/mechanism separation (See also: SEC-Governance)\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Protection_Protection_and_Safety.txt", ". Security methods and devices (See also: SEC-Foundations)\n Example concepts:\na. Rings of protection (history from Multics to virtualized x86)\nb. x86_64 rings -1 and -2 (hypervisor and ME/PSP)\n7. Protection, access control, and authentication (See also: SEC-Foundations, SEC-Crypto)\nIllustrative Learning Outcomes:\nCS Core:\n1. Understand the requirement for protection and security mechanisms in operating systems.\n2. List and describe the attack vectors that leverage OS vulnerabilities.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Protection_Protection_and_Safety.txt", ".\n3. Understand the mechanisms available in an OS to control access to resources.\nKA Core:\n4. Summarize the features and limitations of an operating system that impact protection and security."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Principles_Principles_of_Operating_System.txt", "Pages: 207-208\n\nHOURS\n\tCS Core = 2\n\tKA Core = 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Principles_Principles_of_Operating_System.txt", "OS-Principles: Principles of Operating System\nCS Core:\n1. Operating system software design and approaches (e.g., monolithic, layered, modular, microkernel, unikernel)\n2. Abstractions, processes, and resources\n3. Concept of system calls and links to application program interfaces (e.g., Win32, Java, Posix). (See\nalso: AR-Assembly)\n4. The evolution of the link between hardware architecture and the operating system functions\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Principles_Principles_of_Operating_System.txt", ". Protection of resources means protecting some machine instructions/functions (See also: ARAssembly)\nExample concepts:\na. Applications cannot arbitrarily access memory locations or file storage device addresses.\nb. Protection of coprocessors and network devices\n6. Leveraging interrupts from hardware level: service routines and implementations. (See also: ARAssembly)\n Example concepts:\na. Timer interrupts for implementing time slices\nb. I/O interrupts for putting blocking threads to sleep without polling\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Principles_Principles_of_Operating_System.txt", ". Concept of user/system state and protection, transition to kernel mode using system calls (See\nalso: AR-Assembly)\n8. Mechanism for invoking system calls, the corresponding mode and context switch and return from\ninterrupt (See also: AR-Assembly)\n9. Performance costs of context switches and associated cache flushes when performing process\nswitches in Spectre-mitigated environments.\nIllustrative Learning Outcomes:\nCS Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Principles_Principles_of_Operating_System.txt", ".\nIllustrative Learning Outcomes:\nCS Core:\n1. Understand how the application of software design approaches to operating systems\ndesign/implementation (e.g., layered, modular, etc.) affects the robustness and maintainability of an\noperating system.\n2. Categorize system calls by purpose.\n3. Understand dynamics of invoking a system call (e.g., passing parameters, mode change).\n4. Evaluate whether a function can be implemented in the application layer or can only be\naccomplished by system calls.\n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Principles_Principles_of_Operating_System.txt", ".\n5. Apply OS techniques for isolation, protection, and throughput across OS functions (e.g., starvation\nsimilarities in process scheduling, disk request scheduling, semaphores, etc.) and beyond.\n6. Understand how the separation into kernel and user mode affects safety and performance.\n7. Understand the advantages and disadvantages of using interrupt processing in enabling\nmultiprogramming.\n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Principles_Principles_of_Operating_System.txt", ".\n8. Analyze potential vectors of attack via the operating systems and the security features designed to\nguard against them."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Virtualization_Virtualization.txt", "Pages: 213-214\n\nHOURS\n\tCS Core = 0\n\tKA Core = 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Virtualization_Virtualization.txt", "OS-Virtualization: Virtualization\nKA Core:\n1. Using virtualization and isolation to achieve protection and predictable performance. (See also: SFPerformance)\n2. Advanced paging and virtual memory. (See also: SF-Performance)\n3. Virtual file systems and virtual devices.\n4. Containers and their comparison to virtual machines.\n5. Thrashing (e.g., Popek and Goldberg requirements for recursively virtualizable systems).\nNon-core:\n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Virtualization_Virtualization.txt", ".\nNon-core:\n6. Types of virtualizations (including hardware/software, OS, server, service, network). (See also: SFPerformance)\n7. Portable virtualization; emulation vs isolation. (See also: SF-Performance)\n8. Cost of virtualization. (See also: SF-Performance)\n9. Virtual machines and container escapes, dangers from a security perspective. (See also: SECEngineering)\n10. Hypervisors- hardware virtual machine extensions, hosts with kernel support, QEMU KVM\nIllustrative Learning Outcomes:\nKA Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Virtualization_Virtualization.txt", ". Explain how hardware architecture provides support and efficiencies for virtualization.\n2. Explain the difference between emulation and isolation.\n3. Evaluate virtualization tradeoffs. \nNon-Core:\n4. Explain hypervisors and the need for them in conjunction with different types of hypervisors."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Faults_Fault_tolerance.txt", "Pages: 214-215\n\nHOURS\n\tCS Core = 0\n\tKA Core = 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Faults_Fault_tolerance.txt", "OS-Faults: Fault tolerance\nKA Core:\n1. Reliable and available systems. (See also: SF-Reliability)\n2. Software and hardware approaches to address tolerance (RAID). (See also: SF-Reliability)\nNon-Core:\n3. Spatial and temporal redundancy. (See also: SF-Reliability)\n4. Methods used to implement fault tolerance. (See also: SF-Reliability)\n5. Error identification and correction mechanisms, checksums of volatile memory in RAM. (See also:\nAR-Memory)\n6. File system consistency check and recovery.\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Faults_Fault_tolerance.txt", ". File system consistency check and recovery.\n7. Journaling and log-structured file systems. (See also: SF-Reliability)\n8. Use-cases for fault-tolerance (databases, safety-critical). (See also: SF-Reliability)\n9. Examples of OS mechanisms for detection, recovery, restart to implement fault tolerance, use of\nthese techniques for the OS\u2019s own services. (See also: SF-Reliability)\nIllustrative Learning Outcomes:\nKA Core:\n1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Faults_Fault_tolerance.txt", ". Explain how operating systems can facilitate fault tolerance, reliability, and availability\n2. Explain the range of methods for implementing fault tolerance in an operating system.\n3. Explain how an operating system can continue functioning after a fault occurs.\n4. Explain the performance and flexibility tradeoffs that impact using fault tolerance.\nNon-Core:\n5. Describe operating systems fault tolerance issues and mechanisms in detail."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Memory_Memory_Management.txt", "Pages: 210-211\n\nHOURS\n\tCS Core = 0\n\tKA Core = 0.5 + 1.5 (AR)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Memory_Memory_Management.txt", "OS-Memory: Memory Management\nKA Core:\n1. Review of physical memory, address translation and memory management hardware (See also:\nAR-Memory, MSF-Discrete)\n2. Impact of memory hierarchy including cache concept, cache lookup, and per-CPU caching on\noperating system mechanisms and policy (See also: AR-Memory, SF-Performance)\n3. Logical and physical addressing, address space virtualization (See also: AR-Memory, MSFDiscrete)\n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Memory_Memory_Management.txt", ". Concepts of paging, page replacement, thrashing and allocation of pages and frames\n5. Allocation/deallocation/storage techniques (algorithms and data structure) performance and\nflexibility\nExample concept: Arenas, slab allocators, free lists, size classes, heterogeneously sized pages\n(huge pages)\n6. Memory caching and cache coherence and the effect of flushing the cache to avoid speculative\nexecution vulnerabilities (See also: AR-Organization, AR-Memory, SF-Performance)\n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Memory_Memory_Management.txt", ". Security mechanisms and concepts in memory management including sandboxing, protection,\nisolation, and relevant vectors of attack (See also: SEC-Foundations)\nNon-Core:\n8. Virtual memory: leveraging virtual memory hardware for OS services and efficiency\nIllustrative Learning Outcomes:\nKA Core:\n1. Explain memory hierarchy and cost-performance tradeoffs.\n2. Summarize the principles of virtual memory as applied to caching and paging.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-Memory_Memory_Management.txt", ".\n3. Evaluate the tradeoffs in terms of memory size (main memory, cache memory, auxiliary memory)\nand processor speed.\n4. Describe the reason for and use of cache memory (performance and proximity, how caches\ncomplicate isolation and virtual machine abstraction).\n5. Code/Develop efficient programs that consider the effects of page replacement and frame allocation\non the performance of a process and the system in which it executes.\nNon-Core:\n6. Explain how hardware is utilized for efficient virtualization"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-SEP_Society_Ethics_and_the_Profession.txt", "Pages: 215\n\nHOURS\n\tCS Core = Included in SEP hours\n\tKA Core = Included in SEP hours"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-SEP_Society_Ethics_and_the_Profession.txt", "OS-SEP: Society, Ethics, and the Profession\nKA Core:\n1. Open source in operating systems. (See also: SEP-IP)\n Example concepts:\na. Identification of vulnerabilities in open-source kernels,\nb. Open-source guest operating systems,\nc. Open-source host operating systems, and\nd. Changes in monetization (paid vs free upgrades).\n2. End-of-life issues with sunsetting operating systems"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-SEP_Society_Ethics_and_the_Profession.txt", ".\nExample concept: Privacy implications of using proprietary operating systems/operating\nenvironments, including telemetry, automated scanning of personal data, built-in advertising, and\nautomatic cloud integration.\nIllustrative Learning Outcomes:\nKA Core:\n1. Explain advantages and disadvantages of finding and addressing bugs in open-source kernels.\n2. Contextualize history and positive and negative impact of Linux as an open-source product.\n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/Operating_Systems_OS/OS-SEP_Society_Ethics_and_the_Profession.txt", ".\n3. List complications with reliance on operating systems past end-of-life.\n4. Understand differences in finding and addressing bugs for various operating systems payment\nmodels."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Security.txt", "Page : 235\nCS Core : 2, KA Core : 1\n\nCS Core: \n1. Common system security issues (e.g., viruses, denial-of-service attacks, and eavesdropping) (See also: OS-Protection, NC-Security, SEC-Foundations, SEC-Engineering) \n2. Countermeasures (See also: OS-Principles, OS-Protection, NC-Security) \na. Cryptography (See also: SEC-Crypto) \nb. Security architecture (See also: SEC-Engineering)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Security.txt", "KA Core: \n3. Representative countermeasure systems \na. Intrusion detection systems, firewalls (See also: NC-Security) \nb. Antivirus systems \n \nIllustrative Learning Outcomes: \nCS Core: \n1. Describe some common system security issues and give examples  \n2. Describe some countermeasures against system security issues \n \nKA Core: \n3. Describe representative countermeasure systems"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Basic_Concepts.txt", "Pages : 231-232\nCS Core : 4, KA Core : 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Basic_Concepts.txt", "CS Core: \n1. Digital vs Analog/Discrete vs Continuous Systems \n2. Simple logic gates, logical expressions, Boolean logic simplification \n3. Clocks, State, Sequencing \n4. State and state transition (e.g., starting state, final state, life cycle of states) (See also: AL-Models) \n5. Finite state machines (e.g., NFA, DFA) (See also: AL-Models) \n6. Combinational Logic, Sequential Logic, Registers, Memories (See also: AR-Logic) \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Basic_Concepts.txt", ". Computers and Network Protocols as examples of State Machines (See also: NC-Fundamentals) \n8. Sequential vs parallel processing. (See also: PDC-Programs, OS-Concurrency) \n9. Application-level sequential processing: single thread (See also: PDC-Programs, OS-Concurrency) \n10"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Basic_Concepts.txt", ". Simple application-level parallel processing: request level (web services/client-server/distributed), single thread per server, multiple threads with multiple servers, pipelining (See also: PDC-Programs, OS-Concurrency) \n \nIllustrative Learning Outcomes: \nCS Core: \n1. Describe the differences between digital and analog systems, and between discrete and continuous systems. Can give real-world examples of these systems. \n2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Basic_Concepts.txt", ". \n2. Describe computations as a system characterized by a known set of configurations with transitions from one unique configuration (state) to another (state). \n3. Describe the distinction between systems whose output is only a function of their input (stateless) and those with memory/history (stateful). \n4. Develop state machine descriptions for simple problem statement solutions (e.g., traffic light sequencing, pattern recognizers). \n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Basic_Concepts.txt", ". \n5. Describe a computer as a state machine that interprets machine instructions. \n6. Explain how a program or network protocol can also be expressed as a state machine and that alternative representations for the same computation can exist. \n7. Derive the time-series behavior of a state machine from its state machine representation (e.g., TCP connection management state machine).  \n8. Write a simple sequential problem and a simple parallel version of the same program.  \n9"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Basic_Concepts.txt", ".  \n9. Evaluate the performance of simple sequential and parallel versions of a program with different problem sizes and be able to describe the speed-ups achieved. \n10. Describe on an execution timeline how parallelism events and operations can take place simultaneously (i.e., at the same time). Explain how work can be performed in less elapsed time if this can be exploited."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Ressource_Management.txt", "Page : 232\nCS Core : 1, KA Core : 1\n\nCS Core:  \n1. Different types of resources (e.g., processor share, memory, disk, net bandwidth) (See also: OS-Scheduling, OS-Memory, OS-Files, NC-Fundamentals) \n2. Common resource allocation/scheduling algorithms (e.g., first-come-first-serve, priority-based scheduling, fair scheduling, and preemptive scheduling) (See also: OS-Scheduling) \n \nKA Core:  \n3. Advantages and disadvantages of common scheduling algorithms (See also: OS-Scheduling)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Ressource_Management.txt", "Illustrative Learning Outcomes: \nCS Core: \n1. Define how finite computer resources (e.g., processor share, memory, storage, and network bandwidth) are managed by their careful allocation to existing entities. \n2. Describe how common resource allocation/scheduling algorithms work. \n3. Develop common scheduling algorithms and evaluate their performances. \n \nKA Core:  \n4. Describe the pros and cons of common scheduling algorithms."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt", "Pages : 230-231\nCS Core : 3, KA Core : 0"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt", "CS Core: \n1. Basic building blocks and components of a computer (gates, flip-flops, registers, interconnections; datapath + control + memory) \n2. Hardware as a computational paradigm: Fundamental logic building blocks; Logic expressions, minimization, sum of product forms (See also: AR-Logic) \n3. Programming abstractions, interfaces, use of libraries (See also: PDC-Programs) \n4. Distinction and interaction between application and OS services, remote procedure call (See also: OS-Purpose) \n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt", ". Basic concept of pipelining, overlapped processing stages (See also: AR-Organization) \n6. Basic concept of scaling: performance vs problem size \n \nIllustrative Learning Outcomes:  \nCS Core: \n1. Describe the basic building blocks of computers and their role in the historical development of computer architecture. \n2. Design a simple logic circuit using the fundamental building blocks of logic design to solve a simple problem (e.g., adder). \n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt", ".g., adder). \n3. Describe how computing systems are constructed of layers upon layers, based on separation of concerns, with well-defined interfaces, hiding details of low layers from the higher layers. \n4. Describe that hardware, OS, VM, and application are additional layers of interpretation/processing.  \n5. Describe the mechanisms of how errors are detected, signaled back, and handled through the layers.  \n6. Construct a simple program (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Overview_of_Computer_Systems.txt", ".  \n6. Construct a simple program (e.g., a TCP client/server) using methods of layering, error detection and recovery, and reflection of error status across layers. \n7. Identify bugs in a layered program by using tools for program tracing, single stepping, and debugging. \n8. Understand the concept of strong vs weak scaling, i.e., how performance is affected by the scale of the problem vs the scale of resources to solve the problem. This can be motivated by simple, real-world examples."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Performance_Evaluation.txt", "Pages : 233-234\nCS Core : 2, KA Core : 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Performance_Evaluation.txt", "CS Core: \n1. Performance figures of merit (See also: AR-Performance-Energy, PDC-Evaluation) \n2. Workloads and representative benchmarks, and methods of collecting and analyzing performance figures of merit (See also: AR-Performance-Energy, PDC-Evaluation) \n3. CPI (Cycles per Instruction) equation as a tool for understanding tradeoffs in the design of instruction sets, processor pipelines, and memory system organizations (See also: AR-Performance-Energy, PDC-Evaluation)  \n4"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Performance_Evaluation.txt", ". Amdahl\u2019s Law: the part of the computation that cannot be sped up limits the effect of the parts that can (See also: AR-Performance-Energy, PDC-Evaluation) \n5. Order of magnitude analysis (Big O notation) (See also: AL-Complexity) \n6. Analysis of slow and fast paths of a system (See also: AR-Organization) \n7. Events on their effect on performance (e.g., instruction stalls, cache misses, page faults) (See also: OS-Memory, AR-Organization) \n \nKA Core: \n7. Analytical tools to guide quantitative evaluation \n8"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Performance_Evaluation.txt", ". Understanding layered systems, workloads, and platforms, their implications for performance, and the challenges they represent for evaluation \n9. Microbenchmark pitfalls"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Performance_Evaluation.txt", "Illustrative Learning Outcomes: \nCS Core: \n1. Explain how the components of system architecture contribute to improving its performance.  \n2. Explain the circumstances in which a given figure of a system performance metric is useful. \n3. Explain the usage and inadequacies of benchmarks as a measure of system performance. \n4. Describe Amdahl\u2019s law and discuss its limitations. \n5"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Performance_Evaluation.txt", ". \n5. Apply limit studies or simple calculations to produce order-of-magnitude estimates for a given performance metric in a given context. \n6. Apply software tools to profile and measure program performance. \n \nKA Core: \n7. Design and conduct a performance-oriented experiment of a common system (e.g., an OS and Spark). \n8. Design a performance experiment on a layered system to determine the effect of a system parameter on system performance."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Reliability.txt", "Page : 234\nCS Core : 2, KA Core : 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Reliability.txt", "CS Core: \n1. Distinction between bugs, faults, and failures (See also: PDC-Coordination, SE-Reliability) \n2. Reliability vs availability \n3. Reliability through redundancy \na. check and retry (See also: OS-Faults, NC-Reliability) \nb. redundant encoding (error correction codes, CRC, FEC, RAID) (See also: AR-Memory, NC-Reliability, DM-Distributed) \nc. duplication/mirroring/replicas (See also: DM-Distributed) \n \nKA Core: \n4. Other approaches to reliability (e.g"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Reliability.txt", ". Other approaches to reliability (e.g., journaling) (See also: OS-Faults, NC-Reliability, SE-Reliability) \n \nIllustrative Learning Outcomes: \nCS Core: \n1. Explain the distinction between program errors, system errors, and hardware faults (e.g., corrupted memory) and exceptions (e.g., attempt to divide by zero).  \n2. Articulate the distinction between detecting, handling, and recovering from faults and the methods for their implementation. \n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Reliability.txt", ". \n3. Describe the role of error correction codes in providing error checking and correction techniques in memories, storage, and networks. \n4. Apply simple algorithms for exploiting redundant information for the purposes of data correction. \n \nKA Core:  \n5. Compare different error detection and correction methods for their data overhead, implementation complexity, and relative execution time for encoding, detecting, and correcting errors."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Design.txt", "Page : 235\nCS Core : 2, KA Core : 1"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Design.txt", "CS Core: \n1. Common criteria of system design (e.g., liveness, safety, robustness, scalability, and security) (See also: PDC-Evaluation) \n \nKA Core: \n2. Designs of representative systems (e.g., Apache web server, Spark, and Linux) \n \nIllustrative Learning Outcomes: \nCS Core: \n1. Describe common criteria of system design. \n2. Given the functionality requirements of a system and its key design criteria, provide a high-level design of this system.  \n \nKA Core: \n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Design.txt", ".  \n \nKA Core: \n3. Describe the design of some representative systems."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Performance.txt", "Pages : 232-233\nCS Core : 2, KA Core : 2"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Performance.txt", "CS Core: \n1. Latencies in computer systems \na. Speed of light and computers (one foot per nanosecond vs one GHz clocks) (See also: AR-Organization) \nb. Memory vs disk latencies vs across-the-network memory (See also: AR-Memory, AR-Performance-Energy) \n2. Caches and the effects of spatial and temporal locality on performance in processors and systems (See also: AR-Memory, AR-Performance-Energy, OS-Memory) \n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Performance.txt", ". Caches and cache coherency in databases, operating systems, distributed systems, and computer architecture (See also: OS-Memory, AR-Memory, DM-Internals) \n4. Introduction to the processor memory hierarchy (See also: AR-Memory, AR-Performance-Energy)  \n \nKA Core: \n5. The formula for average memory access time (See also: AR-Memory) \n6. Rationale of virtualization and isolation: protection and predictable performance (See also: OS-Virtualization) \n7"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Performance.txt", ". Levels of indirection, illustrated by virtual memory for managing physical memory resources (See also: OS-Virtualization) \n8. Methods for implementing virtual memory and virtual machines (See also: OS-Virtualization) \n \nIllustrative Learning Outcomes: \nCS Core: \n1. Describe the breakdown of the latency of computer systems in terms of memory, disk, and network. \n2. Explain the importance of locality in determining system performance. \n3"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Performance.txt", ". \n3. Calculate average memory access time and describe the tradeoffs in memory hierarchy performance in terms of capacity, miss/hit rate, and access time. \n \nKA Core: \n4. Explain why it is important to isolate and protect the execution of individual programs and environments that share common underlying resources.  \n5. Describe how the concept of indirection can create the illusion of a dedicated machine and its resources even when physically shared among multiple programs and environments. \n6"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-System_Performance.txt", ". \n6. Evaluate the performance of two application instances running on separate virtual machines and determine the effect of performance isolation."], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Society_Ethics_and_Profession.txt", "Pages : 235-236\nCS Core : None, KA Core : None\n(Hours here are included in Society, Ethics and the Profession Area)"], ["/home/ilefm/SLM-EXP/data/BodyOfKnowledge/System_Fundamentals_SF/SF-Society_Ethics_and_Profession.txt", "KA Core: \n1. Intellectual property rights of computer systems (See also: SEP-IP) \n2. Common software licenses (See also: SEP-IP) \n3. Computer crimes (See also: SEP-Security)  \n \nIllustrative Learning Outcomes: \nKA Core: \n1. Describe the intellectual property rights of computer systems. \n2. List representative software licenses and compare their differences. \n3. List representative computer crimes."]]